<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" 
  xmlns:content="http://purl.org/rss/1.0/modules/content/" 
  xmlns:dc="http://purl.org/dc/elements/1.1/" 
  xmlns:atom="http://www.w3.org/2005/Atom" 
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" 
  xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>technique on Nzo&#39;s Blog</title>
    <link>https://nianze.ml/en/tags/technique/</link>
    <description>Recent content in technique on Nzo&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <managingEditor>daoxinzhishui@gmail.com (Nzo)</managingEditor>
    <webMaster>daoxinzhishui@gmail.com (Nzo)</webMaster>
    <copyright>Â©2021, All Rights Reserved</copyright>
    <lastBuildDate>Tue, 05 May 2020 23:11:57 -0400</lastBuildDate>
    
        <atom:link href="https://nianze.ml/en/tags/technique/index.xml" rel="self" type="application/rss+xml" />
    

      
      <item>
        <title>Trade Sequencer</title>
        <link>https://nianze.ml/en/posts/2020/05/trade-sequencer/</link>
        <pubDate>Tue, 05 May 2020 23:11:57 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 05 May 2020 23:11:57 -0400</atom:modified>
        <guid>https://nianze.ml/en/posts/2020/05/trade-sequencer/</guid>
        <description>&lt;p&gt;A refined version of trade beats: combine multiple stocks in one sequencer, supported by React.js, Tone.js, and P5.js&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2020/05/05/trade-sequencer.jpg" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>music</category>
            
          
            
              <category>technique</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
      </item>
      
      <item>
        <title>Trade Beats</title>
        <link>https://nianze.ml/en/posts/2018/12/use-trading-market-data-to-create-beat-sounds/</link>
        <pubDate>Sun, 16 Dec 2018 00:00:00 +0000</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Sun, 16 Dec 2018 00:00:00 +0000</atom:modified>
        <guid>https://nianze.ml/en/posts/2018/12/use-trading-market-data-to-create-beat-sounds/</guid>
        <description>&lt;p&gt;What would it sound like if trading market data speaks?&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-12/16.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>music</category>
            
          
            
              <category>technique</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
      </item>
      
      <item>
        <title>[EMCpp]Item-40 Use std::atomic for Concurrency, volatile for Special Memory</title>
        <link>https://nianze.ml/en/notes/2018/10/use-stdatomic-for-concurrency-volatile-for-special-memory/</link>
        <pubDate>Tue, 30 Oct 2018 19:05:01 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 30 Oct 2018 19:05:01 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/10/use-stdatomic-for-concurrency-volatile-for-special-memory/</guid>
        <description>&lt;p&gt;&lt;code&gt;std::atomic&lt;/code&gt; is for data accessed from multiple threads without using mutexes (concurrent usage); &lt;code&gt;volatile&lt;/code&gt; is for memory where reads and writes should not be optimised away (special memory).&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-10/30.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-39 Consider Void Futures for One-Shot Event Communication</title>
        <link>https://nianze.ml/en/notes/2018/10/consider-void-futures-for-one-shot-event-communication/</link>
        <pubDate>Thu, 11 Oct 2018 19:23:06 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Thu, 11 Oct 2018 19:23:06 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/10/consider-void-futures-for-one-shot-event-communication/</guid>
        <description>&lt;p&gt;Using &lt;code&gt;std::promise&lt;/code&gt;s and futures is useful skill to create one-shot communication between a detecting task and reacting task.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-10/11.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-38 Be Aware of Varying Thread Handle Destructor Behavior</title>
        <link>https://nianze.ml/en/notes/2018/10/be-aware-of-varying-thread-handle-destructor-behavior/</link>
        <pubDate>Tue, 09 Oct 2018 19:42:16 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 09 Oct 2018 19:42:16 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/10/be-aware-of-varying-thread-handle-destructor-behavior/</guid>
        <description>&lt;p&gt;Future destructors normally just destroy the future&amp;rsquo;s data members, execept for the final future referring to a shared state for a non-deferred task launched via &lt;code&gt;std::async&lt;/code&gt;, which blocks until the task completes.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-10/09.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-37 Make std::threads Unjoinable on All Paths</title>
        <link>https://nianze.ml/en/notes/2018/10/make-stdthreads-unjoinable-on-all-paths/</link>
        <pubDate>Tue, 02 Oct 2018 19:16:09 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 02 Oct 2018 19:16:09 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/10/make-stdthreads-unjoinable-on-all-paths/</guid>
        <description>&lt;p&gt;&lt;em&gt;Join-on-destruction&lt;/em&gt; can lead to difficult-to-debug performance anomalies; while &lt;em&gt;detach-on-destruction&lt;/em&gt; can lead to difficult-to-debug undefined behavior.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-10/02.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-36 Specify std::launch::async if Asynchronicity Is Essential</title>
        <link>https://nianze.ml/en/notes/2018/10/specify-stdlaunchasync-if-asynchronicity-is-essential/</link>
        <pubDate>Mon, 01 Oct 2018 18:33:54 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Mon, 01 Oct 2018 18:33:54 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/10/specify-stdlaunchasync-if-asynchronicity-is-essential/</guid>
        <description>&lt;p&gt;The flexibility that default policy for &lt;code&gt;std::async&lt;/code&gt; permits both async and sync task execution leads to uncertainty when accessing &lt;code&gt;thread_locals&lt;/code&gt;, implies that the task may never execute, and affects program logic for timeout-based &lt;code&gt;wait&lt;/code&gt; calls.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-10/01.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-35 Prefer Task-Based Programming to Thread-Based</title>
        <link>https://nianze.ml/en/notes/2018/08/prefer-task-based-programming-to-thread-based/</link>
        <pubDate>Tue, 28 Aug 2018 10:19:06 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 28 Aug 2018 10:19:06 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/08/prefer-task-based-programming-to-thread-based/</guid>
        <description>&lt;p&gt;Thread-based programming calls for manual management of thread exhaustion, oversubscription, load balancing, and adaptation to new platforms, while task-based programming via &lt;code&gt;std::async&lt;/code&gt; with the default launch policy handles most of the issues for us.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-08/28.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-34 Prefer Lambdas to std::bind</title>
        <link>https://nianze.ml/en/notes/2018/08/prefer-lambdas-to-stdbind/</link>
        <pubDate>Fri, 24 Aug 2018 20:07:38 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Fri, 24 Aug 2018 20:07:38 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/08/prefer-lambdas-to-stdbind/</guid>
        <description>&lt;p&gt;Lambdas are more readable, more expressive, and may be more efficient than using &lt;code&gt;std::bind&lt;/code&gt;.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-08/24.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-33 Use decltype on auto&amp;&amp; parameters to std::forward them</title>
        <link>https://nianze.ml/en/notes/2018/08/use-decltype-on-auto-parameters-to-stdforward-them/</link>
        <pubDate>Thu, 23 Aug 2018 21:44:29 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Thu, 23 Aug 2018 21:44:29 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/08/use-decltype-on-auto-parameters-to-stdforward-them/</guid>
        <description>&lt;p&gt;C++14 introduces generic lambdas, which use &lt;code&gt;auto&lt;/code&gt; in their parameter specifications.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-08/23.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-32 Use Init Capture to Move Objects Into Closures</title>
        <link>https://nianze.ml/en/notes/2018/08/use-init-capture-to-move-objects-into-closures/</link>
        <pubDate>Wed, 22 Aug 2018 18:24:02 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Wed, 22 Aug 2018 18:24:02 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/08/use-init-capture-to-move-objects-into-closures/</guid>
        <description>&lt;p&gt;Use init capture to move objects into closures in C++14; emulate init capture via hand-written classes or &lt;code&gt;std::bind&lt;/code&gt; in C++11.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-08/22.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-31 Avoid Default Capture Modes</title>
        <link>https://nianze.ml/en/notes/2018/08/avoid-default-capture-modes/</link>
        <pubDate>Tue, 21 Aug 2018 19:22:22 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 21 Aug 2018 19:22:22 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/08/avoid-default-capture-modes/</guid>
        <description>&lt;p&gt;Default by-reference capture can lead to dangling references; default by-value capture is susceptible to dangling pointers, while misleadingly susggests the lambdas are self-contained.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-08/21.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-30 Failure Cases in Perfect Forwarding</title>
        <link>https://nianze.ml/en/notes/2018/08/failure-cases-in-perfect-forwarding/</link>
        <pubDate>Sun, 19 Aug 2018 16:10:34 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Sun, 19 Aug 2018 16:10:34 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/08/failure-cases-in-perfect-forwarding/</guid>
        <description>&lt;p&gt;Perfect forwarding fails when template type deduction fails or when it deduces the wrong type.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-08/19.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-29 Assume Move Operations Are Not Present Not Cheap, and Not Used</title>
        <link>https://nianze.ml/en/notes/2018/08/assume-move-operations-are-not-present-not-cheap-not-used/</link>
        <pubDate>Sat, 18 Aug 2018 15:15:12 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Sat, 18 Aug 2018 15:15:12 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/08/assume-move-operations-are-not-present-not-cheap-not-used/</guid>
        <description>&lt;p&gt;There are several scenarios in which C++11&amp;rsquo;s move semantics do us no good:&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-08/18.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-28 Understand Reference Collapsing</title>
        <link>https://nianze.ml/en/notes/2018/08/understand-reference-collapsing/</link>
        <pubDate>Fri, 17 Aug 2018 19:46:25 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Fri, 17 Aug 2018 19:46:25 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/08/understand-reference-collapsing/</guid>
        <description>&lt;p&gt;Reference collapsing occurs in four contexts: template instantiation, auto type generation, creation and use of typedefs and alias declarations, and decltype.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-08/17.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-27 Alternatives to Overloading on Universal References</title>
        <link>https://nianze.ml/en/notes/2018/08/alternatives-to-overloading-on-universal-references/</link>
        <pubDate>Wed, 15 Aug 2018 18:25:27 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Wed, 15 Aug 2018 18:25:27 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/08/alternatives-to-overloading-on-universal-references/</guid>
        <description>&lt;p&gt;Universal reference parameters often have efficiency advantages, but they typically have usability disadvantages.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-08/15.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-26 Avoid Overloading on Universal References</title>
        <link>https://nianze.ml/en/notes/2018/08/avoid-overloading-on-universal-references/</link>
        <pubDate>Mon, 13 Aug 2018 18:54:05 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Mon, 13 Aug 2018 18:54:05 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/08/avoid-overloading-on-universal-references/</guid>
        <description>&lt;p&gt;Overloading on universal references almost always leads to the universal reference overload being called more frequently than expected.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-08/13.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-25 Use std::move on Rvalue References, std::forward on Universal References</title>
        <link>https://nianze.ml/en/notes/2018/08/use-stdmove-on-rvalue-references-stdforward-on-universal-references/</link>
        <pubDate>Sat, 11 Aug 2018 15:26:53 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Sat, 11 Aug 2018 15:26:53 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/08/use-stdmove-on-rvalue-references-stdforward-on-universal-references/</guid>
        <description>&lt;p&gt;But don&amp;rsquo;t apply &lt;code&gt;std::move&lt;/code&gt; or &lt;code&gt;std::forward&lt;/code&gt; to local objects if they would otherwise be eligible for the return value optimization.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-08/11.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-24 Distinguish Universal References From Rvalue References</title>
        <link>https://nianze.ml/en/notes/2018/08/distinguish-universal-references-from-rvalue-references/</link>
        <pubDate>Wed, 08 Aug 2018 18:56:09 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Wed, 08 Aug 2018 18:56:09 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/08/distinguish-universal-references-from-rvalue-references/</guid>
        <description>&lt;p&gt;If a function template parameter has type &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; for a deduced type &lt;code&gt;T&lt;/code&gt;, or if an object is declared using &lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt;, the parameter or object is a &lt;em&gt;universal reference&lt;/em&gt;.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-08/08.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-23 Understand std::Move and std::Forward</title>
        <link>https://nianze.ml/en/notes/2018/08/understand-stdmove-and-stdforward/</link>
        <pubDate>Tue, 07 Aug 2018 17:57:26 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 07 Aug 2018 17:57:26 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/08/understand-stdmove-and-stdforward/</guid>
        <description>&lt;p&gt;&lt;code&gt;std::move&lt;/code&gt; performs an unconditional cast to an rvalue, while &lt;code&gt;std::forward&lt;/code&gt; casts its argument to an rvalue only if that argument is bound to an rvalue.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-08/07.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-22 When Using Pimple Idiom, Define Special Member Functions in the Implementation File</title>
        <link>https://nianze.ml/en/notes/2018/08/prefer-make_unique-and-make_shared-to-direct-use-of-new/</link>
        <pubDate>Sun, 05 Aug 2018 23:46:08 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Sun, 05 Aug 2018 23:46:08 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/08/prefer-make_unique-and-make_shared-to-direct-use-of-new/</guid>
        <description>&lt;p&gt;For &lt;code&gt;std::unique_ptr&lt;/code&gt; pImpl pointers, declare special member functions in the class header, but implement them in the implementation file.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-08/05.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-21 Prefer std::make_unique and std::make_shared to Direct Use of New</title>
        <link>https://nianze.ml/en/notes/2018/08/prefer-make_unique-and-make_shared-to-direct-use-of-new/</link>
        <pubDate>Thu, 02 Aug 2018 18:45:53 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Thu, 02 Aug 2018 18:45:53 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/08/prefer-make_unique-and-make_shared-to-direct-use-of-new/</guid>
        <description>&lt;p&gt;Compared to &lt;code&gt;new&lt;/code&gt;, make functions eliminate source code duplication, improve exception safety, and, for &lt;code&gt;std::make_shard&lt;/code&gt; and &lt;code&gt;std::allocate_shared&lt;/code&gt;, generate code that&amp;rsquo;s smaller and faster.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-08/02.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-20 Use Weak_ptr for Shared_ptr Like Pointers That Can Dangle</title>
        <link>https://nianze.ml/en/notes/2018/08/use-weak_ptr-for-shared_ptr-like-pointers-that-can-dangle/</link>
        <pubDate>Wed, 01 Aug 2018 18:44:19 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Wed, 01 Aug 2018 18:44:19 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/08/use-weak_ptr-for-shared_ptr-like-pointers-that-can-dangle/</guid>
        <description>&lt;p&gt;Potential use cases for &lt;code&gt;std::weak_ptr&lt;/code&gt; include caching, observer lists, and the prevention of &lt;code&gt;std::shared_ptr&lt;/code&gt; cycles.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-08/01.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-19 Use std::Shared_ptr for Shared-ownership Resource Management</title>
        <link>https://nianze.ml/en/notes/2018/07/use-shared_ptr-for-shared-ownership-resource-management/</link>
        <pubDate>Tue, 31 Jul 2018 17:59:25 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 31 Jul 2018 17:59:25 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/use-shared_ptr-for-shared-ownership-resource-management/</guid>
        <description>&lt;p&gt;&lt;code&gt;std::shared_ptrs&lt;/code&gt; offer convenience approaching that of garbage collection for the shared lifetime management of arbitrary resources.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/31.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-18 Use std::unique_ptr for Exclusive-ownership Resource Management</title>
        <link>https://nianze.ml/en/notes/2018/07/use-unique_ptr-for-exclusive-ownership-resource-management/</link>
        <pubDate>Mon, 30 Jul 2018 15:18:04 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Mon, 30 Jul 2018 15:18:04 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/use-unique_ptr-for-exclusive-ownership-resource-management/</guid>
        <description>&lt;p&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt; is a small, fast, move-only smart pointer for managing resources with exclusive-ownership semantics.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/30.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-17 Understand Special Member Function Generation</title>
        <link>https://nianze.ml/en/notes/2018/07/understand-special-member-function-generation/</link>
        <pubDate>Wed, 25 Jul 2018 20:26:53 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Wed, 25 Jul 2018 20:26:53 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/understand-special-member-function-generation/</guid>
        <description>&lt;p&gt;The special member functions are those ccompilers may generate on their own: default constructor, destructor, copy operations, and move operations.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/25.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-16 Make Const Member Functions Thread Safe</title>
        <link>https://nianze.ml/en/notes/2018/07/make-const-member-functions-thread-safe/</link>
        <pubDate>Tue, 24 Jul 2018 10:26:02 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 24 Jul 2018 10:26:02 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/make-const-member-functions-thread-safe/</guid>
        <description>&lt;p&gt;Make &lt;code&gt;const&lt;/code&gt; member functions thread safe unless we&amp;rsquo;re &lt;em&gt;certain&lt;/em&gt; they&amp;rsquo;ll never be used in a concurrent context.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/24.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-15 Use Constexpr Whenever Possible</title>
        <link>https://nianze.ml/en/notes/2018/07/use-constexpr-whenever-possible/</link>
        <pubDate>Mon, 23 Jul 2018 19:27:53 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Mon, 23 Jul 2018 19:27:53 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/use-constexpr-whenever-possible/</guid>
        <description>&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt; objects are &lt;code&gt;const&lt;/code&gt; and are initialized with values known during compilation; &lt;code&gt;constexpr&lt;/code&gt; functions can produce copmile-time results when called with arguments whose values are know during compilations.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/23.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-14 Declare Functions Noexcept if They Won&#39;t Emit Exception</title>
        <link>https://nianze.ml/en/notes/2018/07/declare-functions-noexcept-if-they-wont-emit-exception/</link>
        <pubDate>Fri, 20 Jul 2018 19:50:39 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Fri, 20 Jul 2018 19:50:39 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/declare-functions-noexcept-if-they-wont-emit-exception/</guid>
        <description>&lt;p&gt;Most functions are exception-neutral, but for some, such as move operations, swap, memory deallocation functions, and destructors, &lt;code&gt;noexcept&lt;/code&gt; is particularly valuable.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/20.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-13 Prefer Const_iterators to Iterators</title>
        <link>https://nianze.ml/en/notes/2018/07/prefer-const_iterators-to-iterators/</link>
        <pubDate>Thu, 19 Jul 2018 18:48:52 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Thu, 19 Jul 2018 18:48:52 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/prefer-const_iterators-to-iterators/</guid>
        <description>&lt;p&gt;In maximally generic code, prefer non-member versions of &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, &lt;code&gt;rbegin&lt;/code&gt;, etc., over their member function counterparts.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/19.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-12 Declare Overriding Functions Override</title>
        <link>https://nianze.ml/en/notes/2018/07/declare-overriding-functions-override/</link>
        <pubDate>Wed, 18 Jul 2018 19:19:07 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Wed, 18 Jul 2018 19:19:07 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/declare-overriding-functions-override/</guid>
        <description>&lt;p&gt;C++11 gives us a way to make explicit that a derived class function is supposed to override a base class version: &lt;code&gt;override&lt;/code&gt;.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/18.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Nodes on Clean Architecture</title>
        <link>https://nianze.ml/en/notes/2018/07/nodes-on-clean-architecture/</link>
        <pubDate>Tue, 17 Jul 2018 19:45:47 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 17 Jul 2018 19:45:47 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/nodes-on-clean-architecture/</guid>
        <description>&lt;p&gt;A brief notes on Clean Architecture&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/17.jpg" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-11 Prefer Deleted Functions to Private Undefined Ones</title>
        <link>https://nianze.ml/en/notes/2018/07/prefer-deleted-functions-to-private-undefined-ones/</link>
        <pubDate>Mon, 16 Jul 2018 21:22:57 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Mon, 16 Jul 2018 21:22:57 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/prefer-deleted-functions-to-private-undefined-ones/</guid>
        <description>&lt;p&gt;Any function may be deleted, including non-member functions and template instantiations.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/16.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-10 Prefer Scoped enums to Unscopded enums</title>
        <link>https://nianze.ml/en/notes/2018/07/prefer-scoped-enums-to-unscopded-enums/</link>
        <pubDate>Sat, 14 Jul 2018 13:33:33 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Sat, 14 Jul 2018 13:33:33 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/prefer-scoped-enums-to-unscopded-enums/</guid>
        <description>&lt;p&gt;Enumerators of scoped &lt;code&gt;enum&lt;/code&gt;s are visible only within the &lt;code&gt;enum&lt;/code&gt;, convert to other types only with a cast, and always support forward-declared because their default underlying type is &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/14.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-9 Prefer Alias Declarations to Typedefs</title>
        <link>https://nianze.ml/en/notes/2018/07/prefer-alias-declarations-to-typedefs/</link>
        <pubDate>Thu, 12 Jul 2018 13:03:01 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Thu, 12 Jul 2018 13:03:01 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/prefer-alias-declarations-to-typedefs/</guid>
        <description>&lt;p&gt;Alias declaration support templatization, which avoids the &amp;ldquo;::type&amp;rdquo; suffix and &amp;ldquo;typename&amp;rdquo; prefix often required to refer &lt;code&gt;typedef&lt;/code&gt;s.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/12.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-8 Prefer Nullptr to 0 and NULL</title>
        <link>https://nianze.ml/en/notes/2018/07/prefer-nullptr-to-0-and-null/</link>
        <pubDate>Wed, 11 Jul 2018 18:03:51 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Wed, 11 Jul 2018 18:03:51 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/prefer-nullptr-to-0-and-null/</guid>
        <description>&lt;p&gt;&lt;code&gt;nullptr&lt;/code&gt; doean&amp;rsquo;t suffer from the overloading problem or the template deduction problem that 0 and &lt;code&gt;NULL&lt;/code&gt; are susceptible to. It also improves code clarity.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/11.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-7 Distinguish Betwenn () and {} When Creating Objects</title>
        <link>https://nianze.ml/en/notes/2018/07/distinguish-betwenn-and-when-creating-objects/</link>
        <pubDate>Tue, 10 Jul 2018 18:55:06 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 10 Jul 2018 18:55:06 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/distinguish-betwenn-and-when-creating-objects/</guid>
        <description>&lt;p&gt;Braced initialization is the most widely usable initialization syntax, which can also prevent narrowing conversions, as well as being immune to C++&amp;rsquo;s most vexing parse.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/10.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-6 Use the Explicitly Typed Initializer Idiom when auto deduces undesired types</title>
        <link>https://nianze.ml/en/notes/2018/07/use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types/</link>
        <pubDate>Sun, 08 Jul 2018 13:32:48 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Sun, 08 Jul 2018 13:32:48 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types/</guid>
        <description>&lt;p&gt;âInvisibleâ proxy types can cause &lt;code&gt;auto&lt;/code&gt; to deduce the undesired type for an initializing expression, so we can adopt explicitly typed initializer idiom to force &lt;code&gt;auto&lt;/code&gt; to deduce what we want.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/08.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-5 Prefer Auto to Explicit Type Declarations</title>
        <link>https://nianze.ml/en/notes/2018/07/prefer-auto-to-explicit-type-declarations/</link>
        <pubDate>Sat, 07 Jul 2018 13:33:06 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Sat, 07 Jul 2018 13:33:06 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/prefer-auto-to-explicit-type-declarations/</guid>
        <description>&lt;p&gt;Despite some pitfalls described in EMCpp item 2 and 6, &lt;code&gt;auto&lt;/code&gt; variables are preferred for they must be initialized, are generally immune to type mismatches that can lead to portability or efficiency problems, can ease the process of refactoring, and typically require less typing than variables with explicitly specified types.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/07.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-4 Know How to View Deduced Types</title>
        <link>https://nianze.ml/en/notes/2018/07/know-how-to-view-deduced-types/</link>
        <pubDate>Fri, 06 Jul 2018 10:08:00 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Fri, 06 Jul 2018 10:08:00 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/know-how-to-view-deduced-types/</guid>
        <description>&lt;p&gt;Deduced types can often be seen using IDE editors, compiler error messages, and the Boost TypeIndex library, but the results of some tools may be neither helpful nor accurate.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/06.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-3 Understand Decltype</title>
        <link>https://nianze.ml/en/notes/2018/07/understand-decltype/</link>
        <pubDate>Thu, 05 Jul 2018 18:59:39 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Thu, 05 Jul 2018 18:59:39 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/understand-decltype/</guid>
        <description>&lt;p&gt;&lt;code&gt;decltype&lt;/code&gt; almost always yields the type of a variable or expression without any modifications. For lvalue expressions of type T other than names, &lt;code&gt;decltype&lt;/code&gt; always reports a type of T&amp;amp;.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/05.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-2 Understand Auto Type Deduction</title>
        <link>https://nianze.ml/en/notes/2018/07/understand-auto-type-deduction/</link>
        <pubDate>Tue, 03 Jul 2018 10:07:13 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 03 Jul 2018 10:07:13 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/understand-auto-type-deduction/</guid>
        <description>&lt;p&gt;&lt;code&gt;auto&lt;/code&gt; type deduction is usually the same as template type deduction, with an exception in the case of braced initializer. Also, in C++14, as a function return type or a lambda parameter, &lt;code&gt;auto&lt;/code&gt; implies template type deduction instead of &lt;code&gt;auto&lt;/code&gt; type deduction.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/03.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[EMCpp]Item-1 Understand Template Type Deduction</title>
        <link>https://nianze.ml/en/notes/2018/07/understand-template-type-deduction/</link>
        <pubDate>Mon, 02 Jul 2018 22:44:34 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Mon, 02 Jul 2018 22:44:34 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/understand-template-type-deduction/</guid>
        <description>&lt;p&gt;There are three sets of rules for type deduction in modern C++: one for function templates, one for &lt;code&gt;auto&lt;/code&gt;, and one for &lt;code&gt;decltype&lt;/code&gt;. Without a solid understanding of how deduction operates, effective programming in modern C++ is all but impossible.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/02.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>A Brief Review of Dynamo</title>
        <link>https://nianze.ml/en/notes/2018/07/a-brif-review-of-dynamo/</link>
        <pubDate>Sun, 01 Jul 2018 23:03:34 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Sun, 01 Jul 2018 23:03:34 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/07/a-brif-review-of-dynamo/</guid>
        <description>&lt;p&gt;As a highly available and scalable distributed data store, the design principles of Dynamo features high availability for writes (via reconciliation during reads), incremental scalability (consistent hashing), symmetry, decentralization, and heterogeneity (via virtual nodes).&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-07/01.png" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-34 Understand How to Combine C&#43;&#43; and C in the Same Program</title>
        <link>https://nianze.ml/en/notes/2018/05/understand-how-to-combine-c&#43;&#43;-and-c-in-the-same-program/</link>
        <pubDate>Wed, 23 May 2018 18:38:10 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Wed, 23 May 2018 18:38:10 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/05/understand-how-to-combine-c&#43;&#43;-and-c-in-the-same-program/</guid>
        <description>&lt;p&gt;There are five points worth noting if we want to mix C++ and C in the same program.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-05/2018-05-23.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-33 Make Non-Leaf Classes Abstract</title>
        <link>https://nianze.ml/en/notes/2018/05/make-non-leaf-classes-abstract/</link>
        <pubDate>Mon, 21 May 2018 18:27:39 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Mon, 21 May 2018 18:27:39 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/05/make-non-leaf-classes-abstract/</guid>
        <description>&lt;p&gt;The general rule: non-leaf classes should be abstract. This will yields dividends in the form of increased reliability, robustness, comprehensibility, and extensibility throughout our software.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-05/2018-05-21.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-32 Program in the Future Tense</title>
        <link>https://nianze.ml/en/notes/2018/05/program-in-the-future-tense/</link>
        <pubDate>Thu, 17 May 2018 19:26:17 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Thu, 17 May 2018 19:26:17 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/05/program-in-the-future-tense/</guid>
        <description>&lt;p&gt;Things change. Future tense thinking increases the reusability of the code we write, enhances its maintainability, makes it more robust, and facilitates gracefully in an environment where change is a certainty.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-05/2018-05-17.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-31 Making Functions Virtual With Respect to More Than One Object</title>
        <link>https://nianze.ml/en/notes/2018/05/making-functions-virtual-with-respect-to-more-than-one-object/</link>
        <pubDate>Fri, 11 May 2018 00:00:00 +0000</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Fri, 11 May 2018 00:00:00 +0000</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/05/making-functions-virtual-with-respect-to-more-than-one-object/</guid>
        <description>&lt;p&gt;A virtual function call is termed a &amp;ldquo;message dispatch.&amp;rdquo; A call that acts virtual on multiple parameters is called &lt;em&gt;multiple dispatch&lt;/em&gt;, which is not directly supported in C++. Several resolutions exist, but none is without its disadvantages.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-05/2018-05-11.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-30 Proxy Classes</title>
        <link>https://nianze.ml/en/notes/2018/05/proxy-classes/</link>
        <pubDate>Wed, 09 May 2018 00:00:00 +0000</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Wed, 09 May 2018 00:00:00 +0000</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/05/proxy-classes/</guid>
        <description>&lt;p&gt;Objects that stand for other objects are often called &lt;em&gt;proxy objects&lt;/em&gt; (or &lt;em&gt;surrogates&lt;/em&gt;), and the classes that give rise to proxy objects are often called &lt;em&gt;proxy classes&lt;/em&gt;, which is useful for implementing multidimensional arrays, differentiating lvalue/rvalue, and suppressing implicit conversions.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-05/2018-05-09.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-29 Reference Counting</title>
        <link>https://nianze.ml/en/notes/2018/05/reference-counting/</link>
        <pubDate>Mon, 07 May 2018 00:00:00 +0000</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Mon, 07 May 2018 00:00:00 +0000</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/05/reference-counting/</guid>
        <description>&lt;p&gt;Reference counting is technique that allows multiple objects with the same value to share a sinple representation of that value.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-05/2018-05-07.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-28 Smart Pointers</title>
        <link>https://nianze.ml/en/notes/2018/05/smart-pointers/</link>
        <pubDate>Sat, 05 May 2018 16:38:03 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Sat, 05 May 2018 16:38:03 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/05/smart-pointers/</guid>
        <description>&lt;p&gt;&lt;em&gt;Smart pointers&lt;/em&gt; are designed to look, act, and feel like built-in pointers, but to offer greater functionality.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-05/2018-05-05.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-27 Requiring or Prohibiting Heap Based Objects</title>
        <link>https://nianze.ml/en/notes/2018/05/requiring-or-prohibiting-heap-based-objects/</link>
        <pubDate>Tue, 01 May 2018 00:00:00 +0000</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 01 May 2018 00:00:00 +0000</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/05/requiring-or-prohibiting-heap-based-objects/</guid>
        <description>&lt;p&gt;Techniques for requiring or prohibiting heap-based objects&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-05/2018-05-01.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-26 Limiting the Number of Objects of a Class</title>
        <link>https://nianze.ml/en/notes/2018/04/limiting-the-number-of-objects-of-a-class/</link>
        <pubDate>Tue, 24 Apr 2018 15:03:26 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 24 Apr 2018 15:03:26 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/04/limiting-the-number-of-objects-of-a-class/</guid>
        <description>&lt;p&gt;Combining object-counting technique with the pseudo-constructors, we can limit the number of objects of a class.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-04/2018-04-24.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-25 Virtualizing Constructors and Non-Member Functions</title>
        <link>https://nianze.ml/en/notes/2018/04/virtualizing-constructors-and-non-member-functions/</link>
        <pubDate>Mon, 23 Apr 2018 13:30:56 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Mon, 23 Apr 2018 13:30:56 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/04/virtualizing-constructors-and-non-member-functions/</guid>
        <description>&lt;p&gt;Depending on the different input or dynamic types of function parameters, &amp;ldquo;virtualization&amp;rdquo; is a useful technique to construct new objects of different types accordingly, or to conceive of non-member functions whose behavior changes accordingly.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-04/2018-04-23.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-24 Understand the Costs of Virtual Functions, Multiple Inheritance, Virtual Base Classes, and RTTI</title>
        <link>https://nianze.ml/en/notes/2018/04/costs-of-virtual-functions-multiple-inheritance-virtual-base-classes-and-rtti/</link>
        <pubDate>Fri, 20 Apr 2018 15:32:45 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Fri, 20 Apr 2018 15:32:45 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/04/costs-of-virtual-functions-multiple-inheritance-virtual-base-classes-and-rtti/</guid>
        <description>&lt;p&gt;It&amp;rsquo;s important to have a basic understanding of the cost of some C++ features that can have a noticeable impact on the size of objects and the speed at which member functions execute.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-04/2018-04-20.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-23 Consider Alternative Libraries</title>
        <link>https://nianze.ml/en/notes/2018/04/consider-alternative-libraries/</link>
        <pubDate>Thu, 19 Apr 2018 13:32:15 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Thu, 19 Apr 2018 13:32:15 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/04/consider-alternative-libraries/</guid>
        <description>&lt;p&gt;Different libraries offering similar functionality often feature different performance trade-offs, so we might be able to remove bottlenecks by replacing one library with another.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-04/2018-04-19.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-22 Consider Using op= Instead of Stand Alone op</title>
        <link>https://nianze.ml/en/notes/2018/04/consider-using-op-instead-of-stand-alone-op/</link>
        <pubDate>Wed, 18 Apr 2018 14:09:10 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Wed, 18 Apr 2018 14:09:10 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/04/consider-using-op-instead-of-stand-alone-op/</guid>
        <description>&lt;p&gt;Assignment versions of operators (such as &lt;code&gt;operator+=&lt;/code&gt;) tend to be more efficient than stand-alone versions of those operators (e.g., &lt;code&gt;operator+&lt;/code&gt;).&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-04/2018-04-18.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-21 Overload to Avoid Implicit Type Conventions</title>
        <link>https://nianze.ml/en/notes/2018/04/overload-to-avoid-implicit-type-conventions/</link>
        <pubDate>Tue, 17 Apr 2018 15:42:12 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 17 Apr 2018 15:42:12 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/04/overload-to-avoid-implicit-type-conventions/</guid>
        <description>&lt;p&gt;Overloading to avoid temporaries.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-04/2018-04-17.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-20 Facilitate the Return Value Optimization</title>
        <link>https://nianze.ml/en/notes/2018/04/facilitate-the-return-value-optimization/</link>
        <pubDate>Mon, 16 Apr 2018 00:00:00 +0000</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Mon, 16 Apr 2018 00:00:00 +0000</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/04/facilitate-the-return-value-optimization/</guid>
        <description>&lt;p&gt;Take use of the &lt;em&gt;return value optimization&lt;/em&gt; in compilers.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-04/2018-04-16.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-19 Understand the Origin of Temporary Objects</title>
        <link>https://nianze.ml/en/notes/2018/04/understand-the-origin-of-temporary-objects/</link>
        <pubDate>Fri, 13 Apr 2018 17:06:28 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Fri, 13 Apr 2018 17:06:28 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/04/understand-the-origin-of-temporary-objects/</guid>
        <description>&lt;p&gt;Unnamed non-heap objects are invisible temporary objects in C++.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-04/2018-04-13.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-18 Amortize the Cost of Expected Computations</title>
        <link>https://nianze.ml/en/notes/2018/04/amortize-the-cost-of-expected-computations/</link>
        <pubDate>Thu, 12 Apr 2018 15:31:55 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Thu, 12 Apr 2018 15:31:55 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/04/amortize-the-cost-of-expected-computations/</guid>
        <description>&lt;p&gt;The old Computer Science story: trade space for time&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-04/2018-04-12.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-17 Consider Using Lazy Evaluation</title>
        <link>https://nianze.ml/en/notes/2018/04/consider-using-lazy-evaluation/</link>
        <pubDate>Wed, 11 Apr 2018 14:02:18 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Wed, 11 Apr 2018 14:02:18 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/04/consider-using-lazy-evaluation/</guid>
        <description>&lt;p&gt;The best computations are those we never perform at all.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-04/2018-04-11.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-16 Remember 80-20 Rule</title>
        <link>https://nianze.ml/en/notes/2018/04/remember-80-20-rule/</link>
        <pubDate>Tue, 10 Apr 2018 13:37:45 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 10 Apr 2018 13:37:45 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/04/remember-80-20-rule/</guid>
        <description>&lt;p&gt;The 80-20 rule states that 80 percent of a program&amp;rsquo;s resources are used by about 20 percent of the code.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-04/2018-04-10.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-15 Understand the Costs of Exception Handling</title>
        <link>https://nianze.ml/en/notes/2018/04/understand-the-costs-of-exception-handling/</link>
        <pubDate>Mon, 09 Apr 2018 18:10:06 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Mon, 09 Apr 2018 18:10:06 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/04/understand-the-costs-of-exception-handling/</guid>
        <description>&lt;p&gt;Exception handling has costs, and we pay at least some of them even if we never use the keywords &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, or &lt;code&gt;catch&lt;/code&gt;.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-04/2018-04-09.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-14 Use Exception Specifications Judiciously</title>
        <link>https://nianze.ml/en/notes/2018/04/use-exception-specifications-judiciously/</link>
        <pubDate>Sun, 08 Apr 2018 23:51:00 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Sun, 08 Apr 2018 23:51:00 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/04/use-exception-specifications-judiciously/</guid>
        <description>&lt;p&gt;Exception specifications provide a documentation aid and an enforcement mechanism for constraints on exception usage, but they are only partly checked by compilers and they are easy to violate inadvertently.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-04/2018-04-08.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-13 Catch Exceptions by Reference</title>
        <link>https://nianze.ml/en/notes/2018/04/catch-exceptions-by-reference/</link>
        <pubDate>Thu, 05 Apr 2018 18:57:13 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Thu, 05 Apr 2018 18:57:13 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/04/catch-exceptions-by-reference/</guid>
        <description>&lt;p&gt;If catching by reference, we sidestep the questions about object deletion, avoid slicing exception objects, retain the ability to catch standard exceptions, and limit the number of times exception objects being copied.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-04/2018-04-05.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-12 Understand How Throwing an Exception Differs From Passing a Parameter or Calling a Virtual Function</title>
        <link>https://nianze.ml/en/notes/2018/04/understand-how-throwing-an-exception-differs-from-passing-a-parameter-or-calling-a-virtual-function/</link>
        <pubDate>Wed, 04 Apr 2018 11:28:07 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Wed, 04 Apr 2018 11:28:07 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/04/understand-how-throwing-an-exception-differs-from-passing-a-parameter-or-calling-a-virtual-function/</guid>
        <description>&lt;p&gt;There are three primary ways in which passing an object to a function or using that object to invoke a virtual function differs from throwing the object as an exception.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-04/2018-04-04.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-11 Prevent Exceptions From Leaving Destructors</title>
        <link>https://nianze.ml/en/notes/2018/04/prevent-exceptions-from-leaving-destructors/</link>
        <pubDate>Tue, 03 Apr 2018 10:54:39 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 03 Apr 2018 10:54:39 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/04/prevent-exceptions-from-leaving-destructors/</guid>
        <description>&lt;p&gt;Keep exceptions from propagating out of destructors to prevent C++ calling &lt;code&gt;terminate&lt;/code&gt; during the statck-unwinding part of exception propagation and ensure that every neccessary cleanup is accomplished.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-04/2018-04-03.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-10 Prevent Resource Leaks in Constructors</title>
        <link>https://nianze.ml/en/notes/2018/04/prevent-resource-leaks-in-constructors/</link>
        <pubDate>Mon, 02 Apr 2018 15:56:25 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Mon, 02 Apr 2018 15:56:25 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/04/prevent-resource-leaks-in-constructors/</guid>
        <description>&lt;p&gt;Replace pointer class members with their corresponding smart pointer objects to fortify the constructors against resource leaks in the presence of exceptions, to eliminate the need to manually deallocate resources in destructors, and to allow &lt;code&gt;const&lt;/code&gt; member pointers to be handled in the smae graceful fashion as non-&lt;code&gt;const&lt;/code&gt; pointers.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-04/2018-04-02.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-9 Use Destructors to Prevent Resource Leaks</title>
        <link>https://nianze.ml/en/notes/2018/04/use-destructors-to-prevent-resource-leaks/</link>
        <pubDate>Sun, 01 Apr 2018 00:00:00 +0000</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Sun, 01 Apr 2018 00:00:00 +0000</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/04/use-destructors-to-prevent-resource-leaks/</guid>
        <description>&lt;p&gt;To avoid resource leaks in the presence of exceptions, we can encapsulate resources inside objects.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-04/2018-04-01.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-8 Understand the Different Meanings of New and Delete</title>
        <link>https://nianze.ml/en/notes/2018/03/understand-the-different-meanings-of-new-and-delete/</link>
        <pubDate>Fri, 30 Mar 2018 17:09:04 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Fri, 30 Mar 2018 17:09:04 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/understand-the-different-meanings-of-new-and-delete/</guid>
        <description>&lt;p&gt;The behaviors of &lt;code&gt;new&lt;/code&gt; operator and &lt;code&gt;operator new&lt;/code&gt; is different.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-30.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-7 Never Overload &#39;&amp;&amp;&#39;, &#39;||&#39;, or &#39;,&#39;</title>
        <link>https://nianze.ml/en/notes/2018/03/never-overload-and-or-comma-operator/</link>
        <pubDate>Thu, 29 Mar 2018 11:18:24 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Thu, 29 Mar 2018 11:18:24 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/never-overload-and-or-comma-operator/</guid>
        <description>&lt;p&gt;If we don&amp;rsquo;t have a good reason for overloading an operator, don&amp;rsquo;t overload it. In the case of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, and &lt;code&gt;,&lt;/code&gt;, it&amp;rsquo;s difficult to have a good reason: we can&amp;rsquo;t make them behave the way they&amp;rsquo;re supposed to.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-29.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-6 Distinguish Between Prefix and Postfix Forms of Increment and Decrement Operators</title>
        <link>https://nianze.ml/en/notes/2018/03/distinguish-between-prefix-and-postfix-forms-of-increment-and-decrement-operators/</link>
        <pubDate>Wed, 28 Mar 2018 13:03:10 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Wed, 28 Mar 2018 13:03:10 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/distinguish-between-prefix-and-postfix-forms-of-increment-and-decrement-operators/</guid>
        <description>&lt;p&gt;The prefix and postfix forms of increment and decrement operators return &lt;em&gt;different types&lt;/em&gt;: prefix forms return a reference, while postfix forms return a &lt;em&gt;const&lt;/em&gt; object. For efficiency, prefer prefix forms unless the behavior of postfix ones is necessary. To guarantee consistency, implement postfix operators in terms of the prefix operators.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-28.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-5 Be Wary of User Defined Conversion Functions</title>
        <link>https://nianze.ml/en/notes/2018/03/be-wary-of-user-defined-conversion-functions/</link>
        <pubDate>Tue, 27 Mar 2018 18:53:56 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 27 Mar 2018 18:53:56 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/be-wary-of-user-defined-conversion-functions/</guid>
        <description>&lt;p&gt;Implicit type conversions usually lead to more harm than good, so don&amp;rsquo;t provide conversion functions unless we&amp;rsquo;re sure we want them.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-27.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-4 Avoid Gratuitous Default Constructors</title>
        <link>https://nianze.ml/en/notes/2018/03/avoid-gratuitous-default-constructors/</link>
        <pubDate>Mon, 26 Mar 2018 11:21:08 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Mon, 26 Mar 2018 11:21:08 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/avoid-gratuitous-default-constructors/</guid>
        <description>&lt;p&gt;Including meaningless default constructors affects the efficiency of classes, so avoiding them in classes guarantees fully-initialized objects, with the cost of some limits on how such classes can be used.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-26.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-3 Never Treat Arrays Polymorphically</title>
        <link>https://nianze.ml/en/notes/2018/03/never-treat-arrays-polymorphically/</link>
        <pubDate>Fri, 23 Mar 2018 18:59:16 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Fri, 23 Mar 2018 18:59:16 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/never-treat-arrays-polymorphically/</guid>
        <description>&lt;p&gt;Array operations almost always involve pointer arithmetic, so arrays and polymorphism don&amp;rsquo;t mix.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-23.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>[MECpp]Item-1 Distinguish Between Pointers and References</title>
        <link>https://nianze.ml/en/notes/2018/03/distinguish-between-pointers-and-references/</link>
        <pubDate>Thu, 22 Mar 2018 16:47:15 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Thu, 22 Mar 2018 16:47:15 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/distinguish-between-pointers-and-references/</guid>
        <description>&lt;p&gt;More effective C++: Use references when we already have something to refer to and never want to refer to anything else, or when implementing operators whose syntactic requires us to do so.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-22.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-52 Write placement delete if you write placement new</title>
        <link>https://nianze.ml/en/notes/2018/03/write-placement-delete-if-you-write-placement-new/</link>
        <pubDate>Wed, 21 Mar 2018 15:48:12 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Wed, 21 Mar 2018 15:48:12 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/write-placement-delete-if-you-write-placement-new/</guid>
        <description>&lt;p&gt;When we write a placement version of &lt;code&gt;operator new&lt;/code&gt;, be sure to write the corresponding placement version of &lt;code&gt;operator delete&lt;/code&gt; to avoid subtle, intermittent memory leaks. When we do so, pay attention not to unintentionally hide the normal versions of &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-21.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-51 Adhere to convention when writing new and delete</title>
        <link>https://nianze.ml/en/notes/2018/03/adhere-to-convention-when-writing-new-and-delete/</link>
        <pubDate>Tue, 20 Mar 2018 14:32:24 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 20 Mar 2018 14:32:24 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/adhere-to-convention-when-writing-new-and-delete/</guid>
        <description>&lt;p&gt;&lt;code&gt;operator new&lt;/code&gt; should contain an infinite loop trying to allocate memory, should call the new-handler if it can&amp;rsquo;t satisfy a memory request, and should handle requests for zero bytes; class-specific versions should handle requests for larger blocks than expected. &lt;code&gt;operator delete&lt;/code&gt; should do nothing if passed a pointer that is null; class specific versions should handle blocks that are larger than expected.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-20.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-50 Understand when it makes sense to replace new and delete</title>
        <link>https://nianze.ml/en/notes/2018/03/understand-when-it-makes-sense-to-replace-new-and-delete/</link>
        <pubDate>Mon, 19 Mar 2018 10:54:04 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Mon, 19 Mar 2018 10:54:04 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/understand-when-it-makes-sense-to-replace-new-and-delete/</guid>
        <description>&lt;p&gt;There are many valid reasons for writing custom versions of &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, including improving performance, debugging heap usage errors, and collecting heap usage information.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-19.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-49 Understand the behavior of the new handler</title>
        <link>https://nianze.ml/en/notes/2018/03/understand-the-behavior-of-the-new-handler/</link>
        <pubDate>Fri, 16 Mar 2018 19:52:09 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Fri, 16 Mar 2018 19:52:09 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/understand-the-behavior-of-the-new-handler/</guid>
        <description>&lt;p&gt;&lt;code&gt;set-new-handler&lt;/code&gt; allows you to specify a function to be called when memory allocation requests cannot be satisfied.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-16.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-48 Be aware of template metaprogramming</title>
        <link>https://nianze.ml/en/notes/2018/03/be-aware-of-template-metaprogramming/</link>
        <pubDate>Thu, 15 Mar 2018 23:00:22 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Thu, 15 Mar 2018 23:00:22 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/be-aware-of-template-metaprogramming/</guid>
        <description>&lt;p&gt;Template metaprogramming can shift work from runtime to compile-time (thus enabling earlier error dettection and higher runtime performance), can be used to generate custom code based on combinations of policy choices, and can also be used to avoid generating code inappropriate for particular types.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-15.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-47 Use traits classes for information about types</title>
        <link>https://nianze.ml/en/notes/2018/03/use-traits-classes-for-information-about-types/</link>
        <pubDate>Wed, 14 Mar 2018 18:49:03 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Wed, 14 Mar 2018 18:49:03 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/use-traits-classes-for-information-about-types/</guid>
        <description>&lt;p&gt;Implemented by templates and template specializations, traits classes make information about types available during compilation. Combining traints with overloading, it is possible to perform compile-time &lt;code&gt;if...else&lt;/code&gt; tests on types.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-14.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-46 Define non-member function inside templates when type conversions are desired</title>
        <link>https://nianze.ml/en/notes/2018/03/define-non-member-function-inside-templates-when-type-conversions-are-desired/</link>
        <pubDate>Tue, 13 Mar 2018 12:23:40 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 13 Mar 2018 12:23:40 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/define-non-member-function-inside-templates-when-type-conversions-are-desired/</guid>
        <description>&lt;p&gt;When writing a class template that offers functions related to the template that support implicit type conversions on all parameters, define those functions as friends inside the class template.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-13.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-45 Use member function templates to accept all compatible types</title>
        <link>https://nianze.ml/en/notes/2018/03/use-member-function-templates-to-accept-all-compatible-types/</link>
        <pubDate>Mon, 12 Mar 2018 20:14:47 -0400</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Mon, 12 Mar 2018 20:14:47 -0400</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/use-member-function-templates-to-accept-all-compatible-types/</guid>
        <description>&lt;p&gt;In order to implicitly convert all compatible types for a template class, we neet not a constructor &lt;em&gt;function&lt;/em&gt; but a constructor &lt;em&gt;template&lt;/em&gt; - &lt;em&gt;member functoin templates&lt;/em&gt; that generate member functions of a class.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-12.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-44 Factor parameter-independent code out of templates</title>
        <link>https://nianze.ml/en/notes/2018/03/factor-parameter-independent-code-out-of-templates/</link>
        <pubDate>Sat, 10 Mar 2018 20:24:42 -0500</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Sat, 10 Mar 2018 20:24:42 -0500</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/factor-parameter-independent-code-out-of-templates/</guid>
        <description>&lt;p&gt;Templates generate multiple classes and multiple functions, so any template code not dependent on a template parameter (either non-type template parameters or type parameters) causes bloat: eliminate bloat due to non-type template parameters by replacing template parameters with function parameters or class data members; reduce bloat caused from type parameters by sharing implementations for instantiation types with identical binary representations.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-10.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-43 Know how to access names in templatized base classes</title>
        <link>https://nianze.ml/en/notes/2018/03/know-how-to-access-names-in-templatized-base-classes/</link>
        <pubDate>Fri, 09 Mar 2018 21:48:26 -0500</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Fri, 09 Mar 2018 21:48:26 -0500</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/know-how-to-access-names-in-templatized-base-classes/</guid>
        <description>&lt;p&gt;In derived class templates, refer to names in base class templates via a &lt;code&gt;this-&amp;gt;&lt;/code&gt; prefix, via &lt;code&gt;using&lt;/code&gt; declarations, or via an explicit base class qualification.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-09.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-42 Understand the two meanings of typename</title>
        <link>https://nianze.ml/en/notes/2018/03/understand-the-two-meanings-of-typename/</link>
        <pubDate>Thu, 08 Mar 2018 19:19:28 -0500</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Thu, 08 Mar 2018 19:19:28 -0500</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/understand-the-two-meanings-of-typename/</guid>
        <description>&lt;p&gt;When declaring template parameters, both &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;typename&lt;/code&gt; are interchangeable. When identifying nested dependent type names, use &lt;code&gt;typename&lt;/code&gt;, except in base class lists or as a base class identifier in a member initialization list.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-08.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-41 Understand inplicit interfaces and compile time polymorphism</title>
        <link>https://nianze.ml/en/notes/2018/03/understand-inplicit-interfaces-and-compile-time-polymorphism/</link>
        <pubDate>Wed, 07 Mar 2018 14:21:33 -0500</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Wed, 07 Mar 2018 14:21:33 -0500</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/understand-inplicit-interfaces-and-compile-time-polymorphism/</guid>
        <description>&lt;p&gt;Classes support explicit interfaces based on function signatures, as well as runtime polymorphism through virtual functions; templates support implicit interfaces based on valid expressions, as well as compile-time polymorphism through template instantiation and function overloading resolution.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-07.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-40 Use multiple inheritance judiciously</title>
        <link>https://nianze.ml/en/notes/2018/03/use-multiple-inheritance-judiciously/</link>
        <pubDate>Tue, 06 Mar 2018 17:35:59 -0500</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 06 Mar 2018 17:35:59 -0500</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/use-multiple-inheritance-judiciously/</guid>
        <description>&lt;p&gt;Being more complex than single inheritance, Multiple inheritance (MI) can lead to ambiguity issues and to the need for virtual inheritance, the latter of which imposes costs in size, speed, and complexity of initialization and assignment, so it&amp;rsquo;s more practical to make &amp;ldquo;empty&amp;rdquo; virtual base classes.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-06.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-39 Use private inheritance judiciously</title>
        <link>https://nianze.ml/en/notes/2018/03/use-private-inheritance-judiciously/</link>
        <pubDate>Mon, 05 Mar 2018 18:42:43 -0500</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Mon, 05 Mar 2018 18:42:43 -0500</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/use-private-inheritance-judiciously/</guid>
        <description>&lt;p&gt;Private inheritance means is-implemented-in-terms-of. It is usually inferior to composition, but it makes sense when a derived class needs access to protected base members or needs to redefine inherited virtual functions. For library developers who strive to minimize object sizes, it also offers the ability of empty base optimization.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-05.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-38 Model &#39;has-a&#39; or &#39;is-implemented-in-terms-of&#39; through composition</title>
        <link>https://nianze.ml/en/notes/2018/03/model-has-a-or-is-implemented-in-terms-of-through-composition/</link>
        <pubDate>Sun, 04 Mar 2018 15:49:31 -0500</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Sun, 04 Mar 2018 15:49:31 -0500</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/model-has-a-or-is-implemented-in-terms-of-through-composition/</guid>
        <description>&lt;p&gt;In the application domain, composition means has-a. In the implementation domain, it means is-implemented-in-terms-of.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-04.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-37 Never redefine a function&#39;s inherited default parameter value</title>
        <link>https://nianze.ml/en/notes/2018/03/never-redefine-a-functions-inherited-default-parameter-value/</link>
        <pubDate>Fri, 02 Mar 2018 21:15:36 -0500</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Fri, 02 Mar 2018 21:15:36 -0500</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/never-redefine-a-functions-inherited-default-parameter-value/</guid>
        <description>&lt;p&gt;Defaul parameter values are statically bound, while virtual function - the only functions we should be overriding - are dynamically bound.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-02.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-36 Never redefine an inherited non-virtaul function</title>
        <link>https://nianze.ml/en/notes/2018/03/never-redefine-an-inherited-non-virtaul-function/</link>
        <pubDate>Thu, 01 Mar 2018 20:22:17 -0500</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Thu, 01 Mar 2018 20:22:17 -0500</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/03/never-redefine-an-inherited-non-virtaul-function/</guid>
        <description>&lt;p&gt;A generalized basic rule from item 7.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-03/2018-03-01.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-35 Consider Alternatives to Virtual Functions</title>
        <link>https://nianze.ml/en/notes/2018/02/consider-alternatives-to-virtual-functions/</link>
        <pubDate>Wed, 28 Feb 2018 20:27:02 -0500</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Wed, 28 Feb 2018 20:27:02 -0500</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/02/consider-alternatives-to-virtual-functions/</guid>
        <description>&lt;p&gt;Alternatives to virtual functions include the NVI idiom (as an example of the Template Method design pattern) and various forms of the Strategy design pattern.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-02/2018-02-28.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-34 Differentiate between inheritance of interface and inheritance of implementation</title>
        <link>https://nianze.ml/en/notes/2018/02/differentiate-inheritance-of-interface-from-inheritance-of-implementation/</link>
        <pubDate>Tue, 27 Feb 2018 20:53:53 -0500</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Tue, 27 Feb 2018 20:53:53 -0500</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/02/differentiate-inheritance-of-interface-from-inheritance-of-implementation/</guid>
        <description>&lt;p&gt;Inheritance of interface is different from inheritance of implementatino.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-02/2018-02-27.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-33 Avoid hiding inherited names</title>
        <link>https://nianze.ml/en/notes/2018/02/avoid-hiding-inherited-names/</link>
        <pubDate>Mon, 26 Feb 2018 20:18:55 -0500</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Mon, 26 Feb 2018 20:18:55 -0500</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/02/avoid-hiding-inherited-names/</guid>
        <description>&lt;p&gt;Names in derived classes hide names in base classes, which is not desirable in public inheritance. To fix it, employ &lt;code&gt;using&lt;/code&gt; declarations or forwarding functions to make hidden names visible again.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-02/2018-02-26.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-32 Make sure public inheritance models &#34;Is-A&#34;</title>
        <link>https://nianze.ml/en/notes/2018/02/make-sure-public-inheritance-models-is-a/</link>
        <pubDate>Fri, 23 Feb 2018 12:59:53 -0500</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Fri, 23 Feb 2018 12:59:53 -0500</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/02/make-sure-public-inheritance-models-is-a/</guid>
        <description>&lt;p&gt;Everything that applies to base classes must also apply to derived classes in public inheritance, for every derived class object &lt;em&gt;is&lt;/em&gt; a base class object.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-02/2018-02-23.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-31 Minimize compilation dependencies between files</title>
        <link>https://nianze.ml/en/notes/2018/02/minimize-compilation-dependencies-between-files/</link>
        <pubDate>Thu, 22 Feb 2018 00:00:00 +0000</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Thu, 22 Feb 2018 00:00:00 +0000</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/02/minimize-compilation-dependencies-between-files/</guid>
        <description>&lt;p&gt;To minimize compilation dependencies, depend on declarations instead of definitions via techniques such as Handle classes and Interface classes.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-02/2018-02-22.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      
      <item>
        <title>Item-30 Understand ins and outs of inlining</title>
        <link>https://nianze.ml/en/notes/2018/02/ins-and-outs-of-inlining/</link>
        <pubDate>Wed, 21 Feb 2018 00:00:00 +0000</pubDate>
        <author>daoxinzhishui@gmail.com (Nzo)</author>
        <atom:modified>Wed, 21 Feb 2018 00:00:00 +0000</atom:modified>
        <guid>https://nianze.ml/en/notes/2018/02/ins-and-outs-of-inlining/</guid>
        <description>&lt;p&gt;Limit most inlining to small, frequently called functions to facilitate debugging and binary upgradability, minimize potential code bloat, and maximize the chances of greater program speed.&lt;/p&gt;</description>
        
        <dc:creator>Nzo</dc:creator>
        
        <media:content url="https://nianze.ml/image/2018/2018-02/2018-02-21.gif" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
          
            
              <category>technique</category>
            
          
            
              <category>cpp</category>
            
          
        
        
          
            
              <category>coding</category>
            
          
        
        
          
            
              <category>effective c&#43;&#43;</category>
            
          
        
      </item>
      

    
  </channel>
</rss>
