[{"content":"\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.Sunset after a storm\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\n  ","description":"","id":0,"section":"gallery","tags":["street photography"],"title":"2021.06.05 Hudson River Sunset","uri":"https://nianze.ml/en/gallery/digital/2021/06/05/2021-06-05-weekly-visual-project/"},{"content":"Weekly visual project - 2021/06/03\nMainly shot with Kodak GC/UltraMax 400\n","description":"","id":1,"section":"gallery","tags":["street photography"],"title":"2021.06.03 Some recent films","uri":"https://nianze.ml/en/gallery/film/2021/06/03/2021-06-03-weekly-visual-project/"},{"content":"Sunny day!\n","description":"","id":2,"section":"gallery","tags":["street photography"],"title":"2021.05.15 Governors Island","uri":"https://nianze.ml/en/gallery/digital/2021/05/15/2021-05-15-weekly-visual-project/"},{"content":"Random shots in spring 2021.\n","description":"","id":3,"section":"gallery","tags":["street photography"],"title":"2021.04.10","uri":"https://nianze.ml/en/gallery/digital/2021/04/11/2021-04-10-visual-project/"},{"content":"Weekly visual project - 2020/10/05\n","description":"","id":5,"section":"gallery","tags":["street photography"],"title":"Some recent pics on Leica SL","uri":"https://nianze.ml/en/gallery/digital/2020/10/05/2020-10-05-digital-visual-project/"},{"content":"Weekly visual project - 2020/10/05\n","description":"","id":6,"section":"gallery","tags":["street photography"],"title":"Some recent film pics","uri":"https://nianze.ml/en/gallery/film/2020/10/05/2020-10-05-film-visual-project/"},{"content":"Weekly visual project - 2020/08/02\n","description":"","id":7,"section":"gallery","tags":["street photography"],"title":"[Weekly-50] 2020.08.02","uri":"https://nianze.ml/en/gallery/film/2020/08/02/2020-08-02-weekly-visual-project/"},{"content":"Weekly visual project - 2020/07/25\n","description":"","id":8,"section":"gallery","tags":["street photography"],"title":"[Weekly-65] 2020.07.25","uri":"https://nianze.ml/en/gallery/digital/2020/07/25/2020-07-25-weekly-visual-project/"},{"content":"Weekly visual project - 2020/07/17\n","description":"","id":9,"section":"gallery","tags":["street photography"],"title":"[Weekly-49] 2020.07.17","uri":"https://nianze.ml/en/gallery/film/2020/07/17/2020-07-17-weekly-visual-project/"},{"content":"Weekly visual project - 2020/05/17\n","description":"","id":10,"section":"gallery","tags":["street photography"],"title":"[Weekly-48] 2020.05.17","uri":"https://nianze.ml/en/gallery/film/2020/05/17/2020-05-17-weekly-visual-project/"},{"content":"A refined version of trade beats: combine multiple stocks in one sequencer, supported by React.js, Tone.js, and P5.js\n  !function(e){function r(r){for(var n,l,a=r[0],f=r[1],i=r[2],p=0,s=[];p  ","description":"","id":11,"section":"posts","tags":["music","technique"],"title":"Trade Sequencer","uri":"https://nianze.ml/en/posts/2020/05/trade-sequencer/"},{"content":"Nicolas Collins (born March 26, 1954 in New York City) has been composing and performing since the early 1970s. He studied composition with Alvin Lucier at Wesleyan University (received both B.A. and M.A. there) and worked for several years with David Tudor.\nBackground Collins is a pioneer in the use of microcomputers in live performance, and has made extensive use of \u0026ldquo;home-made\u0026rdquo; electronic circuitry, radio, found sound material, and transformed musical instruments. His recent work emphasizes spoken word, and combines idiosyncratic electronics with conventional acoustic instruments. He is currently Editor-in-Chief of the Leonardo Music Journal, a peer-reviewed academic journal published by the MIT Press. He is also the chair of the sound department of the School of the Art Institute of Chicago.\nHe has presented over 300 concerts and installations in the United States, Europe, and Japan as a solo artist, as a member of David Tudor\u0026rsquo;s \u0026ldquo;Composers Inside Electronics,\u0026rdquo; with his own ensembles, and in collaboration with The Barton Workshop, Tom Cora, Peter Cusack, The Downtown Ensemble, Shelley Hirsch, Impossible Music, Guy Klucevsek, Ron Kuivila, Christian Marclay, David Moss, Ben Neill, Jim O\u0026rsquo;Rourke, Robert Poss, Relache, Elliott Sharp, the Soldier String Quartet, John Zorn, and others.\nTwo albums of his music have been released by Lovely Records, three by Trace Elements Records, and he has contributed to a dozen compilations, including Banned, John Doe, Slowscan, Tellus, Nonesuch, Hat Art, These Records, RRRecords and Unknown Public. In 1989 he produced Imaginary Landscapes, a CD compilation of new electronic music, for Nonesuch Records. He has been commissioned by the Netherlands Wind Ensemble, Zeitkratzer, Jonathan Impett, Lesley Olsen, Guy Klucevsek, the Soldier String Quartet, Mainspring Brass Quartet, Ger van Elk, NCRV, Korzo Theatre, and The Kitchen.\nCollins is a prominent curator of performance and installation art, and has been a curator, policy adviser, and board member for numerous cultural organizations. He has curated concerts for PS 1, The Clocktower, The Kitchen, Relache and Podewil, and served on the board of directors of Roulette and Harvestworks/PASS. He relocated to the Netherlands in the fall of 1992, where he was co-director of The Barton Workshop and a member of the board of directors of the Rumori and Korzo concert series. From 1992 to 1995 he was co-director of Stichting STEIM(Studio for Electro Instrumental Music) in Amsterdam. He is currently a German Academic Exchange Service(DAAD) artist-in-residence in Berlin, and composer-in-residence with the Kammerensemble Neue Musik Berlin.\nIn 2006 Collins' book Handmade Electronic Music: The Art of Hardware Hacking was published by Routledge. An expanded, updated edition was published in 2009. He was a major influence on the establishment of the Musical Electronics Library in New Zealand.\nLive at Luff The live performance covered excerpts from \u0026ldquo;Imperfekt\u0026rdquo;, \u0026ldquo;The Royal Touch\u0026rdquo;, and \u0026ldquo;In Memoriam Michel Waisvisz\u0026rdquo;.\nImperfekt the performance is achieved by the sounds of a barely functional Soviet radio pass through a maze of computer signal processing.   At a workshop in Brno a few years ago a student brought in a \u0026#34;Neywa\u0026#34; Russian radio to hack. It sounded great to my ears, but he was ambivalent enough about it to trade it to me for a copy of my book. I dug it out a few months ago. Outside of the noisy workshop space the radio proved ridiculously loud and shrill, so I disconnected its tiny speaker and hooked up one I\u0026#39;d salvaged from our old teardrop iMac before it went to recycling. This gave a nice bass boost, and the speaker can be muted and filtered with the hand or resonated with one\u0026#39;s mouth -- a sort of a marching band crackle box (CrackleCornet?). The red wire with the faston terminal is a replacement antenna. The road case is a Nicaraguan cigar box.   The Royal Touch from Nicolas:\u0026#34;a simple circuit of my design reanimates a dead circuit board to create a chaotic multi-voice oscillator... Fishing weights make nudgeable contacts between my circuit in the Simon Lévelt tea box and the dead board.\u0026#34;   photos by Atau Tanaka of a performance of at EAVI X, Amersham Arms, London, January 15, 2015.   In Memoriam Michel Waisvisz this piece employs a candle’s flicker to control the tuning of four oscillators.   Reference: https://en.wikipedia.org/wiki/Nicolas_Collins\nhttp://www.kalvos.org/collins.html\nhttp://media.hyperreal.org/zines/est/intervs/collins.html\nhttp://www.nicolascollins.com/\n","description":"","id":12,"section":"notes","tags":["music","computer music"],"title":"Computer Music Study 4: Electronic Music for Performance ft. Nicolas Collins","uri":"https://nianze.ml/en/notes/2020/04/electronic-music-for-performance-featuring-nicolas-collins/"},{"content":"Weekly visual project - 2020/03/22\n","description":"","id":13,"section":"gallery","tags":["street photography"],"title":"[Weekly-47] 2020.03.22","uri":"https://nianze.ml/en/gallery/film/2020/03/22/2020-03-22-weekly-visual-project/"},{"content":"Weekly visual project - 2020/03/15\nThe excerpt  I’m perfectly happy with all the people who are walking around and just staring at the clouds and looking at the stars and saying, ‘I want to go there.’ But I’m looking at the ground, and I want to fix the pothole that’s right in front of me before I fall in. by Linux Torvalds\n","description":"","id":14,"section":"gallery","tags":["street photography"],"title":"[Weekly-46] 2020.03.15","uri":"https://nianze.ml/en/gallery/digital/2020/03/15/2020-03-15-weekly-visual-project/"},{"content":"Weekly visual project - 2020/03/08\nThe excerpt  Good taste is about really seeing the big patterns and kind of instinctively knowing what\u0026rsquo;s the right way to do things. Excerpt From: Linus Torvalds\n","description":"","id":15,"section":"gallery","tags":["street photography"],"title":"[Weekly-45] 2020.03.08","uri":"https://nianze.ml/en/gallery/digital/2020/03/08/2020-03-08-weekly-visual-project/"},{"content":"Recently I just learned that Charles Dodge is the pioneer in sonification and his music piece Earth\u0026rsquo;s Magnetc Field is inspiring.\nEarth’s Magnetic Field In 1970, Columbia-Princeton Electronic Music Center, together with three physicists Bruce R. Boller, Carl Frederick and Stephen G. Ungar, Dodge sonified the variations in the earth’s magnetic field and composed Earth’s Magnetic Field, which is a seminal piece of sonification art and realized in Computed Electronic Sound.\nMapping from scientific data to musical sounds Solar winds make the earth’s magnetic field fluctuate and these fluctuations are registered in the Kp-index, which is a global geomagnetic storm index introduced by Bartels in 1939, and has a scale from 0 to 9, where 0 means that there is very little geomagnetic activity and 9 means extreme geomagnetic storming. The global Kp-index is derived by calculating a weighted average of K-indices from a network of geomagnetic observatories, each of which has their own local K-index. Based on the 2920 Kp-indeces in 1961, Dodge made the music piece Earth\u0026rsquo;s Magnetc Field\nFirstly, the values were tabulated in a so-called Bartel Musical Diagram. One of the physicists had made a five-line staff representation of the data and mapped the values to both a 7-note diatonic scale as well as a 12-note chromatic scale, with a four octave span, or 45 notes (the average span of an instrument).\nBartels diagram displaying fluctuations in the Earth\u0026#39;s magnetic field for the year 1961   As the pitches were mapped through the Bartel diagram, Dodge focused on working on the rhythm and timbre. The 2920 values were compressed in an 8-minute composition and within those 8 minutes, Dodge used algorithms to organise other aspects of the music: between different points within the data, interpolations were made to create tempo, dynamics, and register:\n In the first half of the piece, there would be accelerando-ritardando patterns; in the second half, a fixed tempo within which two patterns, A and B, would alternate, the A pattern having one note to a beat, and the B pattern 2 to 14 notes to a beat. The B-pattern was derived from the sudden commencements, rises in the values due to solar winds and flares which had a bigger impact on the earth’s magnetic field.\n Electronic music involvement Besides its importance in sonification, Earth’s Magnetic Field is an important piece in the electro-acoustic music scene as it is the first piece that explicitly uses comb filters to control the timbre. Dodge used the comb filter in the first part while in the second part he used all-pass filtering. The use of filters is a pure aesthetical choice while pitch and rhythm are dependent on the data.\nReference:\nwikipedia\nsonificationart\nNASA interview\nThieberger, E., \u0026amp; Dodge, C. (1995). An Interview with Charles Dodge. Computer Music Journal, 19(1), 11-24. doi:10.2307/3681298\n","description":"","id":16,"section":"notes","tags":["music","computer music"],"title":"Computer Music Study 3: Music Based on Algo","uri":"https://nianze.ml/en/notes/2020/03/algorithmic-computer-music/"},{"content":"Weekly visual project - 2020/03/01\n","description":"","id":17,"section":"gallery","tags":["street photography"],"title":"[Weekly-44] 2020.03.01","uri":"https://nianze.ml/en/gallery/digital/2020/03/01/2020-03-01-weekly-visual-project/"},{"content":"Paul Lansky (born 1944) is an American composer, pioneering sound synthesis with computers since the mid-1960s. After 2004, he concentrated on instrumental composition without any electronic involvement.\nSounds originating from \u0026ldquo;real-world\u0026rdquo; sources are the predominant focus of Lansky\u0026rsquo;s computer music: traffic, kids in the kitchen, musical instruments, and most of all speech. Electronic synthesis is frequently used but the main sonic resources are transformations of recorded natural sounds.\nSix Fantasies on a Poem by Thomas Campion One of his first large pieces, Six Fantasies on a Poem by Thomas Campion (1979) set the stage. It is based on a reading by his wife Hannah MacKay of Thomas Campion’s famous poem Rose cheekt Lawra, which was published in 1602 as part of a treatise entitled Observations in the Art of English Poesie:\n Rose-cheekt Lawra, come,\nSing thou smoothly with thy beawties\nSilent musick, either other\nSweetely gracing.\nLovely formes do flowe\nFrom concent devinely framed;\nHeav\u0026rsquo;n is musick, and thy beawties\nBirth is heavenly.\nThese dull notes we sing\nDiscords neede for helps to grace them;\nOnly beawty purely loving\nKnowes no discord;\nBut still mooves delight,\nLike cleare springs renu\u0026rsquo;d by flowing,\nEver perfect, ever in them-\nselves eternall.\n The piece is a study of the contours of a live reading of the poem. In the Six Fantasies, the employment of electronic sound manipulation is not so much as a tool for creating yet-unheard sound, but rather introspectively, as a means of exploring the sonic environment of everyday human experience. A technique known as linear predictive coding (LPC) is used in the work. LPC was developed in the 1960s by scientists as a data-reduction technique meant to economize on the amount of data needed for digital voice transmission and is used today in some cell phone communication. It allows for the separation of pitch and speed and the pitch contours of the speech can be altered independently of the speed. Each of the six movements explores a different aspect of speech and is achieved by computer synthesized tape. The six pieces are, respectively:\n her voice her presence her reflection her song her ritual her self  According to Paul Lansky\u0026rsquo;s Homepage on Princeton.edu:\n Speech and song are commonly considered different and distinct \u0026ndash; as apples and oranges. It is my feeling, however, that they are more usefully thought of as occupying opposite ends of a spectrum, encompassing a wealth of musical potential. This fact has certainly not been lost on musicians: sprechstimme, melodrama, recitative, rap, blues, etc., are all evidence that it is a lively domain.\n Six Fantasies is my exploratory journey through this terrain. Each of the fantasies attempts to musically transform a single reading by Hannah MacKay of a well-known poem by Thomas Campion, and to musically highlight some aspect of her speech: contour, vowels, resonance, articulation, consonants, etc., explicating the implicit music within. The final fantasy largely reproduces the original reading, and it is my hope that by the time this rolls by that her speech will sound like music.\nReference:  Ondishko, D. (1990). Six Fantasies on a Poem by Thomas Campion: Synthesis and evolution of Paul Lansky’s music compositions. Paul Lansky\u0026rsquo;s Homepage on Princeton.edu ","description":"","id":18,"section":"notes","tags":["music","computer music"],"title":"Computer Music Study 2: Music based on synthetic electronic sound","uri":"https://nianze.ml/en/notes/2020/02/synthetic-computer-music/"},{"content":"Weekly visual project - 2020/02/22\nFilm: Kodak Colorplus 200\n","description":"","id":19,"section":"gallery","tags":["street photography"],"title":"[Weekly-43] 2020.02.22","uri":"https://nianze.ml/en/gallery/film/2020/02/22/2020-02-22-weekly-visual-project/"},{"content":"Weekly visual project - 2020/02/16\nShot by Leica M9 and iPhone X.\n","description":"","id":20,"section":"gallery","tags":["street photography"],"title":"[Weekly-42] 2020.02.16","uri":"https://nianze.ml/en/gallery/digital/2020/02/16/2020-02-16-weekly-visual-project/"},{"content":"Weekly visual project - 2020/02/08\nFilm: Ilford HP5 Plus 400\nThe excerpt  It is impossible to enjoy idling thoroughly unless one has plenty of work to do. There is no fun in doing nothing when you have nothing to do. Wasting time is merely an occupation then, and a most exhausting one. Idleness, like kisses, to be sweet must be stolen.\n一个人如果没有许许多多工作需要完成，就无法彻底享受懒散度日的乐趣。而一个人无事可做的时候，无所事事也失去了它原有的乐趣。于是浪费时间仅仅变成了一项任务，还是最劳心费神的任务。懒散度日的感觉就像吻一样，只有偷来的才甜美。\n Excerpt From: Jerome K. Jerome. “Idle thoughts on an idle fellow”\n","description":"","id":21,"section":"gallery","tags":["street photography"],"title":"[Weekly-41] 2020.02.08","uri":"https://nianze.ml/en/gallery/film/2020/02/08/2020-02-08-weekly-visual-project/"},{"content":"Karlheinz Stockhausen (22 August 1928 – 5 December 2007) was a German composer, best known for his innovation in electronic music, for introducing controlled chance into serial composition, and for musical spatialization.\nKarlheinz Stockhausen developed the temporal theories and suggested that the entire compositional structure could be conceived as \u0026ldquo;timbre\u0026rdquo;:\n since \u0026ldquo;the different experienced components such as colour, harmony and melody, meter and rhythm, dynamics, and form correspond to the different segmental ranges of this unified time\u0026rdquo;, the total musical result at any given compositional level is simply the \u0026ldquo;spectrum\u0026rdquo; of a more basic duration—i.e., its \u0026ldquo;timbre\u0026rdquo;, perceived as the overall effect of the overtone structure of that duration, now taken to include not only the \u0026ldquo;rhythmic\u0026rdquo; subdivisions of the duration but also their relative \u0026ldquo;dynamic\u0026rdquo; strength, \u0026ldquo;envelope\u0026rdquo;, etc.\n Despite the strangeness and supposedly unlistenability of his music, Stockhausen, as an avant-garde composer, has influence on popular consciousness. The Beatles included his face on the cover of Sgt. Pepper\u0026rsquo;s Lonely Hearts Club Band. This reflects his influence on the band\u0026rsquo;s own avant-garde experiments as well as the general fame and notoriety he had achieved by that time (1967). In particular, \u0026ldquo;A Day in the Life\u0026rdquo; (1967) and \u0026ldquo;Revolution 9\u0026rdquo; (1968) were influenced by Stockhausen\u0026rsquo;s electronic music.\nGesang der Junglinge (\u0026ldquo;Song of the Youths\u0026rdquo;) Karlheinz Stockhausen returned from Paris to Cologne to work in the new electronic sound studio. Beyond his initial studies, his first composition, in 1956, was Gesang der Junglinge, where he used tape recorders to carefully and seamlessly integrate electronic sounds with the human voice by matching voice resonances with pitch and creating sounds of phonemes electronically. The music is originally in five-channel sound to develop the concept of spatialization and successfully brought together the two opposing worlds of the purely electronically generated German elektronische Musik and the French musique concrète.\nThe concept of this music is “harmonizing sung tones with electronically generated tones.” More specifically, as noted by Karlheinz Stockhausen, “at certain points in the composition, the sung tones are understood as words; at other points, they have only the value of sounds. Between these extremes are reached different levels of word-related clarity.”\nThere are three basic types of electronic sounds in the music:\n electronically generated sine tones, electronically generated pulses (clicks), filtered white noise  The recorded voice of a boy soprano (by 12-year-old Josef Protschka) accompanies with all\nthree types above:\n vowels are harmonic spectra, which may be conceived as based on sine tones; fricatives and sibilants are like filtered noises; plosives resemble impulses  The text of Gesang der Jünglinge is from a Biblical story in The Book of Daniel where Nebuchadnezzar throws Shadrach, Meshach, and Abednego into a fiery furnace but miraculously they are unharmed and begin to sing praises to God. The idea of composition is to make a mass for electronic sounds and voices.\nHymnen (\u0026ldquo;national anthems\u0026rdquo;) Karlheinz Stockhausen also developed concepts of spatialization in Hymnen (1966–67), which is a 4-channel electronic and concrete work, with optional live performers. The substance of the work consists of recordings of national anthems from around the world. There are four movements, or \u0026ldquo;regions\u0026rdquo;, with a combined duration of two hours. The composition exists in three versions:\n electronic and concrete music alone (region 1+2, region 3+4) electronic and concrete music with soloists the Third Region (only) with orchestra (composed in 1969). This version of the Third Region can be performed by itself, or together with either the first or second version of the other three regions  Each region uses certain anthems as centres:\n Region I (dedicated to Pierre Boulez) has two: \u0026ldquo;The Internationale\u0026rdquo; and \u0026ldquo;La Marseillaise\u0026rdquo; Region II (dedicated to Henri Pousseur) has four:  the German anthem, a group of African anthems, the opening of the Russian anthem, and a \u0026ldquo;subjective centre\u0026rdquo;, consisting of the recording of a moment during the studio work, \u0026ldquo;in which the present, the past and the pluperfect become simultaneous\u0026rdquo; (Stockhausen 1971, 96).   Region III (dedicated to John Cage) has three:  the continuation of the Russian anthem (the only one made entirely from electronic sounds), the American anthem, and the Spanish anthem.   Region IV (dedicated to Luciano Berio) has just one, but it is a \u0026ldquo;double centre\u0026rdquo;: the Swiss anthem, whose final chord turns into an imaginary anthem of the utopian realm of \u0026ldquo;Hymunion in Harmondie under Pluramon\u0026rdquo; (Stockhausen 1971, 97).  References  intelligentarts theguardian medien art net wikipedia Aldgate, Anthony, James Chapman, and Arthur Marwick. 2000. Windows on the Sixties: Exploring Key\nTexts of Media and Culture. London and New York: I. B. Taurus \u0026amp; Co. Ltd. ISBN 1-86064-383-3. Guy, Alun, and Iwan Llewelyn-Jones. 2004. Students Guide to Gcse Music for the Wjec Specification:\nEnglish Language. London: Rhinegold Publishing. ISBN 1-904226-59-0 ","description":"","id":22,"section":"notes","tags":["music","computer music"],"title":"Computer Music Study 1: Music based on recordings","uri":"https://nianze.ml/en/notes/2020/02/synthetic-computer-music/"},{"content":"A quick review of key concepts in digital signal processing such as aliasing, DFT, convolution, FIR/IIR filters, etc.\nAliasing Waves at frequencies $f$ and $(f + k \\cdot f_s)$ look identical when sampled at rate $f_s$.\nIf a signal $x$ has frequency content only within the $range \\pm B$ Hz, then the sampling rate must be at least $f_s = 2B$ to avoid aliasing.\n$f_s/2$ is called the Nyquist frequency (for sampling rate $f_s$)\nFourier transform DFT (Discrete Fourier transform)  Intuition: cross-correlate the signal against cosine and sine waves of different frequencies.\n $$ X[m] = \\sum_{n=0}^{N-1} x[n] \\cdot (cos(2 \\pi \\cdot m \\cdot n / N) - j \\cdot sin(2 \\pi \\cdot m \\cdot n / N)), m \\in [0, N-1] $$\nWith Euler\u0026rsquo;s formula:\n$$ X[m] = \\sum_{n=0}^{N-1} x[n] \\cdot e^{-j2 \\pi \\cdot m \\cdot n / N} $$\n  $m^{th}$ analysis frequency has exactly $m$ cycles over the duration of the signal $N$, and $f_m = m \\cdot f_s / N$ HZ. The gap between $f_m$ and $f_{m+1}$ is called the bin spacing\n DFT symmetry For real valued $x[n]$,\n$$e^{-j \\cdot 2 \\pi \\cdot (N-m) \\cdot / N} = e^{+j \\cdot 2 \\pi \\cdot m \\cdot m / N}$$\nIn other words, $X[m] = X^{*}[N-m]$, or frequencies $N/2+1, \u0026hellip;, N-1$ are conjugates of $N/2-1, \u0026hellip;, 1$ (identical real parts, reverded-signed imaginary parts)\nDFT properties Shifting If $x_2[n] = x_1[n-D]$, then $X_2[m] = X_1[m] \\cdot e^{-j2 \\pi \\cdot m \\cdot D/N}$\n Derivation:   $|X_1[m]| = |X_2[m]|$ for $x(t) = cos(2 \\pi \\cdot f_0 \\cdot t - \\varphi)$, phase offset in the DFT is $e^{-j \\varphi}$ if $D \u0026lt; N$, then $D/N$ is the proportion of entire signal being delayed, and $X_2[m]$ rotates $m$ times by angle $-2 \\pi \\cdot D/N$  Linearity $$ \\sum_{n} (c_1 \\cdot x_1[n] + c_2 \\cdot x_2[n]) \\cdot e^{-j2 \\pi \\cdot m \\cdot n / N} = c_1 \\cdot X_1[m] + c_2 \\cdot X_2[m] $$\nIn other words, scale and sum in time domain is equivalent to scale and sum in frequency domain\nCombining linearity and shifting $$ x[n]= \\sum_k A_k e^{-2 \\pi \\cdot k \\cdot n/N - \\varphi_k} \\Rightarrow X[m] = A_m e^{-j \\varphi_m} $$\n when $k = m$, $e^{j2 \\pi \\cdot (k-m) \\cdot n/N} = e^0 = 1$, thus\n$$X[m] = A_m e^{-j \\varphi_k}$$ when $k$ ≠ $m$, the summation over all $n$ cancels out, thus\n$$X[m] = 0$$  IDFT (Inverse DFT) $$ x[n] = 1/N \\cdot \\sum_m X[m] \\cdot e^{+j2 \\pi \\cdot m \\cdot n/N} $$\nFor each term $X[m] \\cdot e^{+j2 \\pi \\cdot m \\cdot n/N} = A \\cdot e^{j(j \\pi \\cdot m \\cdot n/N + \\theta)}$, which is a complex sinusoid with amplitude $A$, phase $\\theta$, and frequency $mf_s/N$ [Hz] (or $m$ [cycles per signal duration]). In other words, every signal can be expressed as a weighted sum of sinusoids\nSpectral leakage   If a digital signal $x[n]$ has energy at frequencies which are not integer multiples of $f_s/N$, then this energy will leak (spread) across multiple DFT frequency bands $X[m]$\n   This is caused because such frequencies don\u0026rsquo;t have the whole number of cycles during sampling duration, so comparing to an analisis frequency won\u0026rsquo;t cancel out.\n In this situation, $X[m]$ measures not just energy associated with the $m^{th}$ analysis frequency, but has contributions from every other non-analysis frequency.\nLeakage compensation Strategy #1: Have large N Long signals, high sampling rate $\\Rightarrow$ more analysis frequencies, smaller gaps between them\nStrategy #2: Windowing  Intuition: force continuity at the edges, eliminate fractional cycles\n Before taking the DFT, Multiply $x[n]$ by a window, which tapers the ends of the signal to (near) 0:\n$$ x[n] \\rightarrow w[n] \\cdot x[n] $$\nResult: leakage concentrates on nearby frequencies, and is reduced for distant frequencies; at the same time, analysis frequencies leak to their neighbors as well:\n Since in naturally occurring signals, pure tones at exactly $mf_s/N$ hardly happen, we are unlikely to tell apart analysis and non-analysis frequencies. The overall benefits of windowing outweigh the drawbacks\n Key properties when designing/choosing a window:\n Width of the main lobe(in Hz or bins): how far does energy smear out locally Hight of the side lobe(in dB): how loud is the leakage from distant frequencies    STFT(short-time Fourier transform) Process  Carve the signal into small frames, with frame length $K$ and hop length $h$:  x[0], x[1], \u0026hellip;, x[K-1] x[h], x[h+1], \u0026hellip;, x[h+K-1] x[2h], x[2h+1], \u0026hellip;, x[2h+K-1] \u0026hellip;   Window each frame to reduces leakage and artifacts from frame slicing Compute the DFT of each windowed frame  Parameters \u0026amp; design  Longer window (larger frame length $K$) means:  lower frequencies ($f_{min} = f_s / K$) higher frequency resolution ($f_{max}$ is determined by Nyquist, number of analysis frequencies depends on frame length) more data, more memory and compute   $K$ with value of power of 2 (512, 1024, \u0026hellip;) is ideal for FFT, pick $K$ to give the desired frequency resolution Smaller hop (smaller hop length $h$) means:  higher temporal resolution more data, more memory and compute   $h \u0026lt; K$, usually set hop = $K/2$ or $K/4$  Spectrogram A spectrogram is the STFT as an image, with each column as DFT of one frame into magnitude, which is usually log-scaled to decibels (dB). $log_2$ preserves visual size of octaves.\n$$ X[m] \\rightarrow 20 \\cdot log_{10}|X[m]| [dB] $$\n FFT (Fast Fourier Transform)  Idea: identify redundant calculations shared betwen different analysis frequencies, reducing time complexity from $O(N^2)$ to $O(N \\cdot log(N))$\n  FFT computes the DFT Requires signal length to be the power of 2 (1024, 2048, etc); otherwise pad up signal to the next power of 2 length FFT could be further optimized when the input is real-valued (the rfft() function in most FFT libraries) by taking use of conjugate symmetry  Convolution Definition $$ y[n] = \\sum_{k=0}^{K-1}h[k] \\cdot x[n-k] = x * h $$\n $h$ is filter coefficients ordered from most recent ($h[0]$) to least recent ($h[K-1]$), while $x$ is ordered by increasing time $ \\Rightarrow $ reversing $x$ to line up with $h$\n Modes  Valid: no zero-padding, $[N]*[K] \\rightarrow [N-K+1]$ Same: zero-padding before the signal, $[N]*[K] \\rightarrow [max(N, K)]$ Full: pad by zeros on both ends, $[N]*[K] \\rightarrow [N+K-1]$ Circular: like Same mode except $x$ is looped instead of zero-padded  Simple filters  Gain: $h=[G]$  $x[n] \\rightarrow G \\cdot x[n]$   Delay: $h=[0, 0,\u0026hellip;, 1]$  $x[n] \\rightarrow x[n+d]$   Averaging: $h=[1/K, 1/K,\u0026hellip;, 1/K]$  fast changes get smoothed out, making a crude low-pass filter   Differencing: $h=[1, -1]$  crude hight-pass filter    Property  Linearity: $(c_1x_1+c_2x_2)h = c_1x1h+c_2x_2*h$ Commutativity: $xh = hx$ (we can treat the signal as the filter) Associativity: $(xh)g = x(hg)$  Similar to wave propagation, where after reflection the signal gets delayed and attenuated, and microphone sums up the waves from both direct path as well as reflection path, each $x[n-k]$ could be regarded as being\n delayed by $k$ time steps scaled by $h[k]$ added together  Since convolution is linear and time invariant, every LSI system can be expressed as a convolution, and the \u0026ldquo;filter\u0026rdquo; $h$ is the impulse response of the system, which completely determines the behavior of the system.\nIf $h$ is finite in length, it\u0026rsquo;s called a Finite Impulse Response(FIR)\nConvolution theorem Convolution (int circular mode1) in the time domain $x*h$ $\\Leftrightarrow$ multiplication in the frequency domain $X \\cdot H$, or\n$$ DFT(x*h) = DFT(x) \\cdot DFT(h) $$\nFast convolution  Convolution in time domain has a time complexity of $O(N \\cdot K)$ In the frequency domain, it takes $N$ multiplies, so  zero-pad $h$ from $K$ to $N$ samples compute two forward DFTs $O(2 \\cdot N \\cdot log_2N)$ compute one inverse DFT $O(N \\cdot log_2N)$ totally $O(N \\cdot log_2N)$    Filters Frequency domain is complex-valued, with multiplication rule:\n$$ (r \\cdot e^{j \\theta}) (s \\cdot e^{j \\varphi }) = (r \\cdot s) \\cdot e^{j(\\theta + \\varphi)} $$\nFIR filters Finite Impulse Response means the system\u0026rsquo;s response to an impulse goes to 0 at finite time step, or $y[n]$ depends on finitely many inputs $x[n-k]$.\n Positives:  Usually more simple to implement can analyze by DFT stable and well-behaved   Negatives:  may not be efficient somewhat limited expressivity (non-adaptive)    Delayed impulse analysis A k-step delay filter $h_k = [0, 0, 0, \u0026hellip;, 1]$ has DFT $H_k[m]=e^{-j2 \\pi \\cdot m \\cdot k/N}$, which is a sinusoid of frequency $k$.\n Phase response of a delay filter (wrapped \u0026amp; unrapped):\n Averaging filter (rectangle/box) analysis K-tap averaging filter $h_a = [1/K, 1/K, \u0026hellip;, 1/K, 0, 0, \u0026hellip;]$, which could be regarded as an average of K delayed filters. Thus,\n$$ H_a[m] = DFT(h_a) = 1/K \\sum_k DFT(h_k)[m] = 1/K \\sum_k e^{-j2 \\pi \\cdot m \\cdot k/N} $$\nThe real part $Re{H_a}$ is a $sinc$ function. If we apply $h_a$ to input signal $x$, according to convolution theorem, we multiply them in frequency domain, and magnitudes of output is: $|X[m] \\cdot H[m]| = |X[m]| \\cdot |H_a[m]|$. Since $|H_a[m]|$ decays slowly but bounces up and down in high frequency, there will be high frequency components remaining if we use averaging filter as a low pass filter.\n Phase response of a rectangle filter is sawtoothy even after unwrapping, but it\u0026rsquo;s ok since it\u0026rsquo;s linear within the pass-bands:\n Typical FIR window analysis Most window functions for DFT could be used as low-pass filters. Below is the frequency response for Hann, Blackman-Harris, and Rectangle window.\n Since the windows above are linear within the pass-bands, audible frequencies will have constant delay without noticeable phasing artifacts:\n IIR filters Infinite Impulse Response filters can depend on infinitely many previous inputs by feedback:\n$$ y[n] = \\sum_{k=0}^K b[k] \\cdot x[n-k] - \\sum_{k=1}^K a[k] \\cdot y[n-k] $$\nHere $K$ is the order of the filter. If we define $a[0] = 1$, then we get:\n$$ \\sum_{k \\geq 0} a[k] \\cdot y[n-k] = \\sum_{k \\geq 0} b[k] \\cdot x[n-k] $$\nDue to the feedback, to achieve comparable results, IIR filters need fewer coefficients and multiply-adds with lower latency than FIR filters, so it can be much more efficient.\nTo analyze frequency response of filters, we usually use following parameters to measure their performance:\n passband, passband ripple transition region stopband, stopband attenuation   Butterworth filters  flat response in passband and stopband very wide transition band higher order = faster transition   1 2  b, a = scipy.signal.butter(N, f_c / f_nyquist) y = scipy.signal.lfilter(b, a, x)   Chebyshev filters  narrow transition band type 1 has passband ripples and flat stopband(pictured); type 2 has stopband ripples and flat passband non-linear phase response   1 2  b, a = scipy.signal.cheby1(N, max_ripple, f_c / f_nyquist) b, a = scipy.signal.cheby2(N, max_ripple, f_c / f_nyquist)   Elliptic filters  narrowest transition band ripples in both passband and stopband most non-linear phase response   1  b, a = scipy.signal.ellip(N, max_ripple, min_stop_atten, f_c / f_nyquist)   Z-Transform $$ X(z) = \\sum_{n=0}^{\\infty} x[n] \\cdot z^{-n} $$\n DFT converts $N$ samples ($x[n]$) into N complex coefficients ($X[m]$) z-Transform generalizes the DFT. Specifically, ZT converts $N$ samples ($x[n]$) into a function $X[z]$ on the complex (z-) plane, with $x[n]$ as coefficients of a polynomial in $z^{-1}$. When $z = (e^{j2 \\pi \\cdot m/N})$, $X(z)$ becomes DFT $X[m]$  Properties ZT allows us to analyze IIR filters without dependency on signal length N. It has following properties:\n Linearity:  $ZT(c_1 \\cdot x_1 + c_2 \\cdot x_2) = c_1 \\cdot ZT(x_1) + c_2 \\cdot ZT(x_2)$   Convolution theorem:  $ZT(x * h) = ZT(x) \\cdot ZT(h)$   Shifting theorem:  Delaying by $k$ samples $\\Leftrightarrow$ $X(z) \\rightarrow z^{-k} \\cdot X(z)$    Transform function For a general IIR filter $ y[n] = \\sum_{k=0}^K b[k] \\cdot x[n-k] - \\sum_{k=1}^K a[k] \\cdot y[n-k] $, we have $Y(z) = H(z) \\cdot X(z)$, where $H(z)$ is the **transform function**:\n$$ H(z) = \\dfrac{\\sum_{k=0} b[k] \\cdot z^{-k}}{1 + \\sum_{k=1} a[k] \\cdot z^{-k}} $$\nFrequency response $e^{j2 \\pi \\cdot m/N}$ is a point on the unit circle in the complex plane, according to IDFT, such a point correpsonds to a sinusoid with frequency $f_s \\cdot m/N$, or $ e^{j2 \\pi \\cdot t} \\Rightarrow f_s \\cdot t, t \\in [0, 1/2]$. Thus, we can relate the angle of points in unit circle with frequencies:\n$$ e^{j \\theta} \\Rightarrow f_s \\cdot \\theta / 2 \\pi $$\nBy evaluating the transfer function at $z=e^{2 \\pi \\cdot t}$ for $t \\in [0, 1/2]$, we can see how the frequency magnitude response $|H(e^{j2 \\pi \\cdot t})|$ changes with frequency $f_s \\cdot t$.\n Zeros and poles Places where $H(z) = 0$ are infinitely attenuated and are called zeros of the system. Since $H(z)$ is a polynomial, which is continuous, frequencies near the zeros will also be attenuated. To find zeros, set $\\sum b[k] \\cdot z^{-k} = 0$ and solve for $z$.\nPlaces where $H(z)$ divides by 0 are called the poles of the system, which correspond to resonance and gain. To find poles, solve for $z$ by denominator $1 + \\sum_{k=1} a[k] \\cdot z^{-k} = 0$\nGiven positions of poles and zeros (and total gain), the system is fully determined:\n1  [b, a] = scipy.signal.zpk2tf(zeros, poles, gain)   And vice versa:\n1  [zeros, poles, gain] = scipy.signal.tf2zpk(b, a)     If a system has a pole and a zero at the same $z$, they cancel out If b and a are real, then poles/zeros always come in conjugate pairs A system is stable if all poles are strictly inside the unit circle A system is unstable if any poles are strictly outside the unit circle Zeros do not affect stability Proximity of poles and zeros to the unit circle corresponds to filter sharpness Angle $\\theta$ of poles and zeros corrspond to frequency ($f_s \\cdot \\theta / 2 \\pi $)   We need the DFT shifting property, which assumes looping. If we don\u0026rsquo;t want circular convolution, just pad the signal with K-1 more zeros\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":23,"section":"notes","tags":["dsp"],"title":"DSP Review","uri":"https://nianze.ml/en/notes/2020/01/2020-01-30-dsp-review/"},{"content":"Weekly visual project - 2020/01/25\n The excerpt  有人说，坏制度使好人变坏，好制度让坏人变好。但是问题在于，制度的改变绝非一朝一夕就能完成。悲观主义者的潜台词是，因为无法一劳永逸地改变制度，所以任何行动都是没有意义的。而乐观主义者的想法则是，正因为我们不相信一劳永逸的改变，所以才会相信点滴累进的力量，所以才会为不知何时到来的改变做准备。 Excerpt From: 周濂. “正义的可能”\n","description":"","id":24,"section":"gallery","tags":["street photography"],"title":"[Weekly-39] 2020.01.25","uri":"https://nianze.ml/en/gallery/digital/2020/01/25/2020-01-25-weekly-visual-project/"},{"content":"Weekly visual project - 2020/01/18\nFilm: Ilford HP5 Plus 400 \u0026amp; Ilford Delta 100\nThe excerpt  暴力的语言、粗糙的语言必然会导致暴力的思维、粗糙的思维。 Excerpt From: 周濂. “正义的可能”\n","description":"","id":25,"section":"gallery","tags":["street photography","leica","film","ilford"],"title":"[Weekly-38] 2020.01.18","uri":"https://nianze.ml/en/gallery/film/2020/01/18/2020-01-18-weekly-visual-project/"},{"content":"Weekly visual project - 2020/01/12\nThe excerpt  在现代社会里，思想自由面临着三种威胁：一种是来自蓄意制造的通俗文化麻醉剂，一种来自胆小、自私的庸俗的意识形态，第三种来自官僚独裁者的僵化的教条主义及它的得意武器——思想检查制度。\nExcerpt From: 萨哈罗夫. \u0026ldquo;关于进步、和平共处和思想自由的见解\u0026rdquo;\n","description":"","id":26,"section":"gallery","tags":["street photography","leica","film","ilford"],"title":"[Weekly-37] 2020.01.12","uri":"https://nianze.ml/en/gallery/film/2020/01/12/2020-01-12-weekly-visual-project/"},{"content":"Weekly visual project - 2020/01/05\nThe excerpt  除了奥威尔与赫胥黎，未来存在着第三种可能性：人们一边被禁止阅读书籍，一边自发地不再阅读书籍；一边被剥夺获取信息的权利，一边又深陷垃圾信息的汪洋大海中；一边真相被隐瞒，一边真相被淹没；一边是被砍伐殆尽的文化荒漠，一边又疯狂生长着毫无价值的杂草和荆棘……\nExcerpt From: 周濂. “正义的可能”\n","description":"","id":27,"section":"gallery","tags":["street photography"],"title":"[Weekly-36] 2020.01.05","uri":"https://nianze.ml/en/gallery/digital/2020/01/05/2020-01-05-weekly-visual-project/"},{"content":"Weekly visual project - 2019/12/21\nThe excerpt  When we intend to solve a problem consciously, we process information in a linear, logical fashion. But when ideas call to each other on their own, without our leading them down a straight and narrow path, unexpected combinations may come into being.\nExcerpt From: Mihaly Csikszentmihalyi. \u0026ldquo;Creativity.\u0026rdquo;\n","description":"","id":28,"section":"gallery","tags":["street photography","leica","film","ilford"],"title":"[Weekly-34] 2019.12.21","uri":"https://nianze.ml/en/gallery/film/2019/12/21/2019-12-21-weekly-visual-project/"},{"content":"Weekly visual project - 2019/12/15\nThe excerpt  I thrive on stress and begin to pine if there is no deadline. Otherwise—if I may be presumptuous: I was born like the sentry in Goethe’s Faust II:\nZum Sehen geboren\nZum Schauen bestellt\n(“Born to see, my task is to watch”)\nby Peter Drucker\n","description":"","id":29,"section":"gallery","tags":["street photography"],"title":"[Weekly-33] 2019.12.15","uri":"https://nianze.ml/en/gallery/digital/2019/12/15/2019-12-15-weekly-visual-project/"},{"content":"Weekly visual project - 2019/12/07\nThe gear 估计是老了吧，最近越来越怀旧。黑五期间，没买什么激动人心的新玩意，倒是入了一台编号1191607，于1967年7月19日那批出产1的Leica M4旁轴胶片相机。Ebay卖家表示，这台M4的上任机主是一名职业记者。同相机一并寄来的还有上个世纪的一本徕卡杂志，真是怀旧到底。从没拍过胶片的我，从此步入一个新的大坑。摸着这台年纪堪比我父母辈的相机，我倒是开始理解为什么抚摸党喜欢买来一台又一台徕卡，不出门拍照就只是将这些工具供在防潮箱里——精准的德国工艺在这台相机上体现的淋漓尽致，称得上是能拍照的工艺品：纯机械结构不带电的这台相机可以永远拍下去——只要还有胶片可买。\nThe excerpt  When I have a job to do like that, where you have to do something that takes a lot of effort, slowly, I pretend I’m in jail. Don’t laugh. And if I’m in jail, time is of no consequence. In other words, if it takes a week to cut this, it’ll take a week. What else have I got to do? I’m going to be here for twenty years. See? This is a kind of mental trick.\n\u0026ndash; Jacob Rabinow\n  出产日期参考自历久弥新的黑漆徕卡m4-徕卡m4的使用感受\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":30,"section":"gallery","tags":["street photography","leica"],"title":"[Weekly-32] 2019.12.07","uri":"https://nianze.ml/en/gallery/digital/2019/12/07/2019-12-07-weekly-visual-project/"},{"content":"Weekly visual project - 2019/12/01\nThe excerpt  “What leads to an important discovery doesn’t matter as long as you play by the rules.”\nExcerpt From: Mihaly Csikszentmihalyi. \u0026ldquo;Creativity.\u0026rdquo;\n","description":"","id":31,"section":"gallery","tags":["street photography"],"title":"[Weekly-31] 2019.12.01","uri":"https://nianze.ml/en/gallery/digital/2019/12/01/2019-12-01-weekly-visual-project/"},{"content":"Weekly visual project - 2019/11/24\nThe excerpt  I have always looked upon the task of a scientist as bearing the responsibility for persuading his contemporaries of the cogency and validity of his thinking. He isn’t entitled to a warm reception. He has to earn it, whether by the skill of his exposition, the novelty of his ideas, or what.\nExcerpt From: George Stigler\n","description":"","id":32,"section":"gallery","tags":["street photography"],"title":"[Weekly-30] 2019.11.24","uri":"https://nianze.ml/en/gallery/digital/2019/11/24/2019-11-24-weekly-visual-project/"},{"content":"Weekly visual project - 2019/11/16\nThe excerpt  The point is, a great deal of our limited supply of attention is committed to the tasks of surviving from one day to the next. Over an entire lifetime, the amount of attention left over for learning a symbolic domain—such as music or physics—is a fraction of this already small amount.\nExcerpt From: Mihaly Csikszentmihalyi. \u0026ldquo;Creativity.\u0026rdquo;\n","description":"","id":33,"section":"gallery","tags":["street photography"],"title":"[Weekly-29] 2019.11.16","uri":"https://nianze.ml/en/gallery/digital/2019/11/16/2019-11-16-weekly-visual-project/"},{"content":"Weekly visual project - 2019/11/09\nThe excerpt  从前一直有人认为痴心者见悦于痴心者，以后会有人认知痴心者见悦于明哲者，明哲，是痴心已去的意思，这种失却是被褫夺的被割绝的，痴心与生俱来，明哲当然是后天的事。明哲仅仅是亮度较高的忧郁。\nExcerpt From: 木心. \u0026ldquo;九月初九.\u0026rdquo;\n","description":"","id":34,"section":"gallery","tags":["street photography"],"title":"[Weekly-28] 2019.11.09","uri":"https://nianze.ml/en/gallery/digital/2019/11/09/2019-11-09-weekly-visual-project/"},{"content":"Weekly visual project - 2019/11/02\nThe excerpt  也许你要问：为什么艺术家一定要有所牺牲呢？\n这一问者，大抵不太愿意牺牲，因为还没弄清艺术是怎么回事，怕白白牺牲——我可以彻底地说：艺术本来也只是一个梦，不过比权势的梦、财富的梦、情欲的梦，更美一些，更持久一些，艺术，是个最好的梦。\n我们有共享的心理诉求。你画完一张得意的画，第一个念头就是给谁看。人一定是这样的。权势、财富，只有炫耀，不能共享，一共享，就对立了，一半财富权力给了你了。情欲呢，是两个人的事，不能有第三者。比下来，艺术是可以共享的。天性优美，才华高超，可以放在政治上、商业上、爱情上，但都会失败，失算，过气——放在艺术上最好。 Excerpt From: 木心. \u0026ldquo;文学回忆录.\u0026rdquo;\n","description":"","id":35,"section":"gallery","tags":["street photography"],"title":"[Weekly-27] 2019.11.02","uri":"https://nianze.ml/en/gallery/digital/2019/11/02/2019-11-02-weekly-visual-project/"},{"content":"Weekly visual project - 2019/10/26\nThe excerpt  所以为人之道，第一念，就是明白：人是要死的。\n生活是什么？生活是死前的一段过程。凭这个，凭这样一念，就产生了宗教、哲学、文化、艺术。可是宗教、哲学、文化、艺术，又是要死的——太阳，将会冷却，地球在太阳系毁灭之前，就要出现冰河期，人类无法生存。可是末日看来还远，教堂、博物馆、美术馆、图书馆，煞有介事，庄严肃穆，昔在今在永在的样子——其实都是毁灭前的景观。\n我是怀着悲伤的眼光，看着不知悲伤的事物。\nExcerpt From: 木心. \u0026ldquo;文学回忆录.\u0026rdquo;\n","description":"","id":36,"section":"gallery","tags":["street photography"],"title":"[Weekly-26] 2019.10.26","uri":"https://nianze.ml/en/gallery/digital/2019/10/26/2019-10-26-weekly-visual-project/"},{"content":"Weekly visual project - 2019/10/19\nThe excerpt  想到尼采反理性，元凶一直追到苏格拉底。钦佩极了。大智者。可是病源、病根早就找到了，谁也开不出药方。\n不靠理性，靠什么抗衡理性？\n一筹莫展。病入膏肓。和理性相克的东西，几乎没有。不能说是感性、本能、暴力。都不能。能与理性对立，介乎理性之上的东西，几乎没有。只有在音乐中，准确地说，在某些段落、章节中，介于理性之上。\n希腊雕像，也有这东西，在理性之上。 Excerpt From: 木心. \u0026ldquo;文学回忆录.\u0026rdquo;\n","description":"","id":37,"section":"gallery","tags":["street photography"],"title":"[Weekly-25] 2019.10.19","uri":"https://nianze.ml/en/gallery/digital/2019/10/19/2019-10-19-weekly-visual-project/"},{"content":"Weekly visual project - 2019/10/13\nThe excerpt  \u0026ldquo;群众的眼睛是雪亮的。\u0026ldquo;群众是没有眼睛的。群众还没有记忆。\nExcerpt From: 木心. \u0026ldquo;文学回忆录.\u0026rdquo;\n","description":"","id":38,"section":"gallery","tags":["street photography"],"title":"[Weekly-24] 2019.10.13","uri":"https://nianze.ml/en/gallery/digital/2019/10/13/2019-10-13-weekly-visual-project/"},{"content":"Weekly visual project - 2019/10/06\nThe excerpt  伍尔芙说，莎士比亚、托尔斯泰，都是双性人，比常人不知丰富多少。\n托尔斯泰长篇《战争与和平》曾有七稿之多，放纵潜意识跑马，最后仍以意识控制定稿。\n梦和艺术是两回事。疯子和艺术家是两种人。\n梦是散乱的、不自觉的，艺术是完整的、自觉的。疯子是破坏的，天才是创造的。艺术家的意识及潜意识要特别平衡。\n意识要加强，增加知识，经历，逻辑，善于推理，训练记忆——如何训练潜意识？\n扩大兴趣范围，“智者，是对一切都发生惊奇的人”。放纵你的好奇的行为，享受官能之乐，对一切要抱着豁达大度，对世界万物抱着“无可无不可”的态度。都有兴趣，但别迷恋。\n一句话：明哲而痴心。\n再一句话：痴心而保持明哲。\n还有一张底牌：意识是神性的，潜意识是魔性的，两者相加，即人性。\nExcerpt From: 木心. “文学回忆录.”\n","description":"","id":39,"section":"gallery","tags":["street photography"],"title":"[Weekly-23] 2019.10.06","uri":"https://nianze.ml/en/gallery/digital/2019/10/06/2019-10-06-weekly-visual-project/"},{"content":"Weekly visual project - 2019/09/28\nThe excerpt  战前，立体派诗人很活跃（从绘画的立体派过来），有阿波利奈尔（Guillaume Apollinaire）、雅各布（Max Jacob）、萨尔蒙（André Salmon）。\n他们是立体派中坚，他们有他们的道理：过去的艺术是模仿，现在要创造。阿波利奈尔有名言：当人要模仿步行时，创造了车轮，而车轮不是一条腿。超现实主义是这样出现的。\n这固然是高明的诡辩，但我要和他吵：向来的艺术，并非真是只在模拟，他们也超写实，是隐的超写实，现在不过是显的超写实。因为纯粹的写实从来没有成为艺术。\nExcerpt From: 木心. “文学回忆录.”\n","description":"","id":40,"section":"gallery","tags":["street photography"],"title":"[Weekly-22] 2019.09.28","uri":"https://nianze.ml/en/gallery/digital/2019/09/28/2019-09-28-weekly-visual-project/"},{"content":"Weekly visual project - 2019/09/21\nThe excerpt  文学家个人的命运和文学史的大命运，往往不一致。要注意个人的作品，不要随文学大流，大流总是庸俗的。小时候母亲教导我：“人多的地方不要去。”那是指偶尔容许我带仆人出门玩玩。现在想来，意味广大深长。在世界上，在历史中，人多的地方真是不去为妙。\nExcerpt From: 木心. “文学回忆录.”\n","description":"","id":41,"section":"gallery","tags":["street photography"],"title":"[Weekly-21] 2019.09.21","uri":"https://nianze.ml/en/gallery/digital/2019/09/21/2019-09-21-weekly-visual-project/"},{"content":"Weekly visual project - 2019/09/15\nThe excerpt  什么是悲观主义？我以为就是“透”观主义。不要着眼于“悲”，要着眼于“观”——万事万物都会过去的，人是要死的，欲望永远不能满足，太阳底下无新事……这就是悲观。悲观主义是一个态度，是一个勇敢的人的态度。\n得不到快乐，很快乐，这就是悲观主义。如此就有自知之明，知人之明，知物之明，知世之明。\n一切都无可奈何，难过的，但是透彻。\nExcerpt From: 木心. “文学回忆录.”\n","description":"","id":42,"section":"gallery","tags":["street photography"],"title":"[Weekly-20] 2019.09.15","uri":"https://nianze.ml/en/gallery/digital/2019/09/15/2019-09-15-weekly-visual-project/"},{"content":"Weekly visual project - 2019/09/07\nThe excerpt  艺术没有进化可言，我们读前辈的书（看画、听音乐），应有三种态度：设想在他们的时代鉴赏；据于自己的时代鉴赏；推理未来的时代鉴赏。\n举例：希腊雕像（胜利女神），那是三种鉴赏态度都能完全完满肯定。之外，莎士比亚的诗剧、莫扎特的乐曲，也是昔在、今在、永在。\nExcerpt From: 木心. “文学回忆录.”\n","description":"","id":43,"section":"gallery","tags":["street photography"],"title":"[Weekly-19] 2019.09.07","uri":"https://nianze.ml/en/gallery/digital/2019/09/07/2019-09-07-visual-project/"},{"content":"Weekly visual project - 2019/08/31\nThe excerpt  人生多少事，只能“虽不能至，心向往之”。人的幸福，其实就到心向往之的地步。整个音乐就是心向往之的境界，是拿不到的东西。\nExcerpt From: 木心. “文学回忆录.”\n","description":"","id":44,"section":"gallery","tags":["street photography"],"title":"[Weekly-18] 2019.08.31","uri":"https://nianze.ml/en/gallery/digital/2019/08/31/2019-08-31-visual-project/"},{"content":"Weekly visual project - 2019/08/25\nThe excerpt  希望大家——规模大一点小一点，速度快一点慢一点，都无妨——超越自己。三年前的你，是你现在的学生，你可以教训那个从前的自己。\n停课两个月，小别两个月，临别赠言——超越自己。 Excerpt From: 木心. “文学回忆录.”\n","description":"","id":45,"section":"gallery","tags":["street photography"],"title":"[Weekly-17] 2019.08.25","uri":"https://nianze.ml/en/gallery/digital/2019/08/25/2019-08-25-visual-project/"},{"content":"Weekly visual project - 2019/08/18\nThe excerpt  同样写饮酒，东方是借酒而忘忧、消愁，西方的酒神却是创造极乐、狂欢。\n所以，东方没有狂欢节。魏晋和唐代那么多诗人、文士颂赞酒，没有一个人正面提出酒神精神。东方人写饮酒，说来说去还是在生活层次中盘旋。当然，现在看，悲剧精神并不能救西方人。东方呢，悲观主义早就没有。现代中国人不懂得悲观。\n说到底，悲观是一种远见。鼠目寸光的人，不可能悲观。\n所谓怀疑，悲观是个开场。然后是什么呢？西方没有完成。尼采刚刚开始叫起来：“一切重新估价。”但也才刚刚叫起来。\n悲剧，简单地讲，是人与命运的抗争。\n鲁迅说：“悲剧，是把有价值的东西毁灭给你看！”说对一部分。\n...\n马克思说人类有阶级和阶级斗争。我认为人类只有知与无知的斗争。一切智慧都是从悲从疑而来。我不知道此外还有何种来源可以产生智慧。 Excerpt From: 木心. “文学回忆录.”\n","description":"","id":46,"section":"gallery","tags":["street photography"],"title":"[Weekly-16] 2019.08.18","uri":"https://nianze.ml/en/gallery/digital/2019/08/18/2019-08-18-visual-project/"},{"content":"Weekly visual project - 2019/08/11\nThe excerpt  人类的伟大高贵，完全在于精神生活，在于少数的精神贵族，亦即天才和天才的朋友（欣赏者）。 Excerpt From: 木心. “文学回忆录.”\n","description":"","id":47,"section":"gallery","tags":["street photography"],"title":"[Weekly-15] 2019.08.11","uri":"https://nianze.ml/en/gallery/digital/2019/08/11/2019-08-11-visual-project/"},{"content":"Weekly visual project - 2019/08/04\nThe excerpt  但古代虽然专制，诗人还可以悲哀。我遇到的时代，谁悲哀，谁就是反革命。所以热爱生活啊、健康积极向上啊，饱含恶念，是阴谋，是骗局，是透明的监狱，是愚民的毒药。我一步步看出这种虚伪，用心之刻毒，远远超出古代。对照起来，要在汉末、魏晋、南北朝，做个艺术家、做个诗人，并不很难，在我青壮年时代，你要活得像个人，太不容易了。所以我同情阮籍，阮籍更应该同情我哩。\nExcerpt From: 木心. “文学回忆录.”\n","description":"","id":48,"section":"gallery","tags":["street photography"],"title":"[Weekly-14] 2019.08.04","uri":"https://nianze.ml/en/gallery/digital/2019/08/04/2019-08-04-visual-project/"},{"content":"Weekly visual project - 2019/07/28\n碎言 曼哈顿寸土寸金，我扫街的时候，每隔几个街区却总能发现一座教堂。高耸的哥特式尖塔，有如在钢筋混凝土的森林里点缀上香薰蜡烛,指引迷途的旅魂。摘一段木心先生的话：\n 我要相信，或者，我要推翻的那个神，都不是曾经说过的那个神。我最心仪的是音乐、建筑、绘画所体现的宗教情操，那是一种圆融的刚执，一种崇高的温柔。以这样的情操治国、建邦、待人接物，太美好了。\n人类既有这样美好的情操，不给自己，却奉给上帝，数千年没有回报，乃是最大的冤案。听听圣歌，看看伟拔教堂，可知人类多么伟大。人类的悲剧，是对自身的误解。\n宗教是要把人类变成天上的神的家畜，人再也回不到原来野生的状态。家畜成为人类的牺牲品，人类成为自己的牺牲品。尼采说，人本来有这样多的情操，不应该交给上帝。\n\u0026hellip;\n佛教造大佛，用于视觉；击鼓敲木鱼，用于听觉；焚香，用于嗅觉；素食，用于味觉——人类这般伟大、聪明，为什么不用于人类自己，而去奉神？\n希望大家重视宗教艺术，要把含在宗教里的艺术，含在艺术里的宗教，细细分开来。先明白基督教、佛教等是怎么回事，了解其人格高超，一等，然后再去接触宗教的建筑、服装、礼仪、绘画、雕刻，原来是这样体现人类最高精神、最高智慧，而这等宗教文化，又是如何经过兴衰存亡的过程。\n这是很有味道的事。你到欧洲，扑面而来的都是艺术和宗教。\n给父母、子弟、情人的，也不及人类把最好的情操送给上帝，送给宗教。\n The excerpt  中外不少诗人死得早，哲学家多长寿。孟子说：“吾善养吾浩然之气。”这话很文学。“浩然”，形容词，可随时代和个人的差别而解释。文天祥用“浩然”，是爱国，曹雪芹又作别解。要我解，比文天祥胆小，比曹雪芹老实。我以为“浩然之气”，指元气，如你果然献身艺术，艺术会给你不尽元气，一份诚意，换一份元气。牺牲功利，牺牲爱情，背叛政治，得到艺术，真的要牺牲。\n小细节上更难。光阴逝，要在一秒一秒消失的光阴中，保持艺术家风度，守身如玉，决不让步。\n“善养”，指懂得养。\n孟子还提出“存夜气”。后半夜是“平旦之气”，此是养身法，是生理的，又是心理的。我乡下有“平旦”是“卯气”的说法。肖邦、瓦莱里，都懂，一早起创作。\nExcerpt From: 木心. “文学回忆录.”\n","description":"","id":49,"section":"gallery","tags":["street photography"],"title":"[Weekly-13] 2019.07.28","uri":"https://nianze.ml/en/gallery/digital/2019/07/28/2019-07-28-visual-project/"},{"content":"The excerpt  传道散了，耶稣独自在海面走。门徒惊异，耶稣说勿惊。彼得也从水面走去，怕落水，呼救，耶稣拉他的手近拢，说：你这小信的人，为什么不信我？\n...\n以宗教看，奇迹之一，是用寓言对待其象征性。一个人能否成大器，主观因素最重要，被人忽略的是信心，是信念。信心，信念，一半凭空想，一半凭行动（用功、才能等等）。我的大半生，阅人多矣，阅艺术家多矣。确切说，想成为艺术家者多矣，此后生如行于海，磨难如风浪，但太多人行于海，怕沉没，害怕了，有人沉没，有人时浮时沉。\n一路多小信的人。\n我不比人慧，不比人强，数十年间认识的精英分子前后六批，凡五十人，有大才，甚至天才，至今剩我一人。如果他们成了，文艺复兴。\n下了海，要走下去。\n...\n信心到底哪里来？信心就是忠诚。立志，容易。忠诚其志，太难。许多人立志，随立随毁，不如不立。艺术，爱情，政治，商业，都要忠诚。求道，坚定忠诚无疑，虽蹈海，也走下去。\n所谓第二流者，是原来志在一流，天时、地利、人和，均不合，成了二流。如果甘于二流三流，已经居下流了。\nExcerpt From: 木心. “文学回忆录.”\n ","description":"","id":50,"section":"gallery","tags":["street photography","generative art"],"title":"[Weekly-11] 2019.07.14","uri":"https://nianze.ml/en/gallery/digital/2019/07/14/2019-07-14-visual-project/"},{"content":"Weekly shots - 2019/07/07\nThe excerpt  关于“打右脸给左脸，勿以眼还眼、以牙还牙，爱仇敌……”这几段话，是无抵抗主义的最高纲领。甘地、托尔斯泰都遵守，都信以为真，身体力行。\n\u0026hellip;\n这段话的精义是什么呢，在于开启人的心怀，开阔到了右脸被打，左脸也凑过去。其实是韬略，是战术。两个好人误会了，一方解释不了，或来不及解释，一方情急动手了，被打的不还手、不躲避，打的那个就会自省：他是好人啊，惭愧啊，误会他了，委屈他了。\n这种忍辱功夫，以柔克刚，是为使人愧悔，是感化的战术——优待俘虏、大赦战犯，都出于这个原则。佛家的慈悲、道家的虚纳（如婴、如水）都源于这种无抵抗的抵抗，以含垢忍辱占上风。吓倒你，不彻底的，使你惭愧而悔改，才是真的征服。\n但耶稣的心理战限于好人之间。歹人、不义之徒，打了右脸打左脸，剥了外衣剥内衣。人类历史就这样。代表人类雕像的，就是鼻青脸肿的亚当、夏娃，赤条条一对，被强逼白走了两千年。\n世界是一群左右脸给人打、内外衣给人剥的亚当、夏娃。\n都给人白打，给人白剥！\n\u0026hellip;\n耶稣讲话是话中有话。我不是好人，也不是坏人，所以听来格外有感。\n一个爱我的人，如果爱得讲话结结巴巴，语无伦次，我就知道他爱我。\n凡真的先知，总是时而雄辩，时而结巴。凡是他说不上来的时候，我最爱他。\n假先知都是朗朗上口的。我全不信。我知道他不爱。\nExcerpt From: 木心. “文学回忆录.”\n","description":"","id":51,"section":"gallery","tags":["street photography"],"title":"[Weekly-10] 2019.07.07","uri":"https://nianze.ml/en/gallery/digital/2019/07/07/2019-07-07-street-photography/"},{"content":"Weekly shots - 2019/06/30\nThe excerpt  弥诺陶洛斯，象征欲望。建筑师代达罗斯，即制造迷楼者，象征制定伦理、制度、道德、条例者。迷楼，象征社会，监囚人，人不得出，包括婚姻、法律、契约。在社会中，人进入店，见食物，不能拿，因没有钱，拿即犯法。动物见食便吃。建筑师也出不来，作法自毙。\n唯一的办法是飞。飞出迷楼。艺术家，天才，就是要飞。然而飞高，狂而死。青年艺术家不懂，像伊卡洛斯，飞高而死，他的父亲是老艺术家，懂。\n我曾为文，将尼采、托尔斯泰、拜伦，都列入飞出的伊卡洛斯。但伊卡洛斯的性格，宁可飞高，宁可摔死。\n一定要飞出迷楼，靠艺术的翅膀。宁可摔死。\n欲望，是要关起来，现代迷楼，更难飞出，需要更大的翅膀。\n\u0026hellip;\n纪德（André Gide）解释那耳喀索斯，解释得好。大意是，那耳喀索斯是人的自我，在时间的泉水里发现了映影，这映影，便是艺术，是超自我的自我。艺术不能完成真实，不能实际占有，只可保持距离，两相观照；你要沾惹它，它便消失了，你静着不动，它又显现。\n我觉得艺术、哲学、宗教，都是人类的自恋，都在适当保持距离时，才有美的可能、真的可能、善的可能。如果你把宗教当做哲学对待，就有了距离，看清宗教究竟是什么；如果你把哲学当做艺术对待，就有了距离，看清哲学究竟是什么；如果你把艺术当做宗教对待，就有了距离，看清艺术究竟是什么——我的意见是，将宗教作宗教来信，就迷惑了；将哲学作哲学来研究，就学究了；将艺术作艺术来玩弄，就玩世不恭了。原因，就在于太直接，是人的自我强求，正像那耳喀索斯要亲吻水中的影。而那耳喀索斯是智者，一次两次失败后，不再侵犯自我，满足于距离，纯乎求观照，一直到生命的最后。可见“禅”，东方有，西方也有，换个名称就是“悟”，彻悟，悟又从“迷”来，不垢不净，不迷不恒。那耳喀索斯就因为一度伸手触抚，又一度俯唇求吻，才使他过后保持不饮不食，不眠不动，在时间和空间里证见自我，这就是人类的自我。\n整个希腊文化，可以概称为“人的发现”；全部希腊神话，可以概称为“人的倒影”。妙在倒影比本体更大、更强，而且不在水里，却在天上，在奥林匹斯山上。\n\u0026hellip;\n那耳喀索斯的神话，象征艺术与人生的距离。现实主义取消距离，水即乱。这是人生与艺术的宿命。艺术家只要能把握距离到正好，就成功，不分主义。\n\u0026hellip;\n早先初民的智能，以为风吹孩子，风就是父亲，以为火苗就是野兽，以己度人、度世界。早古人类的疑问，是自问自答，因无人回答，故神话以人类自问自答的方式流传，人格化。此即神话之前的文学雏形。再早，是口传，好则留，坏则不留。到现代、近世，传播出版发达，却相反，坏的容易传播，好的不易流传。\n人类文化的悲哀，是流俗的易传、高雅的失传。\nExcerpt From: 木心. “文学回忆录.”\n","description":"","id":52,"section":"gallery","tags":["street photography"],"title":"[Weekly-9] 2019.06.30","uri":"https://nianze.ml/en/gallery/digital/2019/06/30/2019-06-30-street-photography/"},{"content":"Weekly shots - 2019/06/22\n","description":"","id":53,"section":"gallery","tags":["street photography"],"title":"[Weekly-8] 2019.06.22","uri":"https://nianze.ml/en/gallery/digital/2019/06/22/2019-06-22-street-photography/"},{"content":"A review of some basic music theory before the NYU Steinhardt music technology placement exam.\nIntervals  Perfect Intervals: 1(perfect unison), 4(perfect 4th), 5(perfect 5th), 8(perfect octave) Major Intervals: 2(major 2nd), 3(major 3rd), 6(major 6th), 7(major 7th)  Scales  major scale (WWHWWWH) natural minor scale / aeolian scale (WHWWHWW) = based off the 6th degree that shares the key signature of the major scale harmonic minor scale(WHWWH1.5H) = natural minor + sharpened 7th degree melodic minor scale(ASC:WHWWWWH, DESC:WWHWWHW) = the ascending form of the scale has both a raised 6th and 7th degree, and the descending form of the scale reverts back to the natural minor scale form chromatic scale(H*12) = constructed entirely of half steps or semitones. wholetone scale(W*6) = constructed entirely of whole-steps or tones. lydian scale(WWWHWWH) = based off the 4th degree of any major scale (C major scale from its fourth degree (F) -\u0026gt; F lydian scale) mixolydian scale(WWHWWHW) = based off the 5th degree of any major scale (C major scale from its fifth degree (G), -\u0026gt; G mixolydian scale)  Chords  Tonic: the note considered to be the basis of the chord, e.g.: C, D, … Quality  major chords = 1,3,5 notes of major scale, major 3rd followed by minor 3rd; minor chords = 1,3,5 notes of minor scale, minor 3rd followed by major 3rd, same as a major chord but the third being lowered a semitone diminished chords = similar to minor, but the top note (the fifth) is also flattened, minor 3rd followed by minor 3rd. augmented chords = similar to major, but the top note (the fifth) is raised by a semitone, major 3rd followed by a major 3rd dominat 7th chords = similar to major, with the addition of a flattened seventh above the root note of the chord (C Dominant 7th = C,E,G,bB); within a diatonic context, it’s based from the 5th/dominant of any major key, so in the key of C major, the dominant 7th chord starts on G (GBDF)   Inversion: which note of the chord is placed at the bottom (root, 1st inversion, 2nd inversion)  Key Signatures  Relative minor \u0026amp; major keys: the sixth degree of the major key is the relative minor key, both share exactly the same key signature (C major -\u0026gt; A minor); similarly, to find the relative major of a minor key = either count down 6 notes, or count up to the 3rd note. To add a flat sign, count up four notes from root; to add a sharp, count up five notes.  Chord Progressions  Labelling:  C Major Root Position: C = I C Major 1st Inversion: C/E = Ib = I6 = I6/3 C Major 2nd Inversion: C/G = Ic = I6/4 G7 1st Inversion: G7/B = Vb = V6/5 G7 2nd Inversion: G7/D = Vc = V4/3 G7 3rd Inversion: G7/F = Vd = V4/2    Meter  Simple meters: the top number in the time signature is a 3 or divisible by 2 (e.g., 2/4, 3/4, 4/4, 2/2, 3/2, 4/2).  4/4: simple quadruple, can be represented by a ‘C’, known as common time; 2/2 can be represented by ‘C’ with a vertical line through it, known as cut common time 2/4: simple duple meter. A bar consists of 2 crotchet beats 2/3: simple triple meter. A bar consists of 3 crotchet beats   Compound meters: top number in the time signature is divisible by 3, by a number greater than 1 (e.g., 6/8, 9/8, 12/8). The rhythmic value that is defined in the bottom number of the time signature, is grouped in 3s, which gives them distinct feel Beams: lines that connect shorter note values and help to clearly display the main beats of a meter. Grouping: as a general rule, the main beats of the meter must be clearly visible within the displayed rhythm at all times ","description":"","id":54,"section":"notes","tags":["music theory"],"title":"Basic Musicianship Review","uri":"https://nianze.ml/en/notes/2019/06/basic-musicianship-review/"},{"content":"Weekly shots - 2019/06/15\n","description":"","id":55,"section":"gallery","tags":["street photography"],"title":"[Weekly-7] 2019.06.15","uri":"https://nianze.ml/en/gallery/digital/2019/06/15/2019-06-15-street-photography/"},{"content":"Weekly shots - 2019/06/08\n","description":"","id":56,"section":"gallery","tags":["street photography"],"title":"[Weekly-6] 2019.06.08","uri":"https://nianze.ml/en/gallery/digital/2019/06/08/2019-06-08-street-photography/"},{"content":"Weekly shots - 2019/06/01\n今年纽约的5月总爱下雨，让人不禁多愁善感起来。\n","description":"","id":57,"section":"gallery","tags":["street photography"],"title":"[Weekly-5] 2019.06.01","uri":"https://nianze.ml/en/gallery/digital/2019/06/01/2019-06-01-street-photography/"},{"content":"Weekly shots - 2019/05/25\n","description":"","id":58,"section":"gallery","tags":["street photography"],"title":"[Weekly-4] 2019.05.25","uri":"https://nianze.ml/en/gallery/digital/2019/05/25/2019-05-25-street-photography/"},{"content":"Weekly shots - 2019/05/18\n","description":"","id":59,"section":"gallery","tags":["street photography"],"title":"[Weekly-3] 2019.05.18","uri":"https://nianze.ml/en/gallery/digital/2019/05/18/2019-05-18-street-photography/"},{"content":"Weekly shots - 2019/05/11\n","description":"","id":60,"section":"gallery","tags":["street photography"],"title":"[Weekly-2] 2019.05.11","uri":"https://nianze.ml/en/gallery/digital/2019/05/11/2019-05-11-street-photography/"},{"content":"Weekly shots - May the 4th (be with you)\n最近读了Twyla Tharp的The Creative Habit,很受启发。我决定每天下班回家的时候，在纽约的街头多走走，用随身的手机街拍。每周六就节选出比较好的照片发到这里来，作为岁月的留念。\n","description":"","id":61,"section":"gallery","tags":["street photography"],"title":"[Weekly-1] May the 4th..","uri":"https://nianze.ml/en/gallery/digital/2019/05/04/2019-05-04-street-photography/"},{"content":"What would it sound like if trading market data speaks?\nA little background This little project tries to do one thing for fun: to transform the trading market history data into some sords of sound.\nThe techniques involve some basic use of web audio API and D3.js. All the ticker names are collected from dumb stock api, while all the trading history data comes from ALPHA VANTAGE. Since support for web audio API is different by different browsers, it is highly suggested to try this demo with Chrome.\n     -            Feel free to choose any company interesting to you by typing/selecting corresponding stock exchange name as well as company security ticker (e.g.: NASDAQ for exchange and FB as ticker to listen to how Facebook sounds like.)\n   Currently the mapping from market data to sound is naive:\n Each beat stands for one day of the security price in the past, ordered by the security\u0026rsquo;s trading history. Sound frequency: the higher the daily close price, the higher the frequency. Waveform: if the daily open price is lower than close price, a beat of triangle wave sound is generated, otherwise the sine wave. Duration between each two beats are determined by the earlier day\u0026rsquo;s market volume: larger market volume comes with shorter duration.  Apart from the chart for market data, each beat is also visualized to show their waveform and frequency domain distribution.\n  Of course, listening to only one security ticker at a time isn\u0026rsquo;t that much fun. Some good way to extend this project might be to map multiple securities into different sounds, and play them simultaneously, in the hope of creating some sort of \u0026ldquo;symphony\u0026rdquo;.\n","description":"","id":62,"section":"posts","tags":["music","technique"],"title":"Trade Beats","uri":"https://nianze.ml/en/posts/2018/12/use-trading-market-data-to-create-beat-sounds/"},{"content":"std::atomic is for data accessed from multiple threads without using mutexes (concurrent usage); volatile is for memory where reads and writes should not be optimised away (special memory).\nstd::atomic template Instantiations of std::atomic template offer operations that are guaranteed to be seen as atomic by other threads, as if they were inside a mutex-protected critical section, generally with the support of special machine instructions that are more efficient than the case of mutex. For example:\n1 2 3 4 5  std::atomic\u0026lt;int\u0026gt; ai(0); // init. ai to 0 ai = 10; // atomically set ai to 10 std::cout \u0026lt;\u0026lt; ai; // atomically read ai\u0026#39;s value ++ai; // atomically increment ai to 11 --ai; // atomically decrement ai to 10   During execution of these statements, other threads reading ai may see only values of 0, 10, or 11 (assuming, of course, this is the only thread modifying ai). Two things worth noting here:\n For std::cout \u0026lt;\u0026lt; ai;, only the read of ai is atomic, so it\u0026rsquo;s possible that between the time ai\u0026rsquo;s value is rad and operator\u0026lt;\u0026lt; is invoked to write it to standard output, another thread may modify ai\u0026rsquo;s value. The increment and decrement of ai are read-modify-write (RMW) operations, and they execute atomatically as well, which is one of the nicest characteristics of the std::atomic types that they guarantee all member functions on std::atomic types will be seen by other threads as atomic. The use of std::atomic imposes restrictions that no code precedes a write of a std::atomic variable may take place afterwards. No reorder tricks for compiler/hardwaes for speed-up optimization purpose.  In contrast, volatile offers no guarantee of operation atomicity and suffer insufficient restrictions on code reordering - basically not useful in multithreaded context. Say if we have a counter defined as volatile int vc(0), and there are two threads increment the volatile counter simultaneously, then the ending value of vc need not be 2 - the RMW operation in each of two threads may take place in any order, involving in a data race, which leading to undefined behavior according to Standard\u0026rsquo;s decree.\nThe place in which volatile shines is in the context where redundant loads and dead stores should not be optimized away, that is, we need special memory to perform such kinds of redundent reads and superfluous writes:\n1 2 3 4 5  auto y = x; // read x y = x; // read x again  x = 10; // write x x = 20; // write x again   The most common kind of special memory is memory used for memory-mapped I/O, which is used for communication with peripherals, e.g., external sensors or displays, printers, network ports, etc. rather than reading or writing normal memory (i.e., RAM). volatile is the way to tell compilers that we\u0026rsquo;re dealing with special memory.\nBecause std::atomic and volatile serve different purposes, they can be used together:\n1  volatile std::atomic\u0026lt;int\u0026gt; vai; // operations on vai are atomic and can\u0026#39;t be optimized away   This could be useful if vai corresponded to a memory-mapped I/O location that was concurrently accessed by multiple threads.\n","description":"","id":63,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-40 Use std::atomic for Concurrency, volatile for Special Memory","uri":"https://nianze.ml/en/notes/2018/10/use-stdatomic-for-concurrency-volatile-for-special-memory/"},{"content":"Using std::promises and futures is useful skill to create one-shot communication between a detecting task and reacting task.\nSometimes we want a task to detect some event and then inform a second asynchronously running task to proceed when some event has taken place (e.g., a data structure has been initialized, a stage of computation has been completed, a significant sensor value has been detected, etc.). In other words, a detecting task will detect a special event/condition, and a reacting task will wait until the detecting task notifies that the event occurs/condition changes.\nIf we only want to inform once, we can take use of the power of std::promises and futures (i.e., std::future and std::shared_future). Since both std::promise and futures are templates requiring a type parameter that indicates the type of data to be transmitted through the communications channel, we specify this type as void indicating that no data is to be conveyed:\n The detecting task will set its std::promise\u0026lt;void\u0026gt; when the event of interest occurs The reacting task will wait on its std::future\u0026lt;void\u0026gt; or std::shared_future\u0026lt;void\u0026gt; The communications channel wil permit the reacting task to know when the detecting task has written its void data by calling set_value on its std::promise  The essence of the technique looks like,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  std::promise\u0026lt;void\u0026gt; p; void react(); // func for reacting task  void detect() { // func for detecting task  std::thread t([]{ p.get_future().wait(); // suspend t until future is set  react(); }); ... // here t is suspend prior to call to react  p.set_value(); // event detected, so t is unsuspended (and thus call react)  ... // do additional work, program is terminated if this part of code throws  t.join(); // make t unjoinable }   Taking use of std::future::share()1, a general form is easy to implement where originally one reacting task extent to many:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  std::promise\u0026lt;void\u0026gt; p; // as before  void detect() // now for multiple reacting tasks { auto sf = p.get_future().share(); // sf\u0026#39;s type is std::shared_future\u0026lt;void\u0026gt;  std::vector\u0026lt;std::thread\u0026gt; vt; // container for reacting threads  for (int i = 0; i \u0026lt; ThreadsToRun; ++i) { vt.emplace_back([sf]{ sf.wait(); // wait on local copy of sf  react(); }); // see item 42 for info on emplace_back  } ... // program is terminated if this part of code throws  p.set_value(); // unsuspend all threads  ... for (auto\u0026amp; t : vt) { t.join(); // make all threads unjoinable  } }    std::future::share() transfers ownership of its shared state to the std::shared_future produced by std::future::share()\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":64,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-39 Consider Void Futures for One-Shot Event Communication","uri":"https://nianze.ml/en/notes/2018/10/consider-void-futures-for-one-shot-event-communication/"},{"content":"Future destructors normally just destroy the future\u0026rsquo;s data members, execept for the final future referring to a shared state for a non-deferred task launched via std::async, which blocks until the task completes.\nItem 37 notes that the destruction of a joinable std::thread terminates the program. As a comparicon, the behavior of destructor for a future is quit different.\nTo take a closer examination on future\u0026rsquo;s destruction behavior, let\u0026rsquo;s first understand that future is one end of a communications channel through which a callee transmits a result to a caller. The model works like this:\n The callee (usually running asynchronously) writes the result of its computation into the communications channel (typically via a std::promise object A location known as shared state (typically represented by a heap-based object, which is outside both caller and callee) then stores a copy of the result, which is previously local to the callee and will be destroyed when the callee finished As the name suggests, this location is also accessible by futures that are associated with the caller.  The relationship looks like this:\n future Shared State std::promise Caller\u0026lt;---------------Callee's Result\u0026lt;----------------------Callee (typically) Now comes the behavior of a future\u0026rsquo;s destructor:\n The destructor for the last future referring to a shared state for a non-deferred task launched via std::async blocks until the task completes (which acts like an implicit join on the underlying thread) The destructor for all other futures simply destroys the future object (which acts like an implicit detach on the underlying thread.)  In other words, the implicit join occurs only if all of the following apply to a future:\n it refers to a shared state that was created due to a call to std::async the task\u0026rsquo;s launch policy is std::launch::async, either because that was chosen by the runtime system or because it was specified in the call to std::async the future is the last one referring to the shared state. For std::futures, this is always the case. For std::shared_futures, other earlier future\u0026rsquo;s destructor simply destroys its data members ","description":"","id":65,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-38 Be Aware of Varying Thread Handle Destructor Behavior","uri":"https://nianze.ml/en/notes/2018/10/be-aware-of-varying-thread-handle-destructor-behavior/"},{"content":"Join-on-destruction can lead to difficult-to-debug performance anomalies; while detach-on-destruction can lead to difficult-to-debug undefined behavior.\nEvery std::thread object is in one of two states:\n joinable: corresponding to an underlying asynchronous thread of execution that is or could be running.  A std::thread corresponding to an underlying thread that\u0026rsquo;s waiting to be scheduled, blocked, or have run to comletion are all considered joinable.   unjoinable:  Default-constructed std::threads: such std::threads have no function to execute, thus corresponding to no underlying thread of execution std::thread that have been joined: after a join, the std::thread object no longer corresponding to the underlying thread of execution which has finished running. std::threads that have been detached: a detach severs the connection between a std::thread object and the underlying thread of execution it corresponds to.    Due to the requirement that if the destructor for a joinable thread is invoked, execution of the program (i.e., all threads) is terminated. The destructor of std::thread behaves in this way because the two other obvious options are arguably worse:\n An implicit join: thus a std::thread\u0026rsquo;s destructor would wait for its underlying asynchronous thread of execution to complete, leading to performance anomalies that would be difficult to track down. An implicit detach: then a std::thread\u0026rsquo;s destructor would sever the connection between the std::thread object and its underlying thread of execution, which would continue to run. That is wild.  The Standardization Committee decided this program termination behavior just to tell us that we need to ensure a std::thread object is made unjoinable on every path out of the scope in which it\u0026rsquo;s defined. That is, we can use RAII technique to take care of that.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class ThreadRAII { public: enum class DtorAction { join, detach }; ThreadRAII(std::thread\u0026amp;\u0026amp; t, DtorAction a) : action(a), t(std::move(t)) {} ~ThreadRAII { if (t.joinable()) { if (action == DtorAction::join) { t.join(); } else { t.detach(); } } } ThreadRAII(ThreadRAII\u0026amp;\u0026amp;) = default; // explicitly requesting the default move operations  ThreadRAII\u0026amp; operator=(ThreadRAII\u0026amp;\u0026amp;) = default; // since customized destructor prevent compiler-generated ones  std::thread\u0026amp; get() { return t; } private: DtorAction action; std::thread t; };   A few points:\n std::thread objects aren\u0026rsquo;t copyable, so we accepts only std::thread rvalues The parameter order in the constructor is designed to be intuitive to callers, but the member initialization list is designed to match the order of the data members' declarations, in which we put the std::thread object last in case the std::thread depends on other data members. get is provided to access the underlying std::thread object so that we gain the full std::thread interface for free A check to make sure the t is joinable in destructor is necessary in case that clients used get to acquire t and then did a move from t or called join or detach on t, making t unjoinable. If in the client code there are simultaneous calls trying to invoke two member functions (the destructor and something else) on one object at the same time, there is a race: between execution of t.joinable() and invocation of join or detach, another thread could render t unjoinable.1   In general, simultaneous member function calls on a single object are safe only if all are to cont member functions.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":66,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-37 Make std::threads Unjoinable on All Paths","uri":"https://nianze.ml/en/notes/2018/10/make-stdthreads-unjoinable-on-all-paths/"},{"content":"The flexibility that default policy for std::async permits both async and sync task execution leads to uncertainty when accessing thread_locals, implies that the task may never execute, and affects program logic for timeout-based wait calls.\nWhen requesting a function f to be run in accord with a std::async, there are two standard launch policies, each represented by an enumerator in the std::launch scoped enum:\n The std::launch::async launch policy: f must be run asynchronously on a different thread. The std::launch::deferred launch policy: f may run only when get or wait is called on the future returned by std::async.  In the 2nd policy, things go like this: f\u0026rsquo;s execution is deferred until a caller invokes get or wait, upon which time f will execute synchronously and block the caller until f finishes running. If neither get nor wait is called, f will never run.\nThe default launch policy, however, uses an OR-ed version of the above two policies:\n1 2 3 4 5  auto fut1 = std::async(f); // the same meaning as below  auto fut2 = std::async(std::launch::async | std::launch::deferred, f);   This default policy permits f to be run either asynchronously or synchronously, depending on the decision of thread-management components of the Standard Library about the best step to do to avoid oversubscription and load balancing. This flexibility, however, also imtroduces some limitations:\n  It\u0026rsquo;s not possible to predict whether f will run concurrently with t, since f might be scheduled to run deferred.\n  It\u0026rsquo;s not possible to predict whether f runs on a thread different from the thread invoking get or wait on fut\n  It may not be possible to predict whether f runs at all, since it may not be possible to guarantee that get or wait will be called on fut along every path through the program\n  It affects wait-based loops using timeouts, since calling wait_for or wait_until on a task that\u0026rsquo;s deferred yields the value std::future_status_deferred, leading to following code run forever in some special cases:\n1 2 3 4 5 6 7 8 9 10 11 12 13  using namespace std::literals; void f() { std::this_thread::sleep_for(1s); } auto fut = std::async(f); // run f in default launch policy  while (fut.wait_for(100ms) != // f never yield read  std::future_status::ready) // when deferred { ... }     Solution To deal with these limitations, if we use both the default launch policy as well as the timeout-based wait calls, we need to check for deferred case:\n1 2 3 4 5 6 7 8 9 10 11 12 13  ... if (fut.wait_for(0s) == std::future_status::deferred) { ... // use wait or get on fut to call f synchronously } else { while (fut.wait_for(100ms) != // f never yield read  std::future_status::ready) // when deferred  { ... // do concurrent work until it\u0026#39;s ready  } ... // fut is ready }   In summary, using std::async with the default launch policy for a task is fine as long as following conditions are fulfilled:\n The task need not run concurrently with the thread calling get or wait It doesn\u0026rsquo;t matter which thread\u0026rsquo;s thread_local variables are read or written Either there\u0026rsquo;s a guarantee that get or wait will be called on the future returned by std::async or it\u0026rsquo;s acceptable that the task may never execute Code using wait_for or wait_until takes the possibility of deferred status into account like above example.  If any of the conditions above fails to hold, schedule the task for truly asynchronous execution:\n1  auto fut = std::async(std::launch::async, f); // launch f asynchronously   A nice wrapper for this purpose goes like this:\n1 2 3 4 5 6 7 8 9 10 11 12  // C++11 version template\u0026lt;typename F, typename... Ts\u0026gt; inline std::future\u0026lt;typename std::result_of\u0026lt;F(Ts...)\u0026gt;::type\u0026gt; reallyAsync(F\u0026amp;\u0026amp; f, Ts\u0026amp;\u0026amp;... params) { return std::async(std::launch::async, std::forward\u0026lt;F\u0026gt;(f), std::forward\u0026lt;Ts\u0026gt;(params)...); } auto fut = reallyAsync(f); // run f asynchronously; throw if std::async would throw   1 2 3 4 5 6 7 8 9 10  // C++14 version template\u0026lt;typename F, typename... Ts\u0026gt; inline auto reallyAsync(F\u0026amp;\u0026amp; f, Ts\u0026amp;\u0026amp;... params) { return std::async(std::launch::async, std::forward\u0026lt;F\u0026gt;(f), std::forward\u0026lt;Ts\u0026gt;(params)...); }   ","description":"","id":67,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-36 Specify std::launch::async if Asynchronicity Is Essential","uri":"https://nianze.ml/en/notes/2018/10/specify-stdlaunchasync-if-asynchronicity-is-essential/"},{"content":"Thread-based programming calls for manual management of thread exhaustion, oversubscription, load balancing, and adaptation to new platforms, while task-based programming via std::async with the default launch policy handles most of the issues for us.\nIn concurrent C++ software, there are three meansings for threads:\n Hardware threads are threads that actually perform computation. Contemporary machine architectures offer one or more hardware threads per CPU core. Software threads (a.k.a., OS threads or system threads) are the threads that the operating system manages across all processes and schedules for execution on hardware threads. std::threads are objects in a C++ process that act as handles to underlying software threads.  Since software threads are a limited resource, a std::system_error exception may be thrown if we try to create more of them than the system can provide, even if the function we want to run can\u0026rsquo;t throw:\n1 2  int doAsyncWork() noexcept; std::thread t(doAsyncWork); // throws if no more threads are available   This limitation leads to follow-up problems we need to deal with:\n if no more threads are available and we run doAsyncWork on the current thread, there are issues of unbalanced loads, or even dead lock. even if there\u0026rsquo;re still more threads available, we need to face the trouble of oversubscription, where there are more unblocked software threads than hardware threads, and context switches increase the overall thread management overhead of the system, especially when the hardware thread on which a software thread is scheduled is switched on a diffferent core in a new time-slice.  Using std::async free us from all these problems by dumping them on somebody else who is responsible to implement the C++ Standard Library:\n1  auto fut = std::async(doAsyncWork);   The implementer of C++ Statndard Library solves the \u0026ldquo;out-of-threads\u0026rdquo; problem by providing no guarantee that there will be a new software thread: it permits the OS scheduler to arrange for the specified function (doAsyncWork) to be run on the thread requesting doAsyncWork\u0026rsquo;s result (i.e., on the thread calling get or wait on fut), and reasonable schedulers take advantage of that freedom if the system is oversubscribed or is out of threads. Since runtime scheduler manages the threads from all processes, it is likely to comprehend the whole picture better and be more capable to solve the load-balancing issues than we do1.\nEdge Cases There are some situations where using threads directly may be appropriate:\n We need access to the API of the underlying threading implementation via the member function native_handle in std::thread objects2. There is no counterpart to this functionality for std::futures that std::async returns. We need to and are able to potimize thread usage for our application. E.g., developing server software with a known execution profile that will be deployed as the only significant process on a machine with fixed hardware characteristics. We need to implement threading technology beyond the C++ concurrency API. E.g., thread pools on platforms where our C++ implementations don\u0026rsquo;t offer them.   State-of-the-art thread schedulers employ system-wide thread pools to avoid oversubscription, while improving load balancing across hardware cores through work-stealing algorithms. It will be reasonable to expect that some vendors will take advantage of this technology in their Standard Library implementations, and anyone taking a task-based approach to concurrent programming will automatically reap the benefits.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n The C++ concurrent CPI is implemented using a lower-level platform-specifit API, usually pthreads or Windows' Threads, which are richer than what C++ offers. For example, C++ has no notion of thread priorities or affinities.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":68,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-35 Prefer Task-Based Programming to Thread-Based","uri":"https://nianze.ml/en/notes/2018/08/prefer-task-based-programming-to-thread-based/"},{"content":"Lambdas are more readable, more expressive, and may be more efficient than using std::bind.\nMore readable Suppose we want a function to set up an audible alarm that will go off an hour after it\u0026rsquo;s set and that will stay on for 30 seconds, with the alarm sound remaining undecided.\n1 2 3 4  using Time = std::chrono::steady_clock::time_point; enum class Sount {Beep, Siren, Whistle}; using Duration = std::chrono::steady_clock::duration; void setAlarm(Time t, Sound s, Duration d); // at time t, make sound s for duration d   In C++14, it is very easy to write a lambda version, which is also straight-forward to read:\n1 2 3 4 5 6 7 8  auto setSoundL = [](Sound s) { using namespace std::chrono; using namespace std::literals; setAlarm(steady_clock::now() + 1h, // alarm to go off  s, // in an hour for  30s); // 30 seconds  }   If we decide to use std::bind, it looks like this:\n1 2 3 4 5 6 7  auto setSoundB = std::bind(setAlarm, std::bind(std::plus\u0026lt;\u0026gt;(), std::bind(steady_clock::now), 1h), _1, 30s);   Here, we used two extra bind inside the outer bind instead of passing now() + 1h directly as an argument of std::bind, because we want to defer evaluation of the timestamp expression until when setAlarm is called, rather than when std::bind is called. In C++11, however, the template type argument for the standard operator tempaltes can not be omitted, so the C++11 std::bind equivalent look like this shxt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  struct genericAdder { template\u0026lt;typename T1, typename T2\u0026gt; auto operator()(T1\u0026amp;\u0026amp; param1, T2\u0026amp;\u0026amp; param2) -\u0026gt; decltype(std::forward\u0026lt;T1\u0026gt;(param1) + std::forward\u0026lt;T2\u0026gt;(param2)) { return std::forward\u0026lt;T1\u0026gt;(param1) + std::forward\u0026lt;T2\u0026gt;(param2); } }; auto setSoundB = std::bind(setAlarm, std::bind(genericAdder(), std::bind(steady_clock::now), hours(1)), // std::literals is in C++14  _1, seconds(30));   Moreover, if we have another overloaded function for setAlarm, which takes a new parameter specifying the alarm volume:\n1 2  enum class Volum {Normal, Loud, VeryLoud}; void setAlarm(Time t, Sound s, Duration d, Volume v);   The lambda above continues to work, because overload resolution chooses the three-argument version of setAlarm.\nHowever, the std::bind version fails to compile now, because compilers have no way to determine which of the two setAlarm functions they should pass to std::bind - by the function name alone it is ambiguous.\nTo specify the exactly which one we want, we need to cast setAlarm to the proper function pointer type:\n1 2 3 4 5 6 7 8  using SetAlarm3ParamType = void(*)(Time t, Sound s, Duration d); auto setSoundB = std::bind(static_cast\u0026lt;SetAlarm3ParamType\u0026gt;(setAlarm), std::bind(std::plus\u0026lt;\u0026gt;(), std::bind(steady_clock::now()), 1h), _1, 30s);   More efficient The cast above introduces another side effect:\n std::bind passes a function pointer to setAlarm, which means inside the function call operator for setSoundB (i.e., the function call operator () for the bind object), the call to setAlarm takes place through a function pointer, which generally can\u0026rsquo;t be fully inlined inside the function call operator for setSoundL (i.e., the function call operator of the lambda\u0026rsquo;s closure class), the call to setAlarm is a normal function invocation, which can be inlined by compilers  This means using lambdas might generate faster code than using std::bind.\nMore expressive 1 2 3 4 5 6 7 8 9 10  auto betweenL = [lowVal, highVal] (const auto\u0026amp; val) { return lowVal \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= highVal; }; using namespace std::placeholders; auto betweenB = std::bind(std::logical_and\u0026lt;\u0026gt;(), std::bind(std::less_equal\u0026lt;\u0026gt;(), lowVal, _1), std::bind(std::less_equal\u0026lt;\u0026gt;(), _1, highVal));   Moreover, the placeholders (e.g., _1, _2, etc.) are opaque in that it doesn\u0026rsquo;t specify how parameters are passed and stored in the bind object, by value or by reference. We have to memorize that it\u0026rsquo;s stored by value. Lambda, however, specifies capture mode very clearly.\nEdge cases In C++14, there\u0026rsquo;s no reasonable use case for std::bind. In C++11, two constrained situations my be useful:\n  Move capture, as item 32 explains.\n  Polymorphic function objects: this takes use of bind object\u0026rsquo;s perfect forwarding ability\n1 2 3 4 5 6 7 8 9 10 11  class PolyWidget { public: template\u0026lt;typename T\u0026gt; void operator()(const T\u0026amp; param) const; ... }; PolyWidget pw; auto boundPW = std::bind(pw, _1); boundPW(1942); // pass int to PolyWidget::operator() boundPW(nullptr); // pass nullptr to PolyWidget::operator() boundPW(\u0026#34;RoseGun\u0026#34;); // pass string literal to PolyWidget::operator()   In C++14, simply do this combining lambda with auto:\n1  auto boundPW = [pw](const auto\u0026amp; param) { pw(param); };    ","description":"","id":69,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-34 Prefer Lambdas to std::bind","uri":"https://nianze.ml/en/notes/2018/08/prefer-lambdas-to-stdbind/"},{"content":"C++14 introduces generic lambdas, which use auto in their parameter specifications.\n1  auto f = [](auto x){ return normalize(x); };   If we want to perfect-fowrad a parameter x to normalize, we make two changes:\n use universal reference auto\u0026amp;\u0026amp; apply decltype on parameter to specify the correct type for type argument of std::forward  1  auto f = [](auto\u0026amp;\u0026amp; x){ return normalize(std::forward\u0026lt;decltype(x)\u0026gt;(x)); };   As a fact of decltype(x):\n if x is bound to an lvalue, it will yield an lvalue refernece; if x is bound to an rvalue, it will yield an rvalue reference  Actually, the result of decltype(x) doesn\u0026rsquo;t follow the convention of std::forward, where it dictates that the type argument be an lvalue reference to indicate an lvalue and a non-reference to indicate an rvalue.\nThanks to reference-collapsing rule, even though rvalue convention is broken here, the collapsing result is still the same. Say the T in the implementation of std::forward below is instantiated as Widget\u0026amp;\u0026amp;, an rvalue reference type:\n1 2 3 4  template\u0026lt;typename T\u0026gt; // in namespace T\u0026amp;\u0026amp; forward(remove_reference_t\u0026lt;T\u0026gt;\u0026amp; param) // std { return static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(param); }   and we get this before reference collapsing:\n1 2 3 4  Widget\u0026amp;\u0026amp; \u0026amp;\u0026amp; forward(Widget\u0026amp; param) // instantiation of { // std::forward when  static_cast\u0026lt;Widget\u0026amp;\u0026amp; \u0026amp;\u0026amp;\u0026gt;(param); // T is Widget\u0026amp;\u0026amp; }   After reference collapsing:\n1 2 3 4  Widget\u0026amp;\u0026amp; forward(Widget\u0026amp; param) // instantiation of { // std::forward when  static_cast\u0026lt;Widget\u0026amp;\u0026amp;\u0026gt;(param); // T is Widget\u0026amp;\u0026amp; }   This is exactly what we expect.\nVariadic parameters For more than a single parameter, using following format:\n1 2  auto f = [](auto\u0026amp;\u0026amp;... xs) { return normalize(std::forward\u0026lt;decltype(xs)\u0026gt;(xs)...); }   ","description":"","id":70,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-33 Use decltype on auto\u0026\u0026 parameters to std::forward them","uri":"https://nianze.ml/en/notes/2018/08/use-decltype-on-auto-parameters-to-stdforward-them/"},{"content":"Use init capture to move objects into closures in C++14; emulate init capture via hand-written classes or std::bind in C++11.\nIn C++14 One nice improvement in C++14, compared with C++11, is that it supports int capture (a.k.a, generalized lambda capture), which makes it possible for us to specify:\n the name of a data memeber in the closure class generated from the lambda an expression initializing that data member  For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Widget { public: ... bool isValidated() const; bool isProcessed() const; bool isArchived() const; private: ... }; auto pw = std::make_unique\u0026lt;Widget\u0026gt;(); ... auto func = [pw = std::move(pw)] // init data mbr in closure with std::move(pw)  { return pw-\u0026gt;isValidated() \u0026amp;\u0026amp; pw-\u0026gt;isArchived(); }   One thing to note in init capture: the left side of \u0026ldquo;=\u0026rdquo; is the name of the data member in the closure we\u0026rsquo;re specifying, which is in the closure class scope; the right side is the initializing expresion, which is the same scope as where the lambda is being defined. The code in the body of the lambda is in the scope of the closure class, so uses of pw refer to the closure class data member.\nIn C++11 In C++11, it\u0026rsquo;s not possible to capture the result of an expression. We can still emulate the behaivor by either manually write a class:\n1 2 3 4 5 6 7 8 9 10 11 12  class IsValAndArch { public: using DataType = std::unique_ptr\u0026lt;Widget\u0026gt;; explicit IsValAndArch(DataType\u0026amp;\u0026amp; ptr) : pw(std::move(ptr)) {} bool operator()() const { return pw-\u0026gt;isValidated() \u0026amp;\u0026amp; pw-\u0026gt;isArchived(); } private: DataType pw; } auto func = IsValAndArch(std::make_unique\u0026lt;Widget\u0026gt;());   or use std::bind:\n1 2 3 4 5  auto func = std::bind( [](const std::unique_ptr\u0026lt;Widget\u0026gt;\u0026amp; pw) { return pw-\u0026gt;isValidated() \u0026amp;\u0026amp; pw-\u0026gt;isArchived(); }, std::make_unique\u0026lt;Widget\u0026gt;() );   Some facts about std::bind above:\n std::bind produces function objects (called bind object), which contains copies of all the arguments passed to std::bind following this rule: copy constructing the lvalue arguemnt, and move construct rvalue argument. by default, the operator() member function inside the closure class generated from a lambda is const; as a contrast, the move-constructed copy of Widget inside bind object is not const, so we declare reference-to-const as the lambda\u0026rsquo;s parameter to prevent that copy of Widget from being modified inside the lambda1 the lifetime of the bind is the same as that of the closure, so it\u0026rsquo;s possible to treat objects in the bind object as if they were in the closure.   We can declare lambda as mutable if we want to modify the copy inside the lambda: [](std::unique_ptr\u0026lt;Widget\u0026gt;\u0026amp; pw) mutable {...}\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":71,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-32 Use Init Capture to Move Objects Into Closures","uri":"https://nianze.ml/en/notes/2018/08/use-init-capture-to-move-objects-into-closures/"},{"content":"Default by-reference capture can lead to dangling references; default by-value capture is susceptible to dangling pointers, while misleadingly susggests the lambdas are self-contained.\nDefault by-reference capture If the lifetime of a closure created from a lambda exceeds the lifetime of the local variable or parameter captured by-reference, the reference in the closure will dangle:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  using FilterContainer = std::vector\u0026lt;std::function\u0026lt;bool(int)\u0026gt;\u0026gt;; FilterContainer filters; void addDivisorFilter() { auto calc1 = computeSomeValue1(); auto calc2 = computeSomeValue2(); auto diviser = coputeDiviser(calc1, calc2); filters.emplace_back( [\u0026amp;](int value) { return value % divisor = 0; } // ref to divisor will dangle  ); }   Long-term, it\u0026rsquo;s better software engineering to explicitly list the local variables and parameters that a lambda depends on.\nDefault by-value capture Capture by value will solve the dangling problem in above example, but it can\u0026rsquo;t guarantee the safety if we capture a pointer and that pointer is deleted outside the lambda, which causes our copied pointer to dangle. This usually happens where this, a raw pointer, implicitly shows up, for example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Widget { public: ... void addFilter() const; private: int divisor; }; void Widget::addFilter() const { filters.emplace_back( [=](int value) { return vlaue % diviser == 0; } ); }   Captures apply only to non-static local variables (including parameters) visible in the scope where the lambda is created. Since diviser above is a data member of the Widget class, instead of a local variable, what compilers see is as if it had been written as follows:\n1 2 3 4 5 6 7 8  void Widget::addFilter() const { auto currentObjectPtr = this; filters.emplace_back( [currentObjectPtr](int value) { return value % currentObjectPtr-\u0026gt;divisor == 0; } ); }   and now consider this:\n1 2 3 4 5 6  void doSomeWork() { auto pw = std::make)unique\u0026lt;Widget\u0026gt;(); pw-\u0026gt;addFilter(); ... } // destroy Widget; filters now holds dangling pointer   In this code above, a filter is created containing a copy of a this pointer to the newly created Widget, and then we add this filter to filters. When doSomeWork finishes, the Widget object is destroyed by std::unique_ptr, and filters contains an entry with a dangling pointer.\nTo solve the problem, just make a local copy of the data member we want to capture and then capture the copy:\n1 2 3 4 5 6 7 8  void Widget::addFilter() const { auto currentObjectPtr = divisor; // copy data member  filters.emplace_back( [divisorCopy](int value) { return value % divisor == 0; } ); }   In C++14, a better way to capture a data member is to use generalized lambda capture (Item 32):\n1 2 3 4 5 6 7  void Widget::addFilter() const { filters.emplace_back( // C++14  [divisor = divisor](int value) // copy divisor to closure  { return value % divisor == 0; } // use the copy  ); }   ","description":"","id":72,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-31 Avoid Default Capture Modes","uri":"https://nianze.ml/en/notes/2018/08/avoid-default-capture-modes/"},{"content":"Perfect forwarding fails when template type deduction fails or when it deduces the wrong type.\nGenerally, forwarding means passing parameters that are references so that we can work with the originally-passed-in objects in another function, while perfect forwarding means we will use universal references to keep track of salient characteristics such as lvalue-ness/rvalue-ness, const-ness, volatile-ness, etc.\nThe definition of failure is: given a target function f, and a forwarding function fwd, perfect forwarding fails if calling f with a particular argument does one thing, but calling fwd with the same argument does something difference:\n1 2 3 4 5 6 7 8  f( expression ); fwd( expression ); template\u0026lt;typename T\u0026gt; void fwd(T\u0026amp;\u0026amp; param) // accept any argument { f(std::forward\u0026lt;T\u0026gt;(param)); }   Following kinds of arguments will lead to perfect forwarding failure:\n braced initializers: passing a braced initializer to a function template parameter that’s not declared to be a std::initializer_list is decreed to be a “non-deduced context,” as the Standard puts it null pointers expressed as 0 or NULL: refer to the explanation in EMCpp item 8 declaration-only integral const static data members: since compilers perform const propagation on such members' values, there\u0026rsquo;s no memory allocation procedure for them, no address associated with them, and thus no pointers/references, ending up with a linking error. template and overloaded function names: f\u0026rsquo;s declaration lets compilers figure out the required vertion of overload/template instantiation to be passed, but it\u0026rsquo;s impossible for compilers to determine which version should be passed to fwd bitfields: \u0026ldquo;A non-const reference shall not be bound to a bit-field,\u0026rdquo; as C++ standard condemns ","description":"","id":73,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-30 Failure Cases in Perfect Forwarding","uri":"https://nianze.ml/en/notes/2018/08/failure-cases-in-perfect-forwarding/"},{"content":"There are several scenarios in which C++11\u0026rsquo;s move semantics do us no good:\n No move operations: the object to be moved from fails to offer move operations. The move request thus becomes a copy request Move not faster: the object to be moved from has move operations that are no faster than its copy operations1 Move not usable: the context in which the moving would take place requires a move operation that emits no exceptions, but that operation isn\u0026rsquo;t declared noexcept Source object is lvalue: with very few exceptions (e.g., item 25), only rvlaues may be used as the source of a move operation   For example, std::vector, conceptually, holds only a pointer to the heap memory storing the contents of the container, so it is possible to move the contents of an entire container in constant time; however, for std::array, the data is stored directly in the std::array object, so the move operation runs in linear time. Similar analysis applies to std::string when the small string optimization (SSO) occcurs.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":74,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-29 Assume Move Operations Are Not Present Not Cheap, and Not Used","uri":"https://nianze.ml/en/notes/2018/08/assume-move-operations-are-not-present-not-cheap-not-used/"},{"content":"Reference collapsing occurs in four contexts: template instantiation, auto type generation, creation and use of typedefs and alias declarations, and decltype.\nThe core concept in this item: A universal reference isn\u0026rsquo;t a new kind of reference, it\u0026rsquo;s actually an rvalue reference in a context where two conditions are satisfied:\n Type deduction distinguishes lvalues from rvalues. (Lvalues of type T are deduced to have type T\u0026amp;, while rvalues of type T yield T) Reference collapsing occurs.  Specifically, if a reference to a reference is generated by compilers arises in one of the four context mentioned above, the references collapse to a single reference according this rule:\n if either of the original references is an lvalue reference, the result is an lvalue reference otherwise, it\u0026rsquo;s an rvalue reference  Template instantiation Reference collapsing is a key part to make std::forward work. For example, given an possible implementation of std::forward and a function f:\n1 2 3 4 5 6 7 8 9 10 11 12  template\u0026lt;typename T\u0026gt; T\u0026amp;\u0026amp; forward(typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp; param) { return static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(param); } template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; Param) { ... someFunc(std::forward\u0026lt;T\u0026gt;(fParam)); }   If we pass an lvalue of type Widget to function f, T will then be deduced as Widget\u0026amp;, and we get:\n1 2 3 4  Widget\u0026amp; \u0026amp;\u0026amp; forward(typename remove_reference\u0026lt;Widget\u0026amp;\u0026gt;::type\u0026amp; param) { return static_cast\u0026lt;Widget\u0026amp; \u0026amp;\u0026amp;\u0026gt;(param); }   According to reference collapsing rule, we get:\n1 2 3 4  Widget\u0026amp; forward(Widget\u0026amp; param) { return static_cast\u0026lt;Widget\u0026amp;\u0026gt;(param); }   If we pass to f an rvalue of type Widget, T will then be Widget, and we get:\n1 2 3 4  Widget \u0026amp;\u0026amp; forward(typename remove_reference\u0026lt;Widget\u0026gt;::type\u0026amp; param) { return static_cast\u0026lt;Widget \u0026amp;\u0026amp;\u0026gt;(param); }   According to reference collapsing rule, we get:\n1 2 3 4  Widget\u0026amp;\u0026amp; forward(Widget\u0026amp; param) { return static_cast\u0026lt;Widget\u0026amp;\u0026amp;\u0026gt;(param); }   Overall, an rvalue arguement Widget passed to f will be bound to the lvalue parameter fParam firstly, be casted into an rvalue, and then be forwarded to someFunc.\nauto type generation Type deduction for auto variables is essentially the same as deduction for templates.\n1 2 3 4 5 6  Widget widgetFactory(); Widget w; // w is lvalue  auto\u0026amp;\u0026amp; w1 = w; // type deduces as Widget\u0026amp;, so Widget\u0026amp; \u0026amp;\u0026amp; w1 = w -collapsing-\u0026gt; Wiget\u0026amp; w1 = w auto\u0026amp;\u0026amp; w2 = widgetFactory(); // type deduces as Widget, so Widget\u0026amp;\u0026amp; w2 = widgetFactory();   typedefs and alias declarations 1 2 3 4 5 6  template\u0026lt;typename T\u0026gt; class Widget { public: typedefs T\u0026amp;\u0026amp; RvalueRefToT; ... }   Given Widget\u0026lt;int\u0026amp;\u0026gt; w;, we get typedef int\u0026amp; \u0026amp;\u0026amp; RvalueRefToT;, which then collapses into typedef int\u0026amp; RvalueRefToT;. Interestingly, the name turns out to be misleading: the typedef actually refers to an lvalue reference to int now if instantiated with an lvalue reference type int\u0026amp;.\ndecltype Same logic as above to analyze.\n","description":"","id":75,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-28 Understand Reference Collapsing","uri":"https://nianze.ml/en/notes/2018/08/understand-reference-collapsing/"},{"content":"Universal reference parameters often have efficiency advantages, but they typically have usability disadvantages.\nAbandon overloading This solution works for overloaded logAndAdd example in Item 26, where we break the overloaded function into two: logAndAddName and logAndAddIdx. However, this will not work for Person constructor - the constructor names are fixed by the language.\nPass by const T\u0026amp; This is the original function void logAndAdd(const std::string\u0026amp; name) we see in Item 26. Not efficient in some cases, but works as expected.\nPass by value According to the advice in Item 41, we may consider passing objects by value when we know we\u0026rsquo;ll copy them. Thus, the Person example may get revised like this:\n1 2 3 4 5 6 7 8 9 10  class Person { public: explicit Person(std::string n) : name(std::move(n)) {} explicit Person(int idx) : name(nameFromIdx(idx)) {} ... private: std::string name; };   With this design, int-like arguments get passed to int overload, and arguments of type std::string (and anything from which std::string could be created, e.g., literals) get passed to the std::string overload.\nUse Tag dispatch Add another \u0026ldquo;tag\u0026rdquo; parameter to help compiler differentiate the overloading cases as we want:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  template\u0026lt;typename T\u0026gt; void logAndAdd(T\u0026amp;\u0026amp; name) { logAndAddImpl( std::forward\u0026lt;T\u0026gt;(name), std::is_integral\u0026lt;typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026gt;() ); } template\u0026lt;typename T\u0026gt; void logAndAddImpl(T\u0026amp;\u0026amp; name, std::false_type) { auto now = std::chrono::system_clock::now(); log(now, \u0026#34;logAndAdd\u0026#34;); names.emplace(std::forward\u0026lt;T\u0026gt;(name)); } std::string nameFromIdx(int idx); template\u0026lt;typename T\u0026gt; void logAndAddImpl(T\u0026amp;\u0026amp; name, std::true_type) { logAndAdd(nameFromIdx(idx)); }   Conceptually, true and false are runtime values, and what we need here for the tag parameter should be compil-time types that corresponds to true and false, which in the Standard Library are called std::true_type and std::false_type. This compile-time variables serve no purpose at runtime, so some compilers who\u0026rsquo;s smart enough may recognize these tag parameters and optimize them out of the program\u0026rsquo;s execution image.\nTag dispatch is a standard building block of template metaprogramming to let the tag determine which overload gets called, so that overloading on universal references may work as expect.\nUse enable_if to constrain templates that take universal references Tag dispatch solves some of the problems related with templates taking universal references, but not all of them. The perfect-forwarding constructor for the Person class, for example, remains problematic: even if we write only one constructor and apply tag dispactch technique to it, some constructor calls (copy from const vs non-const lvalues) may sometimes be handled by compiler-generated functions (e.g., copy and move constructors) that bypass the tag dispatch system.\nThus, we want to constrain on when the function template is permitted to be employed. By default, all templates are enabled, but a template using std::enable_if is enabled only if the condition specified by std::enable_if is satisfied.\nIn the case of Person\u0026rsquo;s perfect forwarding constructor, we want to enable its instantiation only if the type being passed isn\u0026rsquo;t Person, so that the class\u0026rsquo;s copy or move constructor my handle the calls where a Person object gets passed in. Specifically, when checking the type of the argument being passed, we want to ignore its referenceness, constness, and volatileness using std::decay\u0026lt;T\u0026gt;:\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Person { public: template\u0026lt; typename T, typename = typename std::enable_if\u0026lt; !std::is_same\u0026lt;Person, typename std::decay\u0026lt;T\u0026gt;::type \u0026gt;::value \u0026gt;::type \u0026gt; explicit Person(T\u0026amp;\u0026amp; n); ... };   Moreover, if we want to make sure the derived class work properly, the conditions for std::enble_if get more restricted: we want to enable it for any argument type other than Person or a type derived from Person. To determian whether one type is derived from another, we can use std::is_base_of\u0026lt;T1, T2\u0026gt;:\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Person { public: template\u0026lt; typename T, typename = typename std::enable_if\u0026lt; !std::is_base_of\u0026lt;Person, typename std::decay\u0026lt;T\u0026gt;::type \u0026gt;::value \u0026gt;::type \u0026gt; explicit Person(T\u0026amp;\u0026amp; n); ... };   In C++14, by employing alias templates, we can save some typing for typename and ::type:\n1 2 3 4 5 6 7 8 9 10 11  class Person { public; template\u0026lt; typename T, typename = std::enbale_if_t\u0026lt; !std::is_base_of\u0026lt;Person, std::decay_t\u0026lt;T\u0026gt;\u0026gt;::value \u0026gt; \u0026gt; explicit Person(T\u0026amp;\u0026amp; n); ... };   Finally, to get our perfect forwarding constructor to work with the int overload, we have to add another constrain in std::enbale_if to check the integral arguments type:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Person { public; template\u0026lt; typename T, typename = std::enbale_if_t\u0026lt; !std::is_base_of\u0026lt;Person, std::decay_t\u0026lt;T\u0026gt;\u0026gt;::value \u0026amp;\u0026amp; !std::is_integral\u0026lt;std::remove_reference_t\u0026lt;T\u0026gt;\u0026gt;::value \u0026gt; \u0026gt; explicit Person(T\u0026amp;\u0026amp; n) // ctor for std::strings and args convertible to std::strings  : name(std::forward\u0026lt;T\u0026gt;(n)) { ... } explicit Person(int idx) // ctor for integral args  : name(nameFromIdx(idx)) { ... } ... // copy and move ctors, etc. private: std::string name; };   To make even more effective code, considering some kinds of arguments can\u0026rsquo;t be perfect-forwarded, as well as the fact that forwarding functions tend to create lengthy error messages, which is debug-unfriendly, we can use static_assert, accompanied with std::is_constructible, to perform a compile-time test to determine whether an object of one type can be constructed from an object (or a set of objects) of a different type (or set of types):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Person { public; template\u0026lt; typename T, typename = std::enbale_if_t\u0026lt; !std::is_base_of\u0026lt;Person, std::decay_t\u0026lt;T\u0026gt;\u0026gt;::value \u0026amp;\u0026amp; !std::is_integral\u0026lt;std::remove_reference_t\u0026lt;T\u0026gt;\u0026gt;::value \u0026gt; \u0026gt; explicit Person(T\u0026amp;\u0026amp; n) // ctor for std::strings and args convertible to std::strings  : name(std::forward\u0026lt;T\u0026gt;(n)) { static_assert( std::is_constructible\u0026lt;std::string, T\u0026gt;::value, \u0026#34;Parameter n can\u0026#39;t be used to construct a std::string\u0026#34; ); ... // the usual ctor work goes here  } ... };   ","description":"","id":76,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-27 Alternatives to Overloading on Universal References","uri":"https://nianze.ml/en/notes/2018/08/alternatives-to-overloading-on-universal-references/"},{"content":"Overloading on universal references almost always leads to the universal reference overload being called more frequently than expected.\nWhy universal references? We want to introduce universal references because we can eliminate some inefficiencies via it. For example,\n1 2 3 4 5 6 7  std::multiset\u0026lt;std::string\u0026gt; names; void logAndAdd(const std::string\u0026amp; name) { auto now = std::chrono::system_clock::now(); log(now, \u0026#34;logAndAdd\u0026#34;); names.emplace(name); // add name to global data structure. See EMCpp Item 42 for info on emplace }   1 2 3 4  std::string petName(\u0026#34;Amy\u0026#34;); logAndAdd(petName); // passing lvalue logAndAdd(std::string(\u0026#34;Ben\u0026#34;)); // passing rvalue logAndAdd(\u0026#34;Candice\u0026#34;); // passing string literal    petName is lvalue, so name is bound to it, and then copied into names. Since an lvalue was passed into logAndAdd, the final copy operation can not be avoided. the parameter for the second call is rvalue, where a temporary of type std::string is explicitly created and gets bound to name, and then name get copied into names. In this call, we might optimize that final copy operation with a move operation since we are dealing with an rvalue similar procedure as the second call but the std::string is implicitly created from string literal Candice. We might optimize the final copy operation by creating the std::string object directly inside the std::multiset if emplace could use the string literal directly as argument, so there\u0026rsquo;s not even a move operation.  To achieve such optimization, we find universal reference, accompany with std::forward:\n1 2 3 4 5 6 7  template\u0026lt;typename T\u0026gt; void logAndAdd(T\u0026amp;\u0026amp; name) { auto now = std::chrono::system_clock::now(); log(now, \u0026#34;logAndAdd\u0026#34;); names.emplace(std::forward\u0026lt;T\u0026gt;(name)); }   What trouble universal references introduces? Functions taking universal references are the greediest functions in C++, so the usually overload more argument types than the developer generally expects. Suppose there\u0026rsquo;s another function overloading for the type of int:\n1 2 3 4 5 6 7  std::string nameFromIdx(int idx); // return name corresponding to idx void logAndAdd(int idx) { auto now = std::chrono::system_clock::now(); log(now, \u0026#34;logAndAdd\u0026#34;); names.emplace(nameFromIdx(idx)); }   1 2 3 4 5  logAndAdd(22); // calls int overload logAndAdd(\u0026#34;David\u0026#34;); // calls T\u0026amp;\u0026amp; overload short nameIdx; ... logAndAdd(nameIdx); // error!   We generally assume the last call will invoke the int overload, but instead it will invoke the T\u0026amp;\u0026amp; one, since the universal reference overload version exactly matches the short argument by deduce T to be short\u0026amp;, while int version has to match short with a promotion. As a result, the exact match beats a match with a promotion. However, within the T\u0026amp;\u0026amp; overload, the parameter name with type short\u0026amp; first get passed into std::forward, which will not get casted into a rvalue since name is initialized with an lvalue (refer to EMCpp item 24), and then get passed into emplace member function on names, which finally forwards it to the std::string constructor, and we get an error here because no constructor for std::string will take a short.\nMore problematic: Perfect-forwarding consturctors Perfect-forwarding constructors are typically better matches than copy constructors for non-const lvalues, and they can hijack derived class calls to base class copy and move constructors, which makes them problematic. For example:\n1 2 3 4 5 6 7 8 9 10 11 12  class Person { public: template\u0026lt;typename T\u0026gt; explicit Person(T\u0026amp;\u0026amp; n) : name(std::forward\u0026lt;T\u0026gt;(n)) {} // perfect forwarding ctor;  explicit Person(int idx) : name(nameFromIdx(idx)) {} // int ctor  ... private: std::string name; }   Remember in EMCpp item 17 we mensioned that, under appropriate conditions, the compiler will generate copy and move constructors for us, even if the class contains a templatized constructor that could be instantiated to produce the signature of the copy or move constructor. In that case, we get following two compiler-generated member functions:\n1 2  Person(const Person\u0026amp; rhs); // copy ctor generated by compiler Person(Person\u0026amp;\u0026amp; rhs); // move ctor generated by compiler   And now comes the problem: these two member functions will easily get shadowed by the universal reference constructor:\n1 2 3 4 5  Person p1(\u0026#34;Edward\u0026#34;); auto cloneOfP1(p1); // create new Person from p;  // T\u0026amp;\u0026amp; ctor get invoked: T is deduces as \u0026#34;Person\u0026amp;\u0026#34;, better than copy ctor\u0026#39;s type \u0026#34;const Person\u0026amp;\u0026#34; const Person p2(\u0026#34;Fernando\u0026#34;); auto cloneOfP2(p2); // fine; copy ctor get invoked.   Moreover, the inheritance makes the mess even worse:\n1 2 3 4 5 6 7 8 9  class SpecialPerson: public Person { public: SpecialPerson(const SpecialPerson\u0026amp; rhs) : Person(rhs) // calls base class forwarding ctor  { ... } SpecialPerson(SpecialPerson\u0026amp;\u0026amp; rhs) : Person(std::move(rhs)) // calls base class forwarding ctor  { ... } }   Here, the derived class will call the perfect forwarding constructor for their copy and move constructors, because they are using arguments of type SpecialPerson to pass to their base class, and base class\u0026rsquo;s forwarding constructor will happily instantiate an exact match for this call. Since there\u0026rsquo;s no std::string constructor taking a SpecialPerson, the code won\u0026rsquo;t compile.\nConclusion Overloading on universal reference is something we should avoid if possible. However, if we do want a function that forwards most argument types, while still support special treatment for some special types, we can find some alternatives to achieve this goal in EMCpp item 27.\n","description":"","id":77,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-26 Avoid Overloading on Universal References","uri":"https://nianze.ml/en/notes/2018/08/avoid-overloading-on-universal-references/"},{"content":"But don\u0026rsquo;t apply std::move or std::forward to local objects if they would otherwise be eligible for the return value optimization.\nNormal cases When forwarding them to other functions, rvalue references, which is always bound to rvalues, should be unconditionally cast to rvalues (via std::move), while universal references, which is sometimes bound be rvalues, should be conditionally cast to rvalues (via std::forward):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Widget { public: Widget(Widget\u0026amp;\u0026amp; rhs) // rhs is rvalue reference  : name(std::move(rhs.name)), p(std::move(rhs.p)) {...} template\u0026lt;typename T\u0026gt; void setName(T\u0026amp;\u0026amp; newName) // newName is rvalue reference  { name = std::forward\u0026lt;T\u0026gt;(newName); } ... private: std::string name; std::shared_ptr\u0026lt;SomeDataStructure\u0026gt; p; };   What if You may wonder, what will happen if we exchange std::forward ans std::move:\n  applying std::forward on rvalue references can exhibit the proper behavior, but the source code is wordy, error-prone1, and unidiomatic:\n1 2 3 4  Widget::Widget(Widget\u0026amp;\u0026amp; rhs) : name(std::forward\u0026lt;std::string\u0026gt;(rhs.name)), p(std::forward\u0026lt;std::shared_ptr\u0026lt;SomeDataStructure\u0026gt;\u0026gt;(rhs.p)) {...}     using std::move on universal refenreces can have the effect of unexpectedly modifying lvalues (e.g., local variables):\n1 2 3 4 5 6 7 8 9  template\u0026lt;typename T\u0026gt; void Widget::setName(T\u0026amp;\u0026amp; newName) { name = std::move(newName); } // compiles, but is bad!  std::string getWidgetName(); // factory function Widget w; auto n = getWidgetName(); // n is local variable w.setName(n); // moves n into w ... // n\u0026#39;s value now unkown!     Another alternative is to replace the template taking a universal reference with a pair of functions overloaded on lvalue references and rvalue references:\n1 2 3 4 5 6 7 8  class Widget { public: void setName(const std::string\u0026amp; newName) // set from const lvalue  { name = newName; } void setName(std::string\u0026amp;\u0026amp; newName) // set from rvalue  { name = std::move(newName); } ... };   The cost we pay for this replacement is:\n  More source code to write and maintain (two functions instead of a single template)\n  Less efficient in some cases such as this2:\n1  w.setName(\u0026#34;John Smith\u0026#34;);     Poor scalability of the design if more parameters come (each of which can be an lvalue or rvalue):\n1 2  tempalte\u0026lt;class T, class... Args\u0026gt; shared_ptr\u0026lt;T\u0026gt; make_shared(Args\u0026amp;\u0026amp;... args); // can\u0026#39;t overload on lvalues and rvalues on args. universal reference is used and std::forward is applyied     Other usage Moreove, sometimes we want to apply std::move or std::forward to only the final use of the reference when an rvalue reference or a universal reference will be used more than once in a single function:\n1 2 3 4 5 6 7  template\u0026lt;typename T\u0026gt; void setSignText(T\u0026amp;\u0026amp; text) // text is a universal reference { sign.setText(text); // use text, but do not modify it  auto now = std::chrono::system_clock::now(); signHistory.add(now, std::forward\u0026lt;T\u0026gt;(text)); // conditionally cast to rvalue }   The same logic applies to std::move, except that in rare cases, we want to call std::move_if_noexcept instead of std::move (refer to EMCpp item 14).\nIf a function returns be value, and the returning object is bound to an rvalue refernece or a universal reference, we also want to apply std::move or std::forward to support potential move construction and get more efficient:\n1 2 3 4 5 6 7 8 9 10 11 12  Matric operator+(Matric\u0026amp;\u0026amp; lhs, const Matrix\u0026amp; rhs) { lhs += rhs; return std::move(lhs); // move lhs into return value } template\u0026lt;typename T\u0026gt; Fraction reduceAndCopy(T\u0026amp;\u0026amp; frac) { frac.reduce(); return std::forward\u0026lt;T\u0026gt;(frac); // move rvalue into return value; copy lvalue }   When not to According to Standardization Committee, there\u0026rsquo;s a kind of optimizatoin called return value optimization (RVO):\n the “copying” version of makeWidget can avoid the need to copy the local variable w by constructing it in the memory alloted for the function’s return value\n Due to this optimization, we should not use std::move on a local object being returnd from a function that\u0026rsquo;s returning by value so that we won\u0026rsquo;t precluding the RVO that compilers will do for the return value.\n The type we pass to std::forward should be a non-reference, according to the convention for encoding that the argument being passed is an rvalue (see EMCpp Item 28).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n With the universal reference version, there\u0026rsquo;s only one call to std::string assignment operator for w.name, since the string literal would be passed to this function as a const char* pointer; the overloaded versions entail execution of one std::string constructor (to create a temporary), one std::string move assignment operator (to move newName into w.name), and one std::string destructor (to destroy the temporary), which is almost certainly more expensive.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":78,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-25 Use std::move on Rvalue References, std::forward on Universal References","uri":"https://nianze.ml/en/notes/2018/08/use-stdmove-on-rvalue-references-stdforward-on-universal-references/"},{"content":"If a function template parameter has type T\u0026amp;\u0026amp; for a deduced type T, or if an object is declared using auto\u0026amp;\u0026amp;, the parameter or object is a universal reference.\nT\u0026amp;\u0026amp; has two different meanings: one is for rvalue reference, another is for universal reference. Universal references are called \u0026ldquo;universal\u0026rdquo;, because they can bind to virtually anything:\n bind to rvalues (behave like rvalue references T\u0026amp;\u0026amp;) bind to lvalues (behave like lvalue references T\u0026amp;) bind to objects that is const or non-const, volatile or non-volatile, or both const and volatile  Universal refenrences must company with a special form (i.e., the form of \u0026ldquo;T\u0026amp;\u0026amp;\u0026quot;) after the occurrence of type deduction, and typically arise in two contexts: the most common case is function template parameters, while another context is auto declarations:\n1 2 3 4 5 6 7  template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); // param is a universal reference auto\u0026amp;\u0026amp; var2 = var1; // var2 is a universal reference  Widget w; f(w); // lvalue passed to f; param\u0026#39;s type is Widget\u0026amp;, act as an lvalue ref. f(std::move(w)); // rvalue passed to f; param\u0026#39;s type is Widget\u0026amp;\u0026amp;, act as an rvalue ref.   If there\u0026rsquo;s no type deduction, or if the type deduction form is incorrect (not in form of \u0026ldquo;T\u0026amp;\u0026amp;\u0026quot;), then there\u0026rsquo;s no universal references:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  void f(Widget\u0026amp;\u0026amp; param); // no type deduction; param is an rvalue reference Widget\u0026amp;\u0026amp; var1 = Widget(); // no type deduction; param is an rvalue reference  template\u0026lt;typename T\u0026gt; void f(std::vector\u0026lt;T\u0026gt;\u0026amp;\u0026amp; param); // not in precise form of T\u0026amp;\u0026amp;, param here is an rvalue ref.  template\u0026lt;typename T\u0026gt; void f(const T\u0026amp;\u0026amp; param); // not in precise form of T\u0026amp;\u0026amp;, param here is an rvalue ref.  template\u0026lt;typename T, class Allocator = allocator\u0026lt;T\u0026gt;\u0026gt; // from C++ standards class vector { public: void push_back(T\u0026amp;\u0026amp; x); // no type deduction here; x is rvalue reference;  ... // a particular vector instantiation must have occurred prior to any call to this function } template\u0026lt;typename T, class Allocator = allocator\u0026lt;T\u0026gt;\u0026gt; // from C++ standards class vector { public: template\u0026lt;class... Args\u0026gt; void emplace_back(Args\u0026amp;\u0026amp;... args); // universal reference! because:  ... // 1. in correct form of \u0026#34;T\u0026amp;\u0026amp;\u0026#34;; 2. type parameter Args must be deduced each time emplace_back is called } // this function can time pretty much any function execution. more information is in EMCpp item 30 auto timeFuncInvocation = // C++14  [] (auto\u0026amp;\u0026amp; func, auto\u0026amp;\u0026amp;... param) // func is a universal reference that can be bound to any callable object, lvaue or rvalue  { // param is zero or more universal references (i.e., a universal reference parameter pack) that can be bound to any number of objects of arbitrary types  // start timer;  std::forward\u0026lt;decltype(func)\u0026gt;(func)( // invoke func on params  std::forward\u0026lt;decltype(params)\u0026gt;(params)... ); // stop timer and record elapsed time;  };   In fact, the foundation of univeral references is a lie (an \u0026ldquo;abstraction\u0026rdquo;), with underlying truth being known as reference collapsing discussed in EMCpp Item 28. Distinguishing between rvalue references and universal references will help us read source code more accurately.\n","description":"","id":79,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-24 Distinguish Universal References From Rvalue References","uri":"https://nianze.ml/en/notes/2018/08/distinguish-universal-references-from-rvalue-references/"},{"content":"std::move performs an unconditional cast to an rvalue, while std::forward casts its argument to an rvalue only if that argument is bound to an rvalue.\nSome facts:\n Neither std::move nor std::forward do anything at runtime. Move request on const objects are treated as copy requests.  std::move To make things concrete, a very basic implementation of std::move in C++11 looks like this:\n1 2 3 4 5 6 7  template\u0026lt;typename T\u0026gt; typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp; move(T\u0026amp;\u0026amp; param) { using ReturnType = typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp;; return static_cast\u0026lt;ReturnType\u0026gt;(param); }   Or, a more elegant implementation in C++14:\n1 2 3 4 5 6  template\u0026lt;typename T\u0026gt; decltype\u0026lt;auto\u0026gt; move(T\u0026amp;\u0026amp; param) { using ReturnType = remove_reference_t\u0026lt;T\u0026gt;\u0026amp;\u0026amp;; return static_cast\u0026lt;ReturnType\u0026gt;(param); }   Basically, std::move does nothing but cast its argument to an rvalue, and we might think it as rvalue_cast. Usually we want move operation on rvalues, so every time we see a move over some parameter, we know we want to perform move operation over the resulting rvalue. However, not all rvalues are candidates for moving, especailly those annotated by const - move requests on const objects are silentlly transformed into copy operation.\nstd::forward std::move unconditionally casts its argument to an rvalue, while std::forward conditionally do so: it casts to an rvalue only if its argument was initialized with an rvalue.\nThe most common scenario is a function template taking a universal reference parameter that is to be passed to another function:\n1 2 3 4 5 6 7 8 9 10  void process(const Widget\u0026amp; lvalArg); void process(Widget\u0026amp;\u0026amp; rvalArg); template\u0026lt;typename T\u0026gt; void logAndProcess(T\u0026amp;\u0026amp; param) // universal reference { auto now = std::chrono::system_clock::now(); makeLogEntry(\u0026#34;Calling \u0026#39;process\u0026#39;\u0026#34;, now); process(std::forward\u0026lt;T\u0026gt;(param)); }   1 2 3  Widget w; logAndProcess(w); // call with lvalue logAndProcess(std::move(w)); // call with rvalue   In the code above, std::forward is able to tell whether param is initialized with an lvalue or an rvalue because that information is encoded in logAndProcess\u0026rsquo;s template parameter T, which is then passed to std::forward, which is able to recover the encoded information. For details, refer to EMCpp item 28.\nComparison Depending on the usecase scenario, we can tell when to use which:\n std:move typically sets up a move std::forward just passes - forwards- an object to another function in a way that retains its original lvalueness or rvalueness. ","description":"","id":80,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-23 Understand std::Move and std::Forward","uri":"https://nianze.ml/en/notes/2018/08/understand-stdmove-and-stdforward/"},{"content":"For std::unique_ptr pImpl pointers, declare special member functions in the class header, but implement them in the implementation file.\nThe Pimpl Idiom decreases build times by reducing compilation dependeencies between class clients and class implementation. For example:\n1 2 3 4 5 6 7 8 9  // header file class Widget { public: Widget(); ... private: struct Impl; std::unique_ptr\u0026lt;Impl\u0026gt; pImpl; };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // impl. file #include \u0026#34;Widget.h\u0026#34;#include \u0026#34;gadget.h\u0026#34;#include \u0026lt;string\u0026gt;#include \u0026lt;vector\u0026gt; struct Widget::Impl { std::string name; std::vector\u0026lt;double\u0026gt; data; Gadget g1, g2, g3; }; Widget::Widget () : pImpl(std::make_unique\u0026lt;Impl\u0026gt;()) {}   However, even though the code above compiles, client code below won\u0026rsquo;t compile:\n1 2  #include \u0026#34;Widget.h\u0026#34;Widget w; // error!   The issue arises due to the code that\u0026rsquo;s generated when w goes out of scope and gets destroyed:\n Since there\u0026rsquo;s no user defined destructor, destructor for Widget is generated by compiler, inside which there is a call to the destructor for pImpl pImpl is a std::unique_ptr\u0026lt;Widget::Impl\u0026gt; using default deleter (a function that uses delete on the raw pointer inside the std::unique_ptr) prior to using delete, autogenerated implementation will have the default deleter employ C++11\u0026rsquo;s static_assert to ensure the raw pointer doesn\u0026rsquo;t point to an incomplete type here this static_assert fails, because autogenerated destructors are implicitly inline, and thus the definition of Widget::Impl along with its autogenerated destructor inside Widget.cpp hasn\u0026rsquo;t been seen by compilers  To solve the problem, we need to let the compiler see the body of Widget\u0026rsquo;s destructor only inside the implementation file after Widget::Impl has been defined:\n1 2 3 4 5 6 7 8 9 10  // header file class Widget { public: Widget(); ~Widget(); // declaration only  ... private: struct Impl; std::unique_ptr\u0026lt;Impl\u0026gt; pImpl; };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // impl. file #include \u0026#34;Widget.h\u0026#34;#include \u0026#34;gadget.h\u0026#34;#include \u0026lt;string\u0026gt;#include \u0026lt;vector\u0026gt; struct Widget::Impl { std::string name; std::vector\u0026lt;double\u0026gt; data; Gadget g1, g2, g3; }; Widget::Widget () : pImpl(std::make_unique\u0026lt;Impl\u0026gt;()) {} Widget::~Widget() {}   To emphasize the fact that the compiler-generated destructor would do the right thing, we can also write like this:\n1  Widget::~Widget() = default;   The same reasoning goes with move operation:\n the compiler generated move assignment operator requires Impl to be complete because the object pointed to by pImpl needs to be destroyed before assignment the compiler generated move constructor requires Impl to be complete because compilers must be able to generate code to destroy pImpl in the event that an exception arises inside the move constructor (even it the constructor is noexcept)  Once we added the move-related functions, compilers won\u0026rsquo;t generate copy operations for us. So to support a well-defined deep copy, we need to write our own version.\n1 2 3 4 5 6 7 8 9 10 11 12  class Widget { public: Widget(); ~Widget(); Widget(Widget\u0026amp;\u0026amp; rhs) noexcept; Widget\u0026amp; operator=(Widget\u0026amp;\u0026amp; rhs) noexcept; Widget(const Widget\u0026amp; rhs); Widgt\u0026amp; operator=(const Widget\u0026amp; rhs); private: struct Impl; std::unique_str\u0026lt;Impl\u0026gt; pImpl; };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  ... Widget::~Widget() = default; Widget::Widget(Widget\u0026amp;\u0026amp; rhs) noexcept = default; Widget\u0026amp; Widget::operator=(Widget\u0026amp;\u0026amp; rhs) noexcept = default; Widget::Widget(const Widget\u0026amp; rhs) : pImpl(nullptr) { if (rhs.pImpl) pImpl = std::make_unique\u0026lt;Impl\u0026gt;(*rhs.pImpl); } Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { if (!rhs.pImpl) pImpl.reset(); else if (!pImpl) pImpl = std::make_unique\u0026lt;Impl\u0026gt;(*rhs.pImpl); else *pImpl = *rhs.pImpl; return *this; }   On the other hand, the above advice does not apply to std::shared_ptr, because in std::shared_ptr, the type of the deleter is not part of the type of the smart pointer, and pointed-to types need not be complete when compiler-generated special functions are employed:\n1 2 3 4 5 6 7 8  class Widget { public: Widget(); ... // no declaration for dtor or move operations private: struct Impl; std::shared_ptr\u0026lt;Impl\u0026gt; pImpl; };   1 2 3 4  // client code compiles without problem Widget w1; auto w2(std::move(w1)); // move-construct w2 w1 = std::move(w2); // move-assign w1   ","description":"","id":81,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-22 When Using Pimple Idiom, Define Special Member Functions in the Implementation File","uri":"https://nianze.ml/en/notes/2018/08/prefer-make_unique-and-make_shared-to-direct-use-of-new/"},{"content":"Compared to new, make functions eliminate source code duplication, improve exception safety, and, for std::make_shard and std::allocate_shared, generate code that\u0026rsquo;s smaller and faster.\nMake functions take an arbitrary set of arguments, perfect forward them to the constructor for a dynamically allocacted object, and return a smart pointer to that objet. There are three make functions:\n std::make_unique std::make_shared std::allocate_shared1  According to the description above, a basic version of std::make_unique is simply:\n1 2 3 4  template\u0026lt;typename T, typename... Ts\u0026gt; std::unique_ptr\u0026lt;T\u0026gt; make_unique(Ts\u0026amp;\u0026amp;... params){ return std::unique_ptr\u0026lt;T\u0026gt;(new T(std::forward\u0026lt;Ts\u0026gt;(params)...)); }   Good parts There are thee reasons to prefer make functions to direct use of new.\n  Eliminate code duplication\n1 2  auto upw1(std::make_unique\u0026lt;Widget\u0026gt;()); std::unique_ptr\u0026lt;Widget\u0026gt; upw2(new Widget);   As we can see above, using make functions avoids code duplication of the repeating type Widget.\n  Improve exception safety\nGiven following functions:\n1 2  void processWidget(std::shared_ptr\u0026lt;Widget\u0026gt; spw, int priority); int computePriority();   then there will be potential resource leak if we directly use new like this:\n1  processWidget(std::shared_ptr\u0026lt;Widget\u0026gt;(new Widget), computePriority());   The potential edge case comes with compilers' translation of source code into object code: compilers may emit code to execute the operations in this order:\n Perform \u0026ldquo;new Widget\u0026rdquo; Execute computePriority Run std::shared_ptr constructor  At runtime, if computePriority produces an exception, the dynamically allocated Widget from Step 1 will be leaked, since it will never be stored in the std::shared_ptr that\u0026rsquo;s supposed to start managing it in Step 3.\nIf we use std::make_shared instead of using new inside std::shared_ptr, there\u0026rsquo;s no Step 1, so Step 2 will never be executed between a new operation and the construction of std::shared_ptr, which is thus exception-safe.\n  Smaller and faster code for std::shared_ptr\nCompared with direct use of new, the improved efficiency provided by std::make_shared and std::allocate_shared is related with its memory allocation mechanism.\n If we directly use new like this - std::shared_ptr\u0026lt;Widget\u0026gt; spw(new Widget); - there are two phaces of allocation involved:  one for Widget object, another for the control block associated with that object.   Instead, auto spw = std::make_shared\u0026lt;Widget\u0026gt;();, one allocation suffices: std::make_shared allocates a single chunk of memory to hold both the Widget object and the constrol block.  This optimization reduces the static size of the program, since the code contains only one memory allocation call This operation also increases the speed of the executable code, since memory is allocated only once Further more, total memory footprint is potentially reduced, since some of the bookkeeping information in the control block is obviated.      Weak parts   Specify custom deleters\nThere\u0026rsquo;s no way to specify a custom deleter using a make function, but using new is straightforward:\n1 2 3  auto widgetDeleter = [](Widget* pw) {...}; std::unique_ptr\u0026lt;Widget, decltype(widgettDeleter)\u0026gt; upw(new Widget, widgetDeleter); std::shared_ptr\u0026lt;Widget\u0026gt; spw(new Widget, widgetDeleter);     Pass braced initializers\nIn these calls,\n1 2  auto upv = std::make_unique\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;(10, 20); auto spv = std::make_shared\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;(10, 20);   the resulting smart pointers point to std::vectors with 10 elements, each of value 20, which means within the make functions, the perfect forwarding code uses the non-std::initializer_list constructor. If we do want to perfect-forward a braced initializer, we use following workaround;\n1 2  auto initList = { 10, 20 }; // create std::initializer_list auto spv = std::make_shared\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;(initList); // create std:vector using std::initializer_list cotr     Custom memory management or memory restriction concerns for std::shared_ptr\nDue to the extra control block in std::shared_ptr, there are two more edge cases where make functions may be ill-advised:\n classes with custom memory management:  if a class defines its own versions of operator new and operator delete, it implies the global memory allocation and deallocation routines for objects of this class are inappropriate. class-specific routines are often designed only to allocate and deallocate chunks of memory of pricisely the size of objects of this class std::allocate_shared however requests to allocate the size of one object plus the size of a control block, so the class-specific routines are poor fit for std::allocate_shared and custom deleters.   systems with memory concerns  when using std::make_shared, the memory allocation for the object and the control block is at the same time, which brings us the smaller and faster code mentioned above; however, this also means that the deallocation for the same chunk of memory has to be at the same time when an object\u0026rsquo;s reference count goes to zero, the object is destroyed (via its destructor), but the memory it occupies will wait to be released until the control block also gets destroyed control block contains a weak count (a second reference count for std::weak_ptr); as long as the weak count is greater than zero, the control block must continue to exist if the object type is quite large and the time between destrution of the last std::shared_ptr and the last std::weak_ptr is significant, a lag occurres between when an object is destroyed and when the memory this object (and its control block) occupied is freed if memory is a concern, this lag will make us frown      Due to the reasons above, we may have to give up make function and directly use new, but we also want to keep our program exception-safe. Here is a workaround, take the same processWidget for example:\n1 2  std::shared_ptr\u0026lt;Widget\u0026gt; spw(new Widget, cusDel); processWidget(std::move(spw), computePriority()); // keep arg as rvalue, so it\u0026#39;s move-enabled   The std::move here is to make sure the argument we pass to processWidget is rvalue, so that expensive copy construction for a std::shared_ptr object, which involves atomic increment of its reference count, will be replaced by a move construction, which requires no reference count manipulation.\n std::allocate_shared acts just like std::make_shared, except its first argument is an allocator object to be used for the dynamic memory allocation.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":82,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-21 Prefer std::make_unique and std::make_shared to Direct Use of New","uri":"https://nianze.ml/en/notes/2018/08/prefer-make_unique-and-make_shared-to-direct-use-of-new/"},{"content":"Potential use cases for std::weak_ptr include caching, observer lists, and the prevention of std::shared_ptr cycles.\nFrom an efficiency perspective, the std::weak_ptr is essentially the same as std::shared_ptr, except that they don\u0026rsquo;t participate in the shared ownership of objects and hence don\u0026rsquo;t affect the pointed-to object\u0026rsquo;s reference count. However, they do manipulate a second reference count in the control block (weak count), so they actually do all the same operations such as construction, destruction, and assignment involve atomic reference count manipulations.\nAs a fact, std::weak_ptr isn\u0026rsquo;t a standalone smart pointer, but an augmentation of std::shared_ptr:\n1 2 3 4 5 6  auto spw = std::make_shared\u0026lt;Widget\u0026gt;(); // reference count (RC) is 1 after spw is constructed ... std::weak_ptr\u0026lt;Widget\u0026gt; wpw(spw); // RC remains 1 ... spw = nullptr; // RC becomes 0, Widget gets destroyed, wpw dangles if (wpw.exipred()) ... // true   Usually, the purpose of creating a std::weak_ptr is to check the dangling std::weak_ptr (when the related control block has zero-value reference count), and if it hasn\u0026rsquo;t expired, we may access the object it points to. Separating the check and the dereference would introduce a race condition, so we need an atomic operation to check and access the object at the same time. There are two ways to do this:\n1 2  auto spw1 = wpw.lock(); // spw1 type is shared_ptr\u0026lt;Widget\u0026gt;; if wpw\u0026#39;s expired, spw1 is null std::shared_ptr\u0026lt;Widget\u0026gt; spw2(wpw); // if wpw\u0026#39;s expired, throw std::bad_weak_ptr   There are at least three use cases for std::weak_ptr.\nCaching Given a factory function returning std::unique_ptr:\n1  std::unique_ptr\u0026lt;const Widget\u0026gt; loadWidget(WidgetID id);   We might consider wrap a cache layer on top of loadWidget due to considerations such as expensive database I/O cost or frequent queries from clients. A quick-and-dirty implementation using std::weak_ptr may fit the requirement1:\n1 2 3 4 5 6 7 8 9 10 11  std::shared_ptr\u0026lt;const Widget\u0026gt; fastLoadWidget(WidgetID id) { static std::unordered_map\u0026lt;WidgetID, std::weak_ptr\u0026lt;const Widget\u0026gt;\u0026gt; cache; auto objPtr = cache[id].lock(); if (!objPtr) { objPtr = loadWidget(id); cache[id] = objPtr; } return objPtr; }   Observer list In the Observer design pattern, there are two components:\n subjects: whose state may change observers: who will be notified when state changes occur  Each subject may contain a data member holding pointers to its observers to issue state change notifications. Since subjects only cares if an observer gets destroyed (to cancel subsequent notifications) and needn\u0026rsquo;t control the lifetime of their observers, a reasonable design, therefore, is to let each subject hold a container of std::weak_ptrs to its observers, and check if a pointer dangles before using it.\nCycling prevention In strictly hierarchal data structures such as trees, child nodes are typially owned only by their parents. When a parent node is destroyed, child nodes are destroyed, too. Links from parents to children are generally best represented by std::unique_ptr, while back-links from children to parents can be safely implemented as raw pointers2.\nIn other pointer-based non-strict-hierarchical data structure, however, forward-links may be best implemented in terms of std::shared_ptr, and to prevent cycles, which will lead to resource leak3, back-link should use std::weak_ptr.\n A potential refinement is to remove the expired cache, since right now the cache accumulate std::weak_ptr corresponding to Widgets that are no longer in use (and have therefore been destroyed).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Children have a shorter lifetime than their parent node, so there\u0026rsquo;s no risk of a child node dereferencing a dangling parent pointer.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Two std::shared_ptrs point to each other wil prevent both from being destroyed: even if both object are unreachable from other program data structures, each will have a reference count of one.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":83,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-20 Use Weak_ptr for Shared_ptr Like Pointers That Can Dangle","uri":"https://nianze.ml/en/notes/2018/08/use-weak_ptr-for-shared_ptr-like-pointers-that-can-dangle/"},{"content":"std::shared_ptrs offer convenience approaching that of garbage collection for the shared lifetime management of arbitrary resources.\nSome facts  std::shared_ptrs are twice the size of a raw pointer:  a raw pointer to the resource a raw pointer to the resource\u0026rsquo;s control block, which is dynamically allocated and contains  reference count weak count other optional data (e.g., custom deleter, allocator, etc)     increments and decrements of the reference count are atomic  reading and writing reference counts is typically slower than non-atomic operations and comparatively costly the related atomic operations typically map to individual machine instructions. Admittedly, they are expensive compared to non-atomic instructons, but they\u0026rsquo;re still just single instructions move-constructing a std::shared_ptr from another std::shared_ptr requires no refernece count manipulation   Default resource destruction is via delete, but custom deleters are supported  the type of the deleter has no effect on the type of the std::shared_ptr (they\u0026rsquo;re in the control block)   std::shared_ptr is designed only for pointers to single objects, and can\u0026rsquo;t work with arrays, unlike std::unique_ptr  Basically, this is how a std::shared_ptr\u0026lt;T\u0026gt; object looks like in the memory:\n std::shared_ptr\u0026lt;T\u0026gt; ┌──────────────────────┐ ┌──────────┐ │ Ptr to T ├──\u0026gt;│ T Object │ ├──────────────────────┤ └──────────┘ │ Ptr to Control Block ├───┐ └──────────────────────┘ ↓ Control Block ┌───────────────────────┐ │ Reference Count │ ├───────────────────────┤ │ Weak Count │ ├───────────────────────┤ │ Other Data │ │ (e.g., custom deleter,│ │ allocator, etc.) │ └───────────────────────┘ It is worth noting that std::shared_ptr design is more flexible than std::unique_ptr in the aspect of specifying custom deleters, because, unlike std::unique_ptr, the type of the deleter is not part of the type of the std::shared_ptr:\n1 2 3 4 5 6 7 8 9  auto customDeleter1 = [](Widget *pw) {...}; auto customDeleter2 = [](Widget *pw) {...}; std::unique_ptr\u0026lt;Widget, decltype(customDeleter1)\u0026gt; upw1(new Widget, customDeleter1); std::unique_ptr\u0026lt;Widget, decltype(customDeleter2)\u0026gt; upw2(new Widget, customDeleter1); std::shared_ptr\u0026lt;Widget\u0026gt; spw1 (new widget, customDeleter1); std::shared_ptr\u0026lt;Widget\u0026gt; spw2 (new widget, customDeleter2); std::vector\u0026lt;std::shared_ptr\u0026lt;Widget\u0026gt;\u0026gt; vpw { spw1, spw2 };   Apart from placing spw1 and spw2 in the same container, we could also assign one to another, or pass them into a function taking a parameter of type std::shared_ptr\u0026lt;Widget\u0026gt;. None of these things can be done with std::unique_ptrs, since their types differ due to different custom deleters.\nAvoid multiple control blocks from this pointer Below is the rules to create the control block:\n a control block is created when std::make_shared (EMCpp item 20) is called (which manufactures a new object to point to) a control block is created when std::shared_ptr is constructed from a unique-ownership pointer (i.e., a std::unique_ptr or std::auto_ptr), and the unique-ownership pointer is set to null later. a control block is created when a std::shared_ptr is called with a raw pointer  this may lead to double deletion issue (creating two control blocks with the same raw pointer), so avoid passing raw pointers to a std::shared_ptr if have to, do in this form std::shared_ptr\u0026lt;Widget\u0026gt; spw(new Widget, loggingDel); to use new directly   the same control block will be shared if a std::shared_ptr is constructed using another std::shared_ptr as initialization argument (by calling std::shared_ptr copy constructor)  Even though we remember the rule to restrict the creation of std::shared_ptr from raw pointers, we might surprisingly create multiple control blocks through the this pointer, which is also a raw pointer. For example, Widget has a member function void processing();, and we use a vector to keep track of Widgets that have been processed. A reasonable-looking approach looks like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13  std::vector\u0026lt;std::shared_ptr\u0026lt;Widget\u0026gt;\u0026gt; processedWidgets; class Widget { public: ... void process(); ... }; void Widget::process(){ ... processedWidgets.emplace_back(this); // add current Widget to list of processed Widgets  ... }   This code will compiler, but it has potential danger: process() passes raw pointer this to a container of std::shared_ptr, resulting to a new control block for pointed-to Widget(*this); as long as there are std::shared_ptrs outside the process() that already point to that Widget, undefined behavior shows up.\nHere, we want a class managed by std::shared_ptrs to be able to safely create a std::shared_ptr from a this pointer without creating multiple control blocks. The solution is to inherit from a base class template std::enable_shared_from_this, which contains a member function shared_from_this(), which points to the same object as the this pointer. We can use this function to create a std::shared_ptr worring about creating a new control block.\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Widget: public std::enable_shared_from_this\u0026lt;Widget\u0026gt; { public: ... void process(); ... }; void Widget::process() { ... processedWidgets.emplace_back(shared_from_this()); ... }   Two points worth noting:\n Here, the derived class(Widget) inherites from a base class templatized on the derived class. This design pattern is called CRTP: The Curiously Recurring Template Pattern. Internally, shared_from_this() looks up the control block for the current object, and it creates a new std::shared_ptr referring to that control block. This means there must be an existing std::shared_ptr that points to the current object. If no such std::shared_ptr exists, behavior is undefined (typically an exception will be thrown)  To prevent invoking shared_from_this() before a std::shared_ptr points to the object, classes inheriting from std::enable_shared_from_this often declare their constructors private and provide factory functions returning std::shared_ptrs to clients:\n1 2 3 4 5 6 7 8 9 10  class Widget: public std::enable_shared_from_this\u0026lt;Widget\u0026gt; { public; template\u0026lt;typename... Ts\u0026gt; static std::shared_ptr\u0026lt;Widget\u0026gt; create(Ts\u0026amp;\u0026amp;... params); ... void process(); // as before  ... private: ... // ctors };   ","description":"","id":84,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-19 Use std::Shared_ptr for Shared-ownership Resource Management","uri":"https://nianze.ml/en/notes/2018/07/use-shared_ptr-for-shared-ownership-resource-management/"},{"content":"std::unique_ptr is a small, fast, move-only smart pointer for managing resources with exclusive-ownership semantics.\nSome facts:\n std::unique_ptr embodies exclusive ownership semantics: a non-null std::unique_ptr owns what it points to Moving a std::unique_ptr transfers ownershiip from the source pointer to the destination pointer Copying a std::unique_ptr isn\u0026rsquo;t allowed (it\u0026rsquo;s move-only type) Upong destruction, a non-null std::unique_ptr destroys its resource by calling its deleter (by default the deleter simply applies delete to the raw pointer inside the std::unique_ptr) std::unique_ptr can easily and efficiently converts to a std::shared_ptr  Factory functions and Pimpl Idiom are two common use case for std::ptrs. For example, supporse we have a hierarchy for types of investments (e.g., stocks, bonds, real estate, etc.) with a factory function alllocating an object on the heap and returning a pointer to it:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Investment { public: ... virtual ~Investment(); ``` }; class Stock: public Investment {...}; class Bond: public Investment {...}; class RealEstate: public Invesetment {...}; template\u0026lt;typename... Ts\u0026gt; std::unique_ptr\u0026lt;Investment, decltype(delInvmt)\u0026gt; // return std::unique_ptr to an object makeInvestment(Ts\u0026amp;\u0026amp;... params); // created from the given args with cutomized deleter   By the help of std::unique_ptr, clients will no longer worry about deleting it:\n1 2 3 4 5  { ... auto pInvestment = makeInvestment( arguments ); ... } // destroy *pInvestment   Callers can also take use of std::unique_ptr\u0026rsquo;s feature to adapt it to its more flexible sibling std::shared_ptr:\n1  std::shared_ptr\u0026lt;Investment\u0026gt; sp = makeInvestment( arguments );   Implementation For C++11, we can implement the factory function this way:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  auto delInvmt = [](Investment* pInvestment) // custom deleter  { // (a lambda expression)  makeLogEntry(pInvestment); delete pInvestment; }; template\u0026lt;typename... Ts\u0026gt; std::unique_ptr\u0026lt;Investment, decltype(delInvmt)\u0026gt; makeInvestment(Ts\u0026amp;\u0026amp;... params) { std::unique_ptr\u0026lt;Investment, decltype(delInvmt)\u0026gt; pInv(nullptr, delInvmt); if ( /* a Stock should be created */ ) { pInv.reset(new Stock(std::forward\u0026lt;Ts\u0026gt;(params)...)); } else if ( /* a Bond should be created */ ) { pInv.reset(new Bond(std::forward\u0026lt;Ts\u0026gt;(params)...)); } else if ( /* a RealEstate should be created */ ) { pInv.reset(new RealEstate(std::forward\u0026lt;Ts\u0026gt;(params)...)); } return pInv; }   In C++14, we could use function return type deduction to make it simpler and more encapsulated:\n1 2 3 4 5 6 7 8 9 10 11  template\u0026lt;typename... Ts\u0026gt; auto makeInvestment(Ts\u0026amp;\u0026amp;... params) // C++14 { auto delInvmt = [](Investment* pInvestment) // now inside makeInvestment  { makeLogEntry(pInvestment); delete pInvestment; }; std::unique_ptr\u0026lt;Investment, decltype(delInvmt)\u0026gt; pInv(nullptr, delInvmt); ... // as before }   It is worth thinking about the size impact on a std::unique_ptr after introducing a custome deleter:\n if the deleter is a function pointer, the size of a std::unique_ptr generally grow from one (the size of a raw pointer) to two if the deleter is a function object, the change in size depends on how much state is stored in the function object  Stateless function objects (e.g., from lambda expressions with no captures) typically incur no size penalty when used as deleters (still one word) Function object deleters with extensive state can yield std::unique_ptr objects of significant size.    Two forms std::unique_ptr comes in two forms\n std::unique_ptr\u0026lt;T\u0026gt; for individule objects, which lacks indexing operator (operator[]) std::unique_ptr\u0026lt;T[]\u0026gt; for arrays, which lacks dereferencing operators (operator* and operator-\u0026gt;)  Generally, std::array, std::vector, and std::string are always better data structure choices than raw arrays, so the only situation where std::unique_ptr\u0026lt;T[]\u0026gt; makes sense would be when we\u0026rsquo;re using a C-like API that returns a raw pointer to a heap array that we assume ownership of.\n","description":"","id":85,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-18 Use std::unique_ptr for Exclusive-ownership Resource Management","uri":"https://nianze.ml/en/notes/2018/07/use-unique_ptr-for-exclusive-ownership-resource-management/"},{"content":"The special member functions are those ccompilers may generate on their own: default constructor, destructor, copy operations, and move operations.\nThe rules in C++11:\n Default constructor: Generated only if the class contains no user-declared constructors. (Same as C++98) Destructor: Destructors are noexcept by default (see EMCpp item 14). Other rules are essentially the same as C++98. Copy constructor  Runtime behavior: same as C++98: memberwise copy construction of non-static data members Generated only if the class lacks a user-declared copy constructor. Generation is deprecated if the user declares a copy assignment operator or destructor. Deleted if the class declares a move operation.   Copy assignment operator  Runtime behavior: same as C++98: memberwise copy assignment of non-static data members. Generation is deprecated if the user declares a copy constructor or destructor. Deleted if the class declares a move operation.   Move constructor and Move assignment operator:  Runtime behavior: memberwise moving of non-static data members Generated only if the class lacks user-declared copy operations, move operations, and destrutor.    Use of \u0026ldquo;=default\u0026rdquo; The default implementation for special member functions inside a base class is correct. Since we have to explicitly declare the base destructor as virtual to avoid undefined or misleading results that often occurs in polymorphic inheritance, using \u0026ldquo;=default\u0026rdquo; will be a good way to express the suppressed default implementation of the move and/or copy operations:\n1 2 3 4 5 6 7 8 9 10  class Base { public: virtual ~Base() = default; // make dtor virtual  Base(Base\u0026amp;\u0026amp;) = default; // support moving  Base\u0026amp; operator=(Base\u0026amp;\u0026amp;) = default; Base(const Base\u0026amp;) = default; // support copying  Base\u0026amp; operator=(const Base\u0026amp;) = default; };   Member function templates Note that there\u0026rsquo;s nothing in the rules about the existence of a member function template preventing compilers from generating the special member functions:\n1 2 3 4 5 6 7 8 9  class Widget { ... template\u0026lt;typename T\u0026gt; Widget(const T\u0026amp; rhs); // construct Widget from anything  template\u0026lt;typename T\u0026gt; Widget\u0026amp; operator=(const T\u0026amp; rhs); // assign Widget from anything  ... };   Assuming the usual conditions governing special member functions are fulfilled, compilers will still generate copy and move operations for Widget even though these templates could be instantiated to produce the signatures for the copy constructor and copy assignment operator (when T is Widget). Refer to EMCpp item 26 for cases that have important consequences.\n","description":"","id":86,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-17 Understand Special Member Function Generation","uri":"https://nianze.ml/en/notes/2018/07/understand-special-member-function-generation/"},{"content":"Make const member functions thread safe unless we\u0026rsquo;re certain they\u0026rsquo;ll never be used in a concurrent context.\nDue to mutable member datas, const member functions may not be thread safe. For a classic use case for mutable:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Polynomial { public: using RootsType = std::vector\u0026lt;double\u0026gt;; // holding val. where poly. evals to zero  RootsType roots() const { if (!rootsAreValie) { // if cache not valid  ... // compute roots, store them in rootVals  rootsAreValid = true; } return rootVals; } ... private: mutable bool rootsAreValid{ false }; mutable RootsType rootVals{}; };   Here roots() retrieves the roots of a polynomial without changing the value of the Polynomial object on which it operates, so const declaratoin is correct. However, rootVals and rootsAreValid might be modified for the purpose of caching. Seeing the const interface for roots(), clients are perfectly reasonable to do something like this:\n1 2 3 4  Polynomial p; ... // thread 1 // thread 2 auto rootsOfP = p.roots(); auto valsGivingZero = p.roots();   Having multiple threads perform a read operation without synchronization is safe. However, although roots is declared const, it\u0026rsquo;s not thread safe: more than one threads might try to modify the data members rootsAreValid and rootVals inside roots, reading and writing the same memory without synchronization - which is data racing, leading to undefined behavior.\nSolution: mutex 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Polynomial { public: using RootsType = std::vector\u0026lt;double\u0026gt;; // holding val. where poly. evals to zero  RootsType roots() const { std::lock_guard\u0026lt;std::mutex\u0026gt; g(m); // lock mutex  if (!rootsAreValie) { // if cache not valid  ... // compute roots, store them in rootVals  rootsAreValid = true; } return rootVals; } // unlock mutex  ... private: mutable std::mutex m; mutable bool rootsAreValid{ false }; mutable RootsType rootVals{}; };   roots is a const member function, inside which std::mutex m would be considered a const object, while locking and unlocking are non-const member functions, so we need to declared m as mutable.\nAnother point worth noting is that std::mutex can be neither copied nor moved, so a side effect of adding m to Polynomial is that Polynomial loses the ability to be copied and moved.\nFor a single variable requiring synchronization Sometimes when there\u0026rsquo;s only one variable or memory location requiring synchronization, mutex might be overkill, and we might consider std::atomic counter (EMCpp item 40), which is often a less expensive way to go1:\n1 2 3 4 5 6 7 8 9 10 11 12  class Point { public: ... double distanceFromOrigin() const noexcept { ++callCount; // atomic increment  return std::hypot(x, y); } private: mutable std::atomic\u0026lt;unsigned\u0026gt; callCount{ 0 }; double x, y; };   The same side effect goes here: the existance of callCount in Point makes Point neither copyable nor movable.\nSummary The point in this item: when we write a const member function, we might avoid the costs associated with mutexes and std::stomics as well as the side effect of uncopyability as well as unmovability, if we can guarantee that there will never be more than one thread executing that member function on an object.\nHowever, such threading-free scenarios are increasingly uncommon. In order to support concurrent execution, we should unsure that const member functions are thread safe.\n Whether it actually is less expensive depends on the hardware we\u0026rsquo;re runnig on and the implementation of mutexes in our Standard Library.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":87,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-16 Make Const Member Functions Thread Safe","uri":"https://nianze.ml/en/notes/2018/07/make-const-member-functions-thread-safe/"},{"content":"constexpr objects are const and are initialized with values known during compilation; constexpr functions can produce copmile-time results when called with arguments whose values are know during compilations.\nconstexpr objects Values known during compmilation are privileged: they may be placed in read-only memory (important for embedded systems), and part of them with constant integral values can be used in contexts where C++ requires an integral constant expression1. Thuse, if we want the compilers to ensure that a variable is constant with a value know at compile time, we declare it constexpr:\n1 2 3 4 5 6  int sz; // non-constexpr variable ... constexpr auto arraySize1 = sz; // error: value not known at compilation std::array\u0026lt;int, sz\u0026gt; data1; // error: same problem constexpr auto arraySize2 = 10; // fine: 10 is compile-time constant std::array\u0026lt;int, arraySize2\u0026gt; data2; // fine, arraySize2 is constexpr   All constexpr objects are const, but not all const objects are constexpr, because const objects need not be initialized with values known during compilations:\n1 2 3 4  int sz; ... const auto arraySize = sz; // fine: arraySize is const copy of sz std::array\u0026lt;int, arraySize\u0026gt; data; // error: arraySize\u0026#39;s value not known at compilation   constexpr functions constexpr is part of a functions\u0026rsquo;s interface, which proclaims \u0026ldquo;I can be used in a context where C++ requires a constant expression.\u0026rdquo; In other words:\n if the values of the arguments we pass to a constexpr function are known during compilation, the result will be computed during compilation when a constexpr function is called with one or more values that are not known during compilation, it acts like a normal function, computing its result at runtime: so that we don\u0026rsquo;t need two functions to perform the same operation.  For example, we want to initialize a std::array with the size of 3^n, wher n is a known integer (or can be computed) during compilation. std::pow doesn\u0026rsquo;t help here, because\n std::pow works on floating-point types, while we need an integral result std::pow isn\u0026rsquo;t constexpr  Thus, we write the pow we need:\n1 2 3 4 5 6 7 8 9 10 11 12  constexpr int pow(int base, unsigned exp) noexcept // never throws { ... // impl is below } constexpr auto numConds = 5; // # of conditions std::array\u0026lt;int, pow(3, numConds)\u0026gt; results; // results has 3^numConds elements ... auto base = readFromDB(\u0026#34;base\u0026#34;); // get the value at runtime auto exp = readFromDB(\u0026#34;exponent\u0026#34;); // ditto auto baseToExp = pow(base, exp); // we can also call pow function at runtime, of course   In C++11, there\u0026rsquo;re some restrictions on constexpr functions:\n they may only contain a single return statement they are limited to taking and returning literal types2  so the implementation goes like this:\n1 2 3 4  constexpr int pow(int base, unsigned exp) noexcept { return (exp == 0 ? 1 : base * pow(base, exp - 1)); }   For C++14, the restrictions are substantially looser:\n1 2 3 4 5 6  constexpr int pow(int base, unsigned exp) noexcept { auto result = 1; for (unsigned i = 0; i \u0026lt; exp; ++i) result *= base; return result; }   constexpr functions can work with user-defined literal types, too:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Point { public: constexpr Point(double xVal = 0, dobule yVal = 0) noexcept : x(xVal), y(yVal) {} constexpr double xValue() const noexcept { return x; } constexpr double yValue() const noexcept { return y; } constexpr void setX(double newX) noexcept { x = newX; } // due to \u0026#34;void\u0026#34; return type,  constexpr void setY(double newY) noexcept { y = newY; // setters\u0026#39;re contexpr only in C++14 private: double x, y; }; constexpr Point midpoint(const Point\u0026amp; p1, const Point\u0026amp; p2) noexcept { return { (p1.xValue() + p2.xValue()) / 2, (p1.yValue() + p2.yValue()) / 2 }; // call constexpr member funcs } constexpr Point reflection(const Point\u0026amp; p) noexcept { Point result; // create non-const Point  result.setX(-p.xValue); // set its x and y value  result.setY(-p.yValue); return result; // return copy of it }   By introducing constexpr, we can maximize the range of situation our objects and functions may be used - the traditionally fairly strict line between work done during compilation and work done at runtime begins to blur after we use constexpr constructors, constexpr getters, constexpr setters, constepxr non-member functions, and create objects in read-only memory:\n1 2 3 4  constexpr Point p1(9.4, 27.7); // \u0026#34;runs\u0026#34; constexpr ctor during compilation constexpr Point p2(28.8, 5.3); // same constexpr auto mid = midpoint(p1, p2); // init constexpr object with result of constexpr func constexpr auto reflectedMid = reflection(mid); // reflectedMid\u0026#39;s value is known during compilation   As a result, the more code taking part in the compilation time, the faster our software will run3.\n Such contexts include specification of array sizes, integral template arguments, enumerator values, alignment specifiers, etc.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Literal types: types that can have values determined during compilation. In C++11, all built-in types except void qualify, plus some user-defined types whose constructors and other member functions are constexpr.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Compilation may take longer, however.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":88,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-15 Use Constexpr Whenever Possible","uri":"https://nianze.ml/en/notes/2018/07/use-constexpr-whenever-possible/"},{"content":"Most functions are exception-neutral, but for some, such as move operations, swap, memory deallocation functions, and destructors, noexcept is particularly valuable.\nMore optimizable For functions that won\u0026rsquo;t produce exceptions, we have C++98 style as well as C++11 style:\n1 2  int f(int x) throw(); // C++98 style int f(int x) noexcept; // C++11 style   The difference:\n C++98: the call stack is unwound to f\u0026rsquo;s caller before program execution is terminated C++11: the call stack is possibly unwound before program execution is terminated  The difference in possibly unwinding leads to large impact on code generation: optimizers need not keep the runtime stack in an unwindable state, and need not ensure that objects in a noexcept function are destroyed in the inverse order of construction, both of which optimization flexibility is lacked for throw(). In fact, throw has the same level of optimizability as functions with no exception specification.\nFor some functions, noexcept is even more desired. For example, calls to copy operations in C++98 will be replaced with calls to move operations in C++11, only if the move operation is declared noexcept. Similarly, swaps in the Standard Library are noexcpet sometimes dependends on whether uesr-defined swaps are noexcept. Following is the declarations for the Standard Library\u0026rsquo;s swaps for arrays and std::pair:\n1 2 3 4 5 6 7 8 9 10  template\u0026lt;class T, size_t N\u0026gt; void swap(T (\u0026amp;a)[N], T (\u0026amp;b)[N]) noexcept(noexcept(swap(*a, *b))); template\u0026lt;class T1, class T2\u0026gt; struct pair { ... void swap(pair\u0026amp; p) noexcept(noexcept(swap(first, p.first)) \u0026amp;\u0026amp; noexcept(swap(second, p.second))); ... };   These functions are conditionally noexcept: whether they are noexcept depends on whether the expression inside the noexcept clauses are noexcept. The fact that swapping higher-level data structures can generally be noexcept only if swapping their lower-level constituents is noexcept should be reasonable enough to offer noexcept swap functions whenever we can.\nException Neutral Functions noexcept is part of a function\u0026rsquo;s interface, so we should declare a function noexcept only if we are willing to commit to a noexcept implementation over the long term.\nHowever, most functions are exception-newtral: they throw no exceptions themselves, but functions they call might emit one. Such functions are never noexcept, because they may emit such \u0026ldquo;just passing through\u0026rdquo; exceptions, and thus they lack the noexcept designation on purpose.\nFor some other few functions, on the other hand, being noexcept is so important that, in C++11, they are implicitly noexcept: by default, all memory deallocation functions and destructors (both user-defined and compiler-generated) are noexcept.\nWide Contracts vs Narrow Contracts A function with a wide contract has no preconditions: they can be called regardless of the state of the program, with no constraints on the arguments that callers pass it, and never exhibit undefined behavior.\nFunctions withou wide contracts have narrow contract: if a precondition is violated, results are undefined.\nGenerally, library desingers reserve noexcept for functions with wide contracts, so that if a precondition in a narrow contract is violated, the program may throw a \u0026ldquo;precondition was violated\u0026rdquo; exception, instead of letting the program to terminate.\nIf we\u0026rsquo;re writing a function with a wide contract and we know it won\u0026rsquo;t emit exceptions, just declare it noexcept.\nBackward compatibility So much legacy code is not decalred with noexcpet even though they actually never emit exceptions. For the reason of backward compatibility, noexcept functions calling non-noexcept functions are permitted in C++, and compilers generally don\u0026rsquo;t issue warnings about it:\n1 2 3 4 5 6 7 8 9  void setup(); // legacy code defined elsewhere void cleanup(); // without declaring noexcept  void doWork() noexcept { setup(); ... clean(); }   ","description":"","id":89,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-14 Declare Functions Noexcept if They Won't Emit Exception","uri":"https://nianze.ml/en/notes/2018/07/declare-functions-noexcept-if-they-wont-emit-exception/"},{"content":"In maximally generic code, prefer non-member versions of begin, end, rbegin, etc., over their member function counterparts.\nIn C++98, using const whenever it\u0026rsquo;s meaningful wasn\u0026rsquo;t practical: it wasn\u0026rsquo;t that easy to create them, and once we had one, the ways we could use it were limited. For example:\n1 2 3 4 5  std::vector\u0026lt;int\u0026gt; values; ... std::vector\u0026lt;int\u0026gt;::iterator it = std::find(values.begin(), values.end(), 1983); values.insert(it, 1998);   The code above search for the first occurrence of 1983 (the year \u0026ldquo;C++\u0026rdquo; replaced \u0026ldquo;C with Classes\u0026rdquo;), then insert the value 1998 (first ISO C++ Standard was adopted) at that location. If no 1983 found, insert at the end of the vector. Since the code never modifies what an iterator points to, so acoording to the convention to use const whenever possible, we should use the const-iterator.\nHowever, in C++98, there was no simple way to get a const_iterator from a non-const container. To work it out, we might concider using the cast like the following code, which conceptually works but probably won\u0026rsquo;t compile:\n1 2 3 4 5 6 7 8 9 10  typedef std::vector\u0026lt;int\u0026gt;::iterator IterT; typedef std::vector\u0026lt;int\u0026gt;::const_iterator ConstIterT; std::vector\u0026lt;int\u0026gt; values; ... ConstIterT ci = std::find(static_cast\u0026lt;ConstIterT\u0026gt;(values.begin()), static_cast\u0026lt;ConstIterT\u0026gt;(values.end()), 1983); values.insert(static_cast\u0026lt;IterT\u0026gt;(ci), 1998); // may not compile   The problem here is that in C++98, const_iterators weren\u0026rsquo;t acceptable for insertions and erasures, so we cast ci into its non-const version. However, in C++98, there\u0026rsquo;s no portable conversion from a const_iterator to an iterator1, so the last statement probably won\u0026rsquo;t compile. The conclusion: const_iterators were so much trouble in C++98.\nNow that we in the new world of C++11, const_iterators are both easy to get and easy to use. Even for non-const containers, we get cbegin and cend to produce const_iterators:\n1 2 3 4  std::vector\u0026lt;int\u0026gt; values; ... auto it = std::find(values.cbegin(), values.cend(), 1983); values.insert(it, 1998);   Maximally Generic Support Taking into account that some containers and container-like data structures offer begin and end as non-member functions, C++11 added the non-member functions begin and end to make sure some generic library code using non-member functions is possible.\nC++14 rectified the oversight in C++11, adding the support for cbegin, cend, rbegin, rend, crbegin, and crend. Now we could generalize the code above into a findAndInsert template as follow:\n1 2 3 4 5 6 7 8 9 10 11 12 13  template\u0026lt;typename C, typename V\u0026gt; void findAndInsert(C\u0026amp; container, // find first occurrence of targetVal in container  const V\u0026amp; targetVal, // then insert insertVal there  const V\u0026amp; insertVal) { using std::cbegin; using std::cend; auto it = std::find(cbegin(container), // non-member cbegin  cend(container), // non-member cend  targetVal); container.insert(it, insertVal); }   If we\u0026rsquo;re using C++11 and want to write maximally generic code, we may build our own implementation for non-member cbegin:\n1 2 3 4 5  template\u0026lt;class C\u0026gt; auto cbegin(const C\u0026amp; container) -\u0026gt; decltype(std::begin(container)) { return std::begin(container); }   Point here is: through its reference-to-const parameter, container, we are invoking the non-member begin function (provided by C++11) on a const container, and this process yields a const_iterator. In fact, this template works even if C is a built-in array type2.\n It\u0026rsquo;s true in C++11, too.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n For insight into how a template can be specialized for built-in arrays, consult EMCpp item 1\u0026rsquo;s discussion of type deduction in templates that take reference parameters to arrays.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":90,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-13 Prefer Const_iterators to Iterators","uri":"https://nianze.ml/en/notes/2018/07/prefer-const_iterators-to-iterators/"},{"content":"C++11 gives us a way to make explicit that a derived class function is supposed to override a base class version: override.\nThere are several requirements for overriding to occur:\n The base class function must be virtual The base and derived funciton names must be identical (except in the case of destructors) The parameter types of the base and derived functions must be identical The constness of the base and derived functions must be identical The return types and exception specifications of the base and derived functions must be compatible The functions' reference qualifiers mmust be identical (new from C++11)  All these requirements for overriding mean that small mistakes can make a big difference. Code containing unintended overriding errors is typically still valid, so compilers may fail to notify us the errors. For example, following code is completely legal:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Base { public: virtual void mf1() const; virtual void mf2(int); virtual void mf3() \u0026amp;; void mf4() const; }; class Derived: public Base { public: void mf1(); // virtual is optional here for derived classes  void mf2(unsigned int); void mf3() \u0026amp;\u0026amp;; virtual void mf4() const; };   However, we almost certainly intend to override base class functions with derived class ones with the same names, yet none of the derived class functions are tied to the base class ones:\n mf1 is declared const in Base, but not in Derived mf2 takes an int in Base, but an unsigned int in Derived mf3 is lvalue-qualified in Base, but rvalue-qualified in Derived mf4 isn\u0026rsquo;t declared virtual in Base  If we explicitly declare with the contextual keyword override:\n1 2 3 4 5 6 7  class Derived: public Base { public: virtual void mf1() override; virtual void mf2(unsigned int) override; virtual void mf3() \u0026amp;\u0026amp; override; virtual void mf4() const override; };   Then the code won\u0026rsquo;t compile, because compilers will complain the overriding-related problems above, which is exactly what we want.\nMoreover, taking use of compilers' ability to diagnostic overriding problems, we can easily use override keyword to gauge the ramifications if we\u0026rsquo;re contemplating changing the signature of a virtual funciton in a base class: if derived classes use override everywhere, we can just change the signature, recompile the system, see how much damage we\u0026rsquo;ve caused, and then decide whether the signature change is worth the trouble.\n","description":"","id":91,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-12 Declare Overriding Functions Override","uri":"https://nianze.ml/en/notes/2018/07/declare-overriding-functions-override/"},{"content":"A brief notes on Clean Architecture\nChapter 1 What is design and architecture  The Goal:   The goal of software architecture is to minimize the human resources required to build and maintain the required system.\n  Low-level details andd the high-level structure are all part of the same whole, forming a continuous fabric that defines the shape of the system. There is simply a continuum of decisions from the highest to the lowest levels.  Chapter 2 A Tale of Two Values  Eisenhower matrix:      Urgent Not urgent     Important Important/Urgent Important/Not urgent   Unimportant Unimportant/Urgent Unimportant/Not urgent    In terms of priorities:\n Urgent and important Not urgenet and important Urgent and not important Not urgent and not ipmortant  The common mistake we make: elevate items in position 3 to position 1 - fail to separate those that are urgent but not important from those that truly are urgent and important (i.e, ignoring the important architecture of the system in favor of the unimportant features of the system).\nIt is the responsibility of the software development team to assert the importance of architecture over the urgency of features.\nChapter 3 Paradigm Overview  Structured Programming: remove goto - imposing discipline on direct transfer of control Object-oriented Programming: polymorphism through the disciplines use of function pointer - imposing discipline on indirect transfer of control Functional Programming: remove assignment statement (immutability) - imposing discipline upon assignment  Conclusion: We use polymorphism as the mechanism to cross architectural boundaries; we use functional programming to impose discipline on the location of and access to data; and we use structured programming as the algorithmic foundation of our modules.\nChapter 4 Sturctured Programming  It is this ability to create falsifiable units of programming that makes structured programming valuable.\n  Mathematics is the discipline of proving provable statements true; Science is the discipline of proving provable statements false  Software is like a science - we show correctness by failing to prove incorrectness, despite our best efforts. Specifically, we prove incorrectness by tests. Note that:\n such proofs of incorrectness can be applied only to provable programs. A program that is not provable (due to unrestrained use of goto) cannot be deemed correct no matter how many tests are applied to it. structures programming forces us to recursively decompose a program into a set of small provable functions. We can then use tests to try to prove those small provable functions incorrect.  Therefore, all that tests do, after sufficient testing effort, is allow us to deem a program to be correct enough for our purposes.\nFrom the smallest function to the largest component, sofwware is driven by falsifiability. Under such a perspective, software architects strive to define modules, components, and services that are easily fasifiable (testable).\n","description":"","id":92,"section":"notes","tags":["technique"],"title":"Nodes on Clean Architecture","uri":"https://nianze.ml/en/notes/2018/07/nodes-on-clean-architecture/"},{"content":"Any function may be deleted, including non-member functions and template instantiations.\nTo prevent use of certain function from being called, there is a classic approach in C++98: declare that function private and not define them.\nHowever, the fact is that this C++98 practice is really an attempt to achieve what C++11\u0026rsquo;s deleted functions actually accomplish. As an emulation, it is not as good as the real thing: it doesn\u0026rsquo;t work outside classes, it doesn\u0026rsquo;t always work inside classes, and when it does work, it may not work until link-time.\nLink-time vs compile-time failure diagnostic In C++98 practice, declaring functions private prevents clients from calling them. Due absence of function definitions, linking will fail if member functions or friends of the class try to call them. Take the copy constructor in uncopyable basic_ios class for example:\n1 2 3 4 5 6 7 8  template \u0026lt;class charT, class traits = char_traits\u0026lt;charT\u0026gt; \u0026gt; class basic_ios : public ios_base { public: ... private: basic_ios(const basic_ios\u0026amp;); // not defined  basic_ios\u0026amp; operator=(const basic_ios\u0026amp;); // not defined };   As a comparason, deleted functions may not be used in any way, so even code that\u0026rsquo;s in member and friend functions will fail to compile if it tries to copy basic_ios objects:\n1 2 3 4 5 6 7 8 9  template \u0026lt;class charT, class traits = char_traits\u0026lt;charT\u0026gt; \u0026gt; class basic_ios : public ios_base { public: ... basic_ios(const basic_ios\u0026amp;) = delete ; basic_ios\u0026amp; operator=(const basic_ios\u0026amp;) = delete; ... };   Note that by convertion, deleted functions are declared public instead of private, because C++ checks accessibility before deleted status. When client code tries to use a deleted private function, some compilers complain only about the function being private. If declaring those functions in public, we will get better error messages.\nDisable non-member functions Functions may be deleted outside classes, while private functions are always member functions inside some class. For example, we may use delete to prevent implicit numerical conversion into int for a non-member function isLucky, which takes in i\nnteger and returns whether it\u0026rsquo;s a lucky number:\n1 2 3 4  bool isLucky(int number); // original function bool isLucky(char) = delete; // reject chars bool isLucky(bool) = delete; // reject bools bool isLucky(double) = delete; // reject doubles and floats   Disable special template instantiations Suppose we want to handle specail cases of void* and char* in the processProinter template, we may simply delete those instantiations:\n1 2 3 4 5 6 7 8  t emplate\u0026lt;typename T\u0026gt; void processProinter(T* ptr); template\u0026lt;\u0026gt; void processProinter\u0026lt;void*\u0026gt;(void*) = delete; template\u0026lt;\u0026gt; void processProinter\u0026lt;char*\u0026gt;(char*) = delete;   Disable speacial member function template instanciation Since template specializations must be written at namespace scope, not class scope, we can\u0026rsquo;t adopt the C++98 convertion to disable specialization of a member function template from being called. Delete functions, however, won\u0026rsquo;t be restricted by class scope, so we can simply delete the specialization outside the class:\n1 2 3 4 5 6 7 8 9 10 11  class Widget { public: ... template\u0026lt;typename T\u0026gt; void processProinter(T* ptr) {...} ... }; template\u0026lt;\u0026gt; void Widget::processProinter\u0026lt;void\u0026gt;(void*) = delete;   ","description":"","id":93,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-11 Prefer Deleted Functions to Private Undefined Ones","uri":"https://nianze.ml/en/notes/2018/07/prefer-deleted-functions-to-private-undefined-ones/"},{"content":"Enumerators of scoped enums are visible only within the enum, convert to other types only with a cast, and always support forward-declared because their default underlying type is int.\nScope Generally speaking, declaring a name inside curly braces limits the visibility of that name to the scope defined by the braces, with one exception: the C++98-style enums, which lead to enumerator names leaking into the scope containing their enum definition, and thus have an official term - unscoped enums.\n1 2  enum Color { black, white, red }; // black, white, red are in same scope as Color auto white = false; // error! white already declared in this scope   As their new C++11 counterparts, by adding a class in declaration, scoped enums don\u0026rsquo;t leak names:\n1 2 3 4  enum class Color { black, white, red }; auto white = false; // fine. no other \u0026#34;whate\u0026#34; in scope Color c = white; // error auto c = Color::white; // fine, type of c is Color   Implicit conversion The fact that scoped enums have strong typed enumerators results in their inability to implicitly convert to integral types (and, from there, to floating-point types), which behavior is otherwise permited in terms of unscoped enums:\n1 2 3 4 5 6  Color c = Color::red; std::vector\u0026lt;std::size_t\u0026gt; primeFactors(std:size_t x); // func. returning prime factors of x ... if (c \u0026lt; 14.5) { // error! can\u0026#39;t compare Color and double  auto factors = primeFactors(c); // error! can\u0026#39;t pass Color to function expecting std::size_t }   Instead, in order to convert typefrom Color to a different type, we need a cast:\n1 2 3  if (static_cast\u0026lt;double\u0026gt;(c) \u0026lt; 14.5 ) { // odd code, but valid  auto factors = primeFactors(static_cast\u0026lt;std::size_t\u0026gt;(c)); }   Forward declaration Technically speaking, both scoped and unscoped enums may be forward-declared, except that unscoped ones need a bit of additional work - by specifying the underlying type for unscoped enums1:\n1  enum Status: std::unit8_t; // fwd decl for unscoped enum;   Since scoped enums have a default underlying type of int, forward declaration is always supported:\n1 2  enum class Status; // forward declaration void continueProcessing(Status s); // use of fwd-declared enum   With the help of forward declaration, the header containing the declarations requires no recompilation if Status\u0026rsquo;s definition is revised. Furthermore, it is also possible that continueProcessing\u0026rsquo;s implementation need not be recompiled2.\nTwist There\u0026rsquo;s still some situation where unscoped enums may be useful: when referring to fields within C++11\u0026rsquo;s std::tuples. Suppose we have a tuple holding values for the name, email address, and reputation value for a user at a social networking website:\n1 2 3 4  using UserInfo = // type alias  std::tuple\u0026lt;std::string // name  std::string // email  std::size_t\u0026gt; // reputation   To get field value, using an unscoped enum to associate names with field numbers may be helpful:\n1 2 3 4  enum UserInfoFields { uiName, uiEmail, uiReputation }; UserInfo uInfo; ... auto val = std::get\u0026lt;uiEmail\u0026gt;(uInfo); // implicit conversion from UserInfoFields to std::size_t   To mimic the similar behavior, using scoped enums is more verbose:\n1 2 3  enum class UserInfoFields { uiName, uiEmail, uiReputation }; ... auto val = std::get\u0026lt;static_cast\u0026lt;std::size_t\u0026gt;(UserInfoFields::uiEmail)\u0026gt;(uInfo);   To save some typing, we might consider define a helper function, or in a more generalized form, a function template toUType that takes an arbitrary enumerator and return its value as a compile-time constant:\n1 2 3 4 5 6  template\u0026lt;typename E\u0026gt; constexpr typename std::underlying_type\u0026lt;E\u0026gt;::typename // see item 9 for info on type traits  toUType(E enumerator) noexcept { return static_cast\u0026lt;typename std::underlying_type\u0026lt;E\u0026gt;::type\u0026gt;(enumerator); }   In C++14, we may simplify the toUType to a sleeker form:\n1 2 3 4 5  template\u0026lt;typename E\u0026gt; constexpr auto toUType(E enumerator) noexcept { return static_cast\u0026lt;std::underlying_type_t\u0026lt;E\u0026gt;\u0026gt;(enumerator); }   And then we access a field of the tuple like this:\n1  auto val = std::get\u0026lt;toUType(\u0026lt;UserInfoFields::uiEmail)\u0026gt;(uInfo);   Still more to write than use of the unscoped enum, but it also avoids namespace pollution and inadvertent conversions involving enumerators, so those extra characters might still be a reasonable to pay for.\n Since there is no default underlying type for unscoped enums, to make it possible for compilers to select an underlying type for each enum prior to the enum being used, C++98 supports only enum definitions (when all enumerators are listed), while enum declarations are not allowed.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n This happens if Status is modified (e.g., add a new enumerator), but continueProcessing\u0026rsquo;s behavior is unaffected (e.g., the function doesn\u0026rsquo;t use the newly added enumerator).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":94,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-10 Prefer Scoped enums to Unscopded enums","uri":"https://nianze.ml/en/notes/2018/07/prefer-scoped-enums-to-unscopded-enums/"},{"content":"Alias declaration support templatization, which avoids the \u0026ldquo;::type\u0026rdquo; suffix and \u0026ldquo;typename\u0026rdquo; prefix often required to refer typedefs.\nCompared with typedef, alias declarations have following advantages:\nEasier to understand 1 2 3  typedef void (*FP)(int, const std::string\u0026amp;); // same meaning as above using alias declaration using FP = void (*)(int, const std::string\u0026amp;);   Support for template Alias declarations may be templatized (called alias templates), while typedefs cannot. For example, suppose we want to define a synonym for a linked list that uses a custom allocator MyAlloc:\n1 2 3 4 5 6 7 8 9 10  template\u0026lt;typename T\u0026gt; using MyAllocList = std::list\u0026lt;T, MyAlloc\u0026lt;T\u0026gt;\u0026gt;; // client code MyAllocList\u0026lt;std::string\u0026gt; ls; template\u0026lt;typename T\u0026gt; class Widget { // Widget contains a MyAllocList\u0026lt;T\u0026gt; as a data member private: typename MyAllocList\u0026lt;T\u0026gt; list; }   With a typedef, to support template, we need the trick to nest typedef inside templatized structs:\n1 2 3 4 5 6 7  template\u0026lt;typename T\u0026gt; struct MyAllocList { typedef std::list\u0026lt;T, MyAlloc\u0026lt;T\u0026gt;\u0026gt; type; }; // client code MyAllocList\u0026lt;Widget\u0026gt;::type lw;   To make things worse, when using the typedef inside a template class, we have to precede the typedef name with typename, so that compilers get comfirmed that MyAllocList\u0026lt;T\u0026gt;::type refers to a type, instead of a data member named type inside MyAllocList:\n1 2 3 4 5  template\u0026lt;typename T\u0026gt; class Widget { private: typename MyAllocList\u0026lt;T\u0026gt;::type list; }   Type traits supported by alias templates in C++14\nWhen we need to take template type parameters and create revised types from them(e.g., turn Widget into Widget\u0026amp;), we perform these kinds of transformations through type traits. Since type traits in C++11 are implemented as nested typedefs inside templatized structs, C++14 provides corresponding alias templates:\n1 2 3 4 5 6 7 8  std::remove_const\u0026lt;T\u0026gt;::type // C++11: const T -\u0026gt; T std::remove_const_t\u0026lt;T\u0026gt; // C++14 equivalent  std::remove_reference\u0026lt;T\u0026gt;::type // C++11: T\u0026amp;/T\u0026amp;\u0026amp; -\u0026gt; T std::remove_reference_t\u0026lt;T\u0026gt; // C++14 equivalent  std::add_lvalue_reference\u0026lt;T\u0026gt;::type // C++11: T -\u0026gt; T\u0026amp; std::add_lvalue_refernece_t\u0026lt;T\u0026gt; // C++14 equivalent   Basically what C++14 adds is simply some code like this:\n1 2 3 4 5 6  template \u0026lt;class T\u0026gt; using remove_const_t = typename remove_const\u0026lt;T\u0026gt;::type; template \u0026lt;class T\u0026gt; using remove_reference_t = typename remove_reference\u0026lt;T\u0026gt;::type; template \u0026lt;class T\u0026gt; using add_lvalue_reference_t = typename add_lvalue_reference\u0026lt;T\u0026gt;::type;   ","description":"","id":95,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-9 Prefer Alias Declarations to Typedefs","uri":"https://nianze.ml/en/notes/2018/07/prefer-alias-declarations-to-typedefs/"},{"content":"nullptr doean\u0026rsquo;t suffer from the overloading problem or the template deduction problem that 0 and NULL are susceptible to. It also improves code clarity.\nIn C++98, a null pointer can be represented by an int 0 or NULL1, which introduses some controdiction between the apparent meaning (mean to refer to a null pointer) and actual meaning (the representation is some kind of integer). Neither 0 nor NULL has a pointer type - it\u0026rsquo;s just that C++ will (reluctently) interpret them as a null pointer in the context where a pointer a pointer is wanted but can\u0026rsquo;t be found.\nThat\u0026rsquo;s why nullptr is introduced: its type is not integral, but std::nullptr_t2, which could be treated as a pointer of all types due to its ability to implicitly convert to all raw pointer types.\nCompared with 0 and NULL, the obvious advantages shown by nullptr is its better support for overloading and template, as well as its improved code clarity.\nOverloading 1 2 3 4 5 6 7  void f(int); void f(bool); void f(void*); f(0); // calls f(int) f(NULL); // might not compile, but typically calls f(int), never calls f(void*) f(nullptr); // calls f(void*)   Template Inside a template, if an int or NULL (which is int-like type) is being passed to a function that requires a pointer, type errors occur:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // call these only then approriate mutix is locked int f1(std::shared_ptr\u0026lt;Widget\u0026gt; spw); int f2(std::unique_ptr\u0026lt;Widget\u0026gt; upw); bool f3(Widget* pw); template\u0026lt;typename FuncType, typename MuxType, typename PtrType\u0026gt; declType(auto) lockAndCall(FuncType func, // C++14  MuxType\u0026amp; mutex PtrType ptr) { using MuxGuard = std::lock_guard\u0026lt;std::mutex\u0026gt;; MuxGuard g(mutex); // lock mutex for func  return func(ptr); // pass ptr (pointer type) to func } // unlock mutex  std::mutex f1m, f2m, f3m; auto result1 = lockAndCall(f1, f1m, 0); // error auto result2 = lockAndCall(f2, f2m, NULL); // error auto result3 = lockAndCall(f3, f3m, nullptr); // fine   In contrast, here, when nullptr is passed to lockAndCall, the type for ptr is deduced to be std::nullptr_t instead of previous int (or int-like one), and when ptr is passed to f3, there is an implicit conversion from std::nullptr_t to Widget*.\nCode clarity Using 0, the return type may not be obvious, is it an integral type or a pointer type?\n1 2 3 4  auto result = findRecord(/* args. */); if (result == 0) { ... }   There\u0026rsquo;s no ambiguity when using nullptr:\n1 2 3 4  auto result = findRecord( /* args */ ); if (result == nullptr) { ... }    There is some leeway regarding the implementaition of the type of NULL - possibly, NULL will be defined to be 0L as a long.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n std::nullptr_t, techniquely, is not a pointer type. The type is in a circular definition: std::nullptr_t is defined to be the type of nullptr.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":96,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-8 Prefer Nullptr to 0 and NULL","uri":"https://nianze.ml/en/notes/2018/07/prefer-nullptr-to-0-and-null/"},{"content":"Braced initialization is the most widely usable initialization syntax, which can also prevent narrowing conversions, as well as being immune to C++\u0026rsquo;s most vexing parse.\nThe good part Syntacticly widest usage Syntax choices for object initialization in C++11 are confusing to support 3 forms: parentheses, equal signs, and braces.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  int x(0); // initializer with parentheses int y = 0; // initializer with \u0026#34;=\u0026#34; int z{ 0 }; // initializer with braces int zz = {0}; // initializer with \u0026#34;=\u0026#34; and braces, treated the same as braces-only version.  Widget w1; // default ctor. Widget w2 = w1; // copy ctor w1 = w2; // assignment, calls copy operator=  // easy to specify the init. content of a container std::vector\u0026lt;int\u0026gt; v{ 1, 3, 5 }; // v\u0026#39;s init. content is 1, 3, 5  // specify default init. value for non-static data members, where parentheses not allowed class Widget { ... private: int x{ 0 }; // fine  int y = 0; // fine  int z(0); // error }; // specify init. value for uncopyable objects (EMCpp item 40), where \u0026#34;=\u0026#34; not allowed std::atomic\u0026lt;int\u0026gt; ai1{ 0 }; // fine std::atomic\u0026lt;int\u0026gt; ai2(0); // fine std::atomic\u0026lt;int\u0026gt; ai3 = 0; // error   From the example above, it\u0026rsquo;s easy to see why braced initialization is called \u0026ldquo;uniform\u0026rdquo; - a single initialization syntax that aims to be used anywhere and express everything.\nPreventing narrowing conversion Braced initialization prohibits implicit narrowing conversions among built-in types:\n1 2 3 4 5  double x, y, z; ... int sum1{ x + y + z }; // error int sum2(x + y + z); // okay to truncate value of expression to an int int sum3 = x + y + z; // ditto   Immune to most vexing parse Most vexing parse: anything that can be parsed as a declaration must be interpreted as one. This may be annoying when developers want to default-construct an object, but inadvertently end up declaring a function instead. Using braces, we don\u0026rsquo;t have such an issue:\n1 2 3  Widget w1(10); // call Widget ctor with arg. 10 Widget w2(); // intend to call a Widget const. with zero arg., end up declaring a func. named w2 that returns a Widget Widget w3{}; // calls Widget ctor with no args.   The not-so-good part Unintuitive behavior with auto As EMCpp item 2 explains, when an auto-declared variable has a braced initializer, the type deduced is std::initializer_list, which may lead to surprising behaviors sometimes.\n(Too) high overloading priority Calls using braced initialization syntax strongly prefer the overloads taking std::initializer_lists: if there\u0026rsquo;s any way for compilers to construe a call using a braced initializer to be to a constructor taking a std::initializer_list, compilers will employ that interpretation:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Widget { public: Widget(int i, bool b); Widget(int i, double d); Widget(std::initializer_list\u0026lt;long double\u0026gt; il); operator float() const; // convert to float  ... }; Widget w1(10, true); // calls first ctor. Widget w2{10, true}; // calls std::initializer_list ctor, 10 and true convert to long double Widget w3(10, 5.6); // calls second ctor Widget w4{10, 5.6}; // calls std::initializer_list ctor, 10 and 5.6 convert to long double Widget w5(w4); // calls copy ctor Widget w6{w4}; // calls std::initializer_list ctor, w4 converts to float, and float converts to long double Widget w7(std::move(w4)); // calls move ctor Widget w8{std::move(w4)}; // calls std::initializer_list ctor, same conversion as w6   The priority is so high that it prevails even if the best-match std-initializer_list constructor can\u0026rsquo;t be called:\n1 2 3 4 5 6 7 8 9  class Widget { public: Widget(int i, bool b); Widget(int i, double d); Widget(std::initializer_list\u0026lt;bool\u0026gt; il); // no implicit conversion funcs  ... }; Widget w{10, 5.0}; // error: requires narrowing conversions. The other callable ctors is shadowed   Only if there\u0026rsquo;s no way to convert the types of the arguments in a braced initializer to the type in a std::initializer_list do compilers fall back on normal overload resolution:\n1 2 3 4 5 6 7 8 9 10 11 12  class Widget { public: Widget(int i, bool b); Widget(int i, double d); Widget(std::initializer_list\u0026lt;std::string\u0026gt; il); // no implicit conversion funcs  ... }; Widget w1(10, true); // calls first ctor Widget w2{10, true}; // calls first ctor Widget w3(10, 5.0); // calls second ctor Widget w3{10, 5.0}; // calls second ctor   Edge case: Empty braces mean no arguments, not an empty std::initializer_list. For example\n1 2 3 4 5 6 7 8 9 10 11  class Widget { public: Widget(); Widget(std::initializer_list\u0026lt;int\u0026gt; il); // no implicit conversion funcs  ... }; Widget w1; // calls default ctor Widget w2(); // calls default ctor Widget w3{}; // calls default ctor Widget w4({}); // calls std::initializer_list ctor with empty list   ","description":"","id":97,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-7 Distinguish Betwenn () and {} When Creating Objects","uri":"https://nianze.ml/en/notes/2018/07/distinguish-betwenn-and-when-creating-objects/"},{"content":"“Invisible” proxy types can cause auto to deduce the undesired type for an initializing expression, so we can adopt explicitly typed initializer idiom to force auto to deduce what we want.\nSome proxy classe are designed to be apparent to clients, such as std::shared_ptr, and std::unique_ptr. Other proxy classes are designed to at more or less invisibly, such as std::vector\u0026lt;bool\u0026gt;::reference, and std::bitset::reference.\nFor example, suppose we have a function that takes a Widget and returns a std::vector\u0026lt;bool\u0026gt;, where each bool indicates whether the Widget offers a particular feature:\n1  std::vector\u0026lt;bool\u0026gt; features(const Widget\u0026amp; w);   Now we want to check the value of bit 5, which indicates whether the Widget has high priority:\n1 2 3 4 5  Widget w; ... bool highPriority = features(w)[5]; // is w high priority ? ... processWidget(w, highPriority); // process w in accord with its priority   However, if we change the explicit type for highPriority with auto:\n1 2  auto highPriority = features(w)[5]; processWidget(w, highPriority); // undefined behavior!   The undefined behavior is caused by the fact that highPriority contains dangling pointer. And here is what happened:\n features returns a temporary std::vector\u0026lt;bool\u0026gt; object (let\u0026rsquo;s call it temp), which is specified to represent its bools in packed form, one bit per bool. operator[] is invokes on temp, and returns a std::vector\u0026lt;bool\u0026gt;::reference object (an invisible proxy), which contains a pointer to a word in the data structure holding the bits that are managed by temp, plus the offset into that word corresponding to bit 51 auto deduces std::vector\u0026lt;bool\u0026gt;::reference as the tpe of highPriority, and bind highPriority to a copy of this std::vector\u0026lt;bool\u0026gt;::reference object at the end of the statement, temp is destroyed. Therefore, as a copy, highPriority contains a dangling pointer, leading to undefined behavior in the call to processWidget.  Now is the time we adopt the explicitly typed initializer idiom: we declare a variable with auto, but casting the initialization expression to the type we want auto to deduce:\n1  auto highPriority = static_cast\u0026lt;bool\u0026gt;(features(w)[5]);   At this time, the std::vector\u0026lt;bool\u0026gt;::reference object returned from std::vector\u0026lt;bool\u0026gt;::operator[] executes the conversion to bool it supports, and as part of that conversion, the still-valid pointer to temp (the std::vector\u0026lt;bool\u0026gt; object returned from features) is dereferenced, and the index 5 is then applied to the bits pointed to by the ponter, and the bool value that emerges is used to initialize highPriority - therefore, undefined behavior is avoided.\n C++ forbids references to bits, so in the case where T is bool, operator[] for std::vector\u0026lt;T\u0026gt; cannot return bool\u0026amp; in packed form. That\u0026rsquo;s why the proxy is introduced here to make the return value act like a bool\u0026amp;.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":98,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-6 Use the Explicitly Typed Initializer Idiom when auto deduces undesired types","uri":"https://nianze.ml/en/notes/2018/07/use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types/"},{"content":"Despite some pitfalls described in EMCpp item 2 and 6, auto variables are preferred for they must be initialized, are generally immune to type mismatches that can lead to portability or efficiency problems, can ease the process of refactoring, and typically require less typing than variables with explicitly specified types.\nAvoidance of Uninitialized variables auto variavbles have their type deduced from their initializer, so they must be initialized.\n1 2 3  int x1; // potentially unintialized auto x2; // error! initializer required auto x3 = 0; // fine, x3\u0026#39;s value is well-defined   Avoidance of Syntactic Verbosity In order to express the type of the value pointed to by an iterator, without auto, we may write like this:\n1 2 3 4 5 6 7 8  template\u0026lt;typename It\u0026gt; void dwim(It b, It e) // \u0026#34;do what I mean\u0026#34;. for all elements in range from b to e { for (; b != e; ++b) { typename std::iterator_traits\u0026lt;It\u0026gt;::value_type currValue = *b; ... } }   Thanks to auto, now we can declare a local variable whose value is that of a dereferenced iterator with ease:\n1 2 3 4 5 6 7 8  template\u0026lt;typename It\u0026gt; void dwim(It b, It e) { for (; b != e; ++b) { auto currValue = *b; ... } }   Ability to Hold Closure Because auto uses type deduction, it can represent types known only to compilers, such as lambda expressions:\n1 2 3 4 5  // C++14 auto derefLess = // comparison func. for values pointed  [](const auto\u0026amp; p1, // to by anything pointer-like  const auto\u0026amp; p2) { return *p1 \u0026lt; *p2; };   or in C++11, a little more verbose:\n1 2 3 4 5  // C++11 doesn\u0026#39;t support auto for parameters to lambda, so more verbose. auto derefUPLess = // comparison func. for Wdigets pointed  [](const std::unique_ptr\u0026lt;Widget\u0026gt;\u0026amp; p1, // to by std::unique_ptr  const std::unique_ptr\u0026lt;Widget\u0026gt;\u0026amp; p2) { return *p1 \u0026lt; *p2; };   Without using auto, since lambda expressions yield closures, which are callable objects, we can store them in std::function objects:\n1 2 3 4 5  std::function\u0026lt;bool(const std::unique_ptr\u0026lt;Widget\u0026gt;\u0026amp;, bool(const std::unique_ptr\u0026lt;Widget\u0026gt;\u0026amp;)\u0026gt; derefUPLess = [](const std::unique_ptr\u0026lt;Widget\u0026gt;\u0026amp; p1, // comparison func. for Wdigets pointed  const std::unique_ptr\u0026lt;Widget\u0026gt;\u0026amp; p2) // to by std::unique_ptr  { return *p1 \u0026lt; *p2; };   As we can see, syntactic verbosity makes auto a preferred choice. Besides that, there are two more reasons to choose auto:\n std::function object typically uses more memory than the auto-declared object1. invoking a closure via a std::function object is almost certain to be slower than calling it via an auto-declared object2.  In summary, auto wins the competition between auto and std::function for holding a closure.\nAvoidance of Unexpected Implicit Conversions Consider this code:\n1 2 3 4 5 6  std::unordered_map\u0026lt;std::string, int\u0026gt; m; ... for (const std::pair\u0026lt;std::string, int\u0026gt;\u0026amp; p : m) { ... }   This looks perfectly reasonable, but there\u0026rsquo;s a problem: the key part of a std::unorderd_map is const, so the type of std::pair in the hash table isn\u0026rsquo;t std::pair\u0026lt;std::string, int\u0026gt;, but std::pair\u0026lt;const std::string, int\u0026gt;. Since the constness hasn\u0026rsquo;t been declared for the variable p in the loop, compilers will create a temporary object of the type that p wants to bind to by coping each object in m, then binding the reference p to that temporary object, and finally destroy the temporary at the end of each loop iteration. This is almost certain to be an unwanted behavior - we probably intend to simply bind the reference p to each element in m directly.\nSuch unintentional type mismatches can be autoed away:\n1 2 3 4  for (auto\u0026amp; p : m) { ... }   Avoidance of Explicit Type Revising during Refactoring auto types automatically change if the type of their initializing expression changes, and that means that some refactoring (e.g., change the return type of a function from int to long) are facilitated by the use of auto:\n if the results of calling the function are stored in auto variables, the calling code automatically updates itself the next time we compile if the results are stored in varibles explicitly declared to be int, we have to find all the call sites so that we can revise them.   An auto-declared variable holding a closure has the same type as the closure, and uses only as much memory as the closure requires. The type of a std::function-declared variable holding a closure is an instantiation of the std::function template, and that has a fixed size for any given signature. When this size is not adequate for the closure, std::function constructor will allocate heap memory to store the closure - leading to typical result that std::function object uses more memory than the auto-declared object.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n This slowness comes from the implementation details of std::function, which restrict inlining and yield indirect function calls.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":99,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-5 Prefer Auto to Explicit Type Declarations","uri":"https://nianze.ml/en/notes/2018/07/prefer-auto-to-explicit-type-declarations/"},{"content":"Deduced types can often be seen using IDE editors, compiler error messages, and the Boost TypeIndex library, but the results of some tools may be neither helpful nor accurate.\nDependending on the phase of the software development process, we might get type deduction information during coding, compilation, and runtime.\nIDE Editors Code editors in IDEs often show the types of program entities when we hover our cursor over the entity. In order for the IDE to offer this kind of information, our code must be in a more or less compilable state. Moreover, when more complicated types are involved, the information displayed by IDEs may not be helpful.\nCompiler Diagnostics We can get a compiler to show what it deduced for a type by causing a compilation problem using that type:\n1 2  template\u0026lt;typename T\u0026gt; // Declaration only. class TD; // TD == \u0026#34;Type Displayer\u0026#34;.   1 2 3 4 5 6  const int theAnser = 42; auto x = theAnswer; auto y = \u0026amp;theAnswer; TD\u0026lt;decltype(x)\u0026gt; xType; TD\u0026lt;decltype(y)\u0026gt; yType;   For the code above, since there\u0026rsquo;s no template definition to instantiate, compiler will yield the error messages like this:\n1 2  error: \u0026#39;xType\u0026#39; uses undefined class \u0026#39;TD\u0026lt;int\u0026gt;\u0026#39; error: \u0026#39;yType\u0026#39; uses undefined class \u0026#39;TD\u0026lt;const int *\u0026gt;\u0026#39;   Through these errors, we get useful type information.\nRuntime Output Consider a more complex example involving a user-defined type (Widget), an STL container(std::vector), and an auto variable (vm), which is more representative of the situation where we want to see deduced type information:\n1 2 3 4 5 6 7 8 9 10  template\u0026lt;typename T\u0026gt; // template function to void f(const T\u0026amp; param); // be called  std::vector\u0026lt;Widget\u0026gt; createVec(); // factory function const auto vw = createVec(); // init vm with factory return  if (!vm.empty()) { f(\u0026amp;vm[0]); // call f  ... }   This time, if we want to see what type is deduced for T and param, the type information displayed by IDE editors is not reliably useful. For example, the deduced type for T is shown as:\n1  conststd::_Simple_types\u0026lt;std::_Wrap_alloc\u0026lt;std::_Vec_base_types\u0026lt;Widget,std::allocator\u0026lt;Widget\u0026gt; \u0026gt;::_Alloc\u0026gt;::value_type\u0026gt;::value_type *   and the param\u0026rsquo;s type is:\n1  const std::_Simple_types\u0026lt;...\u0026gt;::value_type *const \u0026amp;   In order to create a textual representation of the type we care about and print it out on screen, we might consider the Boost TypeIndex library1. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;boost/type_index.hpp\u0026gt;template\u0026lt;typename T\u0026gt; void f(const T\u0026amp; param) { using std::cout; using boost::typeindex::type_id_with_cvr; // show T  cout \u0026lt;\u0026lt; \u0026#34;T = \u0026#34; \u0026lt;\u0026lt; type_id_with_cvr\u0026lt;T\u0026gt;().pretty_name() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // show param\u0026#39;s type  cout \u0026lt;\u0026lt; \u0026#34;param = \u0026#34; \u0026lt;\u0026lt; type_id_with_cvr\u0026lt;decltype(param)\u0026gt;().pretty_name() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; ... }   Under compilers from GNU and Clang, Boost.TypeIndex produces this accurate output:\n1 2  T = Widget const* param = Widget const* const\u0026amp;    There is something similar called typeid and std::type_info::name in Standard C++ that could also display the type, but the output text may not be straightforward (for example, using \u0026ldquo;PK\u0026rdquo; to stand for \u0026ldquo;pointer to const\u0026rdquo;) and might not be reliable.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":100,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-4 Know How to View Deduced Types","uri":"https://nianze.ml/en/notes/2018/07/know-how-to-view-deduced-types/"},{"content":"decltype almost always yields the type of a variable or expression without any modifications. For lvalue expressions of type T other than names, decltype always reports a type of T\u0026amp;.\nThe primary use of decltype is declaring function templates where the function\u0026rsquo;s return type depends on its parameter types. For example, the indexing operator [] on a containedr of objects of type T typically return T\u0026amp;, but in the case of std::vector\u0026lt;bool\u0026gt;, operator[] returns a brand new object (refer to EMCpp item 6 for whys and hows). In order to let compiler deduce the return type, we can use decltype:\n1 2 3 4 5 6 7  // C++14 version template\u0026lt;typename Container, typename Index\u0026gt; decltype(auto) authAndAccess(Container\u0026amp;\u0026amp; c, Index i) { authenticateUser(); return std::forward\u0026lt;Container\u0026gt;(c)[i]; }   A few points worth noting here:\n  return type is decltype(auto)1 instead of auto. As EMCpp item 2 points out, compilers employ template type deduction for functions with an auto return type. If using auto, the reference-ness will be stripped off, so T\u0026amp;, which is the type returned by operator[] in most cases, will be deduced as T. This is not what we want.\n  universal refrences for the first parameter is used here. As EMCpp item 24 explains, this makes the reference paramter c be able to bind to both lvalues and rvlues2. Following the exmpale of the Standard Library for index values, we stick with pass-by-value for i though.\n  the std::forward is applied to the universal reference in accord with EMCpp item 25\u0026rsquo;s admonition.\n  in C++11, auto is not permitted as return types for non-lambda functions, so we need the trailing return type syntax to tell the compiler that the function\u0026rsquo;s return type will be declared following the parameter list (after the \u0026ldquo;-\u0026gt;\u0026quot;), which give us the advantage to use the function\u0026rsquo;s parameters (c and i here) in the specification of the return type:\n1 2 3 4 5 6 7 8  // C++11 version template\u0026lt;typename Container, typename Index\u0026gt; auto authAndAccess(Container\u0026amp;\u0026amp; c, Index i) -\u0026gt; decltype(std::forward\u0026lt;Container\u0026gt;(c)[i]) { authenticateUser(); return std::forward\u0026lt;Container\u0026gt;(c)[i]; }     Exceptions As mentioned in the begining, decltype almost always produces the type we expect - it means that there are exceptions to the rule. We\u0026rsquo;re unlikely to encounter these exceptions unless we\u0026rsquo;re a heavy-duty library implementer.\nFor example, decltype generally ensures that the type induced for lvalue expressions more complicated than names is an lvalue reference. Since the type of most lvalue expressions inherently includes an lvalue reference qualifier (for example, functions returning lvalues always return lvalue references), this property seldom has any impact. However, a seemingly trivial change in the way we write a return statement can affect the deduced type for a function:\n1 2 3 4 5 6 7 8 9 10 11 12 13  decltype(auto) f1() { int x = 0; ... return x; // decltype(x) is int, so f1 returns int } decltype(auto) f2() { int x = 0; ... return (x); // decltype((x)) is int\u0026amp;, so f1 returns int\u0026amp; }   C++ defines the expression (x) to be an lvalue, which is also an expression more complicated than a variable name x, so decltype((x)) is int\u0026amp;, leading to different return types in f1 and f2. Moreover, f2 returns a reference to a local variable, which means undefined behavior that we don\u0026rsquo;t want.\nSummary The lesson we learn from the above example is to pay close attention when using decltype(auto). The techniques described in EMCpp item 4 may help ensure that the deduced type is what we expect.\nMeanwhile, don\u0026rsquo;t lose sight of the bigger picture: in most normal cases where decltype is applied to names, decltype does just what it sounds like: it reports that name\u0026rsquo;s declared type.\n The use of decltype(auto) is not limited to function return types. We can use is for declaring variables. For example, given const Widget\u0026amp; type variable cw, auto myWidget1 = cw; will employ auto type deduction and deduce myWidget1 as type of Widget, while decltype(auto) myWidget2 = cw; uses decltype type deduction, leading to myWidget2\u0026rsquo;s type as const Widget\u0026amp;.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Supporting the use of rvalue is basically supporting such a function that a client might simply make a copy of an element in the temporary container. Otherwise, an rvalue container (a.k.a. a temporary object) would typically be destroyed at the end of the statement containing the call to authAndAccess, which means that a reference to an element in that container (typically what authAndAccess would return in the most cases) would dangle at the end of the statement.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":101,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-3 Understand Decltype","uri":"https://nianze.ml/en/notes/2018/07/understand-decltype/"},{"content":"auto type deduction is usually the same as template type deduction, with an exception in the case of braced initializer. Also, in C++14, as a function return type or a lambda parameter, auto implies template type deduction instead of auto type deduction.\nWith only one curious exception, auto type deduction is template type deduction. In the case of general function template form and its general function call:\n1 2 3  template\u0026lt;typename T\u0026gt; void f(ParamType param); f(expr); // general call   compilers use expr to deduce types for T and ParamType. Similarly, in the case where a variable is declared using auto, auto plays the role of T, and the type specifier for the variable acts as ParamType.\nTherefore, there are also three cases based on the type specifier:\n Case 1: the type specifier is a pointer or reference, but not a universal reference Case 2: the type specifier is a universal reference Case 3: the type specifier is neither a pointer nor a reference  For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  auto x = 27; // case 3. type specifier is simply auto by itself. const auto cx = x; // case 3. type specifier is const auto. const auto\u0026amp; rx = x; // case 1. type specifier is const auto\u0026amp;. // case 2: auto\u0026amp;\u0026amp; uref1 = x; // x is int and lvalue, so uref1\u0026#39;s type is int\u0026amp; auto\u0026amp;\u0026amp; uref2 = cx; // cx is const int and lvalue, so uref2\u0026#39;s type is const int\u0026amp; auto\u0026amp;\u0026amp; uref3 = 27; // 27 is int and rvlue, so uref3\u0026#39;s type is int\u0026amp;\u0026amp; // array and function names decay into pointers for non-ref type specifiers: const char name[] = \u0026#34;R. N. Briggs\u0026#34;; // name\u0026#39;s type is const char [13] auto arr1 = name; // arr1\u0026#39;s type is const char* auto\u0026amp; arr2 = name; // arr2\u0026#39;s type is const char (\u0026amp;)[13] void someFunc(int, double); // someFunc is a function, type is void(int, double) auto func1 = someFunc; // func1\u0026#39;s type is void (*)(int, double) auto\u0026amp; func2 = someFunc; // func2\u0026#39;s type is void (\u0026amp;)(int, double)   Exception: uniform initialization C++98 provides two syntactic choices when we want to declare an int with an initial value:\n1 2  int x1 = 27; int x2(27);   By introducing uniform initialization, C++11 adds these two forms:\n1 2  int x3 = { 27 }; int x4{ 27 };   As EMCpp 5 explains, there are advantages to declare variables using auto, so we may prefer:\n1 2 3 4  auto x1 = 27; // type is int, value is 27 auto x2(27); // ditto auto x3 = { 27 }; // type is std::initializer_list\u0026lt;int\u0026gt;, value is {27} auto x4{ 27 }; // ditto   However, after this modification, while the first two statements do declare a variable of type int with value 27, the second two actually declare a variable of type std::initializer_list\u0026lt;int\u0026gt; containing a single element with value 27.\nIn fact, when an auto-declared variable is initialized with a braced initializer, auto will assume that the braced initilizer represents a std::initializer_list, which itself is a template for some type T, so there are actually two kinds of type deduction taking place:\n auto type deduction: the type is an instantiation of std::initializer_list template type deduction: the type T in std::initializer_list\u0026lt;T\u0026gt;  The only real difference between auto and template type deduction is the assumption that a braced initializer represents a std::initializer_list. This lead to some interesting results:\n1 2 3 4 5 6 7 8 9  auto x = { 11, 23, 9 }; // x\u0026#39;s type is std::initializer_list\u0026lt;int\u0026gt;  template\u0026lt;typename T\u0026gt; void f1(T param); f1({ 11, 23, 9 }); // error! can\u0026#39;t deduce type for T. Do not recognise the type for braced initializer  template\u0026lt;typename T\u0026gt; void f2(std::initializer_list\u0026lt;T\u0026gt; initList); f({ 11, 23, 9 }); // T deduced as T, and initList\u0026#39;s type is std::initializer_list\u0026lt;int\u0026gt;   More exceptions in C++14 C++14 permits to use auto as a function\u0026rsquo;s return type as well as in lambda parameter declarations. However, these uses of auto employ tamplate type deduction, not auto type deduction - so a braced initializer won\u0026rsquo;t imply the type of std::initializer_list automatically, and following statement won\u0026rsquo;t compile:\n1 2 3 4 5 6 7 8 9 10 11 12  // auto in return type auto createInitList() { return { 1, 2, 3 }; // error: can\u0026#39;t deduce type for { 1, 2, 3 } } // auto in a parameter type specification in a C++14 lambda std::vector\u0026lt;int\u0026gt; v; ... auto resetV = [\u0026amp;v](const auto\u0026amp; newValue) { v = newValue; }; // C++14 lambda, second auto is in parameter list ... resetV({ 1, 2, 3 }); // error: can\u0026#39;t deduce type for { 1, 2, 3 }   ","description":"","id":102,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-2 Understand Auto Type Deduction","uri":"https://nianze.ml/en/notes/2018/07/understand-auto-type-deduction/"},{"content":"There are three sets of rules for type deduction in modern C++: one for function templates, one for auto, and one for decltype. Without a solid understanding of how deduction operates, effective programming in modern C++ is all but impossible.\nSince type deduction for templates is the basis of that for auto, it\u0026rsquo;s important to truly understand the aspects of template type deduction that auto builds on: during template type deduction, there are three cases for parameter types:\n pointer type or non-universal reference type universal reference type neither a pointer nor a reference (value type)  Moreover, there\u0026rsquo;s a niche case worth knowing about, that arguments that are array or function names decay to pointers unless they\u0026rsquo;re used to initialize references.\nTo tell the difference, let\u0026rsquo;s think of a function template as looking like this:\n1 2 3  tempalte\u0026lt;typename T\u0026gt; void f(ParamType param); f(expr); // deduce T and ParamType from expr   Case 1: ParamType is Reference or Pointer, but not a Universal Reference The rules in this case works like this:\n If expr\u0026rsquo;s type is a reference, ignore the reference part. Then pattern-match expr\u0026rsquo;s type against ParamType to determine T.  For example,\n1 2 3 4 5 6 7 8 9 10  template\u0026lt;typename T\u0026gt; void f(T\u0026amp; param); // param is a reference  int x = 27; // x is an int const int cx = x; // cx is a const int const int\u0026amp; rx = x; // rx is a refrence to x as a const int  f(x); // T is int, param\u0026#39;s type is int\u0026amp; f(cx); // T is const int, param\u0026#39;s type is const int\u0026amp; f(rx); // T is const int, param\u0026#39;s type is const int\u0026amp;   Note that even though rx\u0026rsquo;s type is a reference, T is deduced to be a non-reference, because rx\u0026rsquo;s reference-ness is ignored during type deduction.\n1 2 3 4 5 6  template\u0026lt;typename T\u0026gt; void f(const T\u0026amp; param); // param is now a ref-to-const,  // so there\u0026#39;s no longer a need for const to be deduced as part of T f(x); // T is int, param\u0026#39;s type is const int\u0026amp; f(cx); // T is int, param\u0026#39;s type is const int\u0026amp; f(rx); // T is int, param\u0026#39;s type is const int\u0026amp;   As before, rx\u0026rsquo;s reference-ness is ignored during type deduction.\n1 2 3 4 5 6 7 8  template\u0026lt;typename T\u0026gt; void f(T* param); // param is now a pointer  int x = 27; // x is an int const int *px = \u0026amp;x; // px is a ptr to x as a const int  f(\u0026amp;x); // T is int, param\u0026#39;s type is int* f(px); // T is const int, param\u0026#39;s type is const int*   As shown above, when param were a pointer (or a pointer to const), things work essentially the same way.\nCase 2: ParamType is a Universal Reference Things are less obvious for templates taking universal reference paramters:\n If expr is an lvalue, both T and ParamType are deduced to be lvalue references. If expr is an rvalue, the \u0026ldquo;normal\u0026rdquo; (i.e., case 1) rules apply.  For example:\n1 2 3 4 5 6 7 8 9 10 11  template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); // param is now a universal reference  int x = 27; // as before const int cx = x; // as before const int\u0026amp; rx = x; // as before  f(x); // x is lvalue, so T is int\u0026amp;, param\u0026#39;s type is also int\u0026amp; f(cx); // x is lvalue, so T is const int\u0026amp;, param\u0026#39;s type is also const int\u0026amp; f(rx); // x is lvalue, so T is const int\u0026amp;, param\u0026#39;s type is also const int\u0026amp; f(27); // x is rvlaue, so T is int, param\u0026#39;s type is therefore int\u0026amp;\u0026amp;   EMCpp Item24 explains why these examples play out the way they do.\nCase 3: ParamType is Neither a Pointer nor a Reference In this case, we\u0026rsquo;re dealing with pass-by-value. That means that param will be a new object, which motivates the rules below:\n As before, if expr\u0026rsquo;s type is a reference, ignore the reference part If, after ignoring expr\u0026rsquo;s reference-ness, expr is const, ignore that, too. If it\u0026rsquo;s volatile, also ignore that (refer to EMCpp item 40 for volatile).  1 2 3 4 5 6 7 8 9 10 11 12  template\u0026lt;typename T\u0026gt; void f(T param); // param is now passed by value  int x = 27; // as before const int cx = x; // as before const int\u0026amp; rx = x; // as before const char* const ptr = \u0026#34;Fun with pointers\u0026#34;; // ptr is const ptr to const obj.  f(x); // T\u0026#39;s and param\u0026#39;s types are both int f(cx); // T\u0026#39;s and param\u0026#39;s types are both int f(rx); // T\u0026#39;s and param\u0026#39;s types are both int f(ptr); // T\u0026#39;s and param\u0026#39;s types are const char*, the constness of ptr is ignored.   Array Arguments Even though they sometimes seems to be interchangeable, array types are, in fact, different from pointer types. We had such equivalence illusion because, in many contexts, an array decays into a pointer to its first element:\n1 2  const char name[] = \u0026#34;J.P. Briggs\u0026#34;; // name\u0026#39;s type is const char [13] const char * ptrToName = name; // array decays to pointer   Array parameter declarations are treated as if they were pointer parameters, so void myFunc(int param[]); is equivalent to void myFunc(int* param);. Thus, the type of an array that\u0026rsquo;s passed to a template function by value is deduced to be a pointer type:\n1 2 3 4  template\u0026lt;typename T\u0026gt; void f(T param); f(name); // name is array, but T deduced as const char*   Although functions can\u0026rsquo;t declare parameters that are truly arrays, they can declare parameters that are references to arrays. Thus,\n1 2 3 4  template\u0026lt;typename T\u0026gt; void f(T\u0026amp; param); // template with by-reference parameter  f(name); // T is deduced as array type: const char [13], type of param is const char (\u0026amp;)[13]   The actual type of the array includes the array size, so in this example, T is deduced to be const char[13], and the type of f\u0026rsquo;s parameter (a reference to this array) is const char (\u0026amp;)[13].\nUsing this ability to declare references to arrays enables creation of a template that deduces the number of elements that an array contains:\n1 2 3 4 5 6 7  // return size of an array as a compile-time constant. // array parameter has no name because we don\u0026#39;t care its name template\u0026lt;typename T, std::size_t N\u0026gt; constexpr std::size_t arraySize(T (\u0026amp;)[N]) noexcept { return N; }   There are two points worth noting in this declaration:\n  constexpr, as explained in EMCpp 15, makes the function result available during compilation, which makes it possible to declare an array with the same number of elements as a second array whose size is computed from a braced initializer:\n1 2 3  int keyVals[] = { 1, 3, 7, 9, 11, 22, 35 }; // 7 elements int mappedVals[arraySize(keyVals)]; // 7 elements std::array\u0026lt;int, arraySize(keyVals)\u0026gt; values; // size == 7     noexcept, as explained in EMCpp 14, helps compilers generate better code.\n  Function Arguments Apart from arrays, function types can decay into function pointers, too. As a result:\n1 2 3 4 5 6 7 8 9 10 11  void someFunc(int, double); // someFunc is a function, type is void(int, double)  template\u0026lt;typename T\u0026gt; void f1(T param); // in f1, param passed by value  template\u0026lt;typename T\u0026gt; void f2(T\u0026amp; param); // in f2, param passed by ref  f1(someFunc); // param deduced as ptr-to-func, type is void (*)(int, double)  f2(someFunc); // param deduced as ref-to-func, type is void (\u0026amp;)(int, double)   This rarely makes any difference in practice.\n","description":"","id":103,"section":"notes","tags":["technique","cpp"],"title":"[EMCpp]Item-1 Understand Template Type Deduction","uri":"https://nianze.ml/en/notes/2018/07/understand-template-type-deduction/"},{"content":"As a highly available and scalable distributed data store, the design principles of Dynamo features high availability for writes (via reconciliation during reads), incremental scalability (consistent hashing), symmetry, decentralization, and heterogeneity (via virtual nodes).\nThe summary of techniques used in Dynamo and their advantages    Problem Technique Advantage     Partitioning Consistent Hashing Incremental Scalability   High Availability Vector clocks with reconciliation during reads Version size is decoupled from update rates.   Handling temporary failures Sloppy Quorum and hinted handoff Provides high availability and durability guarantee when some of the replicas are not available.   Recovering from permanent failures Anti-entropy using Merkle trees Synchronizes divergent replicas in the background.   Membership and failure detection Gossip-based membership protocol and (local notion) failure detection Perserves symmetry and avoids having a centralized registry for storing membership and node liveness information.   ","description":"","id":104,"section":"notes","tags":["technique"],"title":"A Brief Review of Dynamo","uri":"https://nianze.ml/en/notes/2018/07/a-brif-review-of-dynamo/"},{"content":"A random collection of recent works on music generation.\nPapers  Melody Generation for Pop Music via Word Representation of Musical Properties (2017.10) [arXiv] [Code] Generating Nontrivial Melodies for Music as a Service (2017.10) [arXiv] [Page] MuseGAN: Symbolic-domain Music Generation and Accompaniment with Multi-track Sequential Generative Adversarial Networks (2017.9) [arXiv] [Page] Similarity Embedding Network for Unsupervised Sequential Pattern Learning by Playing Music Puzzle Games （2017.9）[arXiv] [Page] A Tutorial on Deep Learning for Music Information Retrieval (2017.9) [arXiv] Deep Learning Techniques for Music Generation - A Survey (2017.9) [arXiv] (论文综述) Neural Translation of Musical Style (2017.8) [arXiv] [Page] GLSR-VAE: Geodesic Latent Space Regularization for Variational AutoEncoder Architectures (2017.7) [arXiv] Learning and Evaluating Musical Features with Deep Autoencoders (2017.6) [arXiv] Objective-Reinforced Generative Adversarial Networks (ORGAN) for Sequence Generation Models (2017.5) [arXiv] [Code] MidiNet: A Convolutional Generative Adversarial Network for Symbolic-domain Music Generation using 1D and 2D Conditions - ISMIR 2017 (2017.3) [arXiv] [Page] Automatic Conversion of Pop Music into Chiptunes for 8-bit Pixel Art - ICASSP 2017 (2017.2) [Paper] [Code] [Page] DeepBach: a Steerable Model for Bach Chorales Generation (2016.12) [arXiv] [Code] C-RNN-GAN: Continuous Recurrent Neural Networks with Adversarial Training (2016.11) [arXiv] [Code] 🌟 Tuning Recurrent Neural Networks with Reinforcement Learning - ICLR 2017 (2016.11) [arXiv] [Web] [Code] 🌟 SeqGAN: Sequence Generative Adversarial Nets with Policy Gradient - AAAI 2017 (2016.9) [Paper] [Code] Song From PI: A Musically Plausible Network for Pop Music Generation - ICLR 2017 [arXiv] [Reports]🌟 Text-based LSTM networks for Automatic Music Composition (2016.4) [arXiv] [Web] [Code] Music Transcription Modelling and Composition Using Deep Learning (2016.4) [arXiv] [Code] Composing A Melody with Long-short Term Memory (LSTM) Recurrent Neural Networks (2016.2) [Web] [Code] [Paper] Neural Adaptive Sequential Monte Carlo - NIPS 2015 (2015) [Paper] A Recurrent Latent Variable Model for Sequential Data - NIPS 2015 (2015) [Paper] [Code] AI Methods in Algorithmic Composition: A Comprehensive Survey (2013) [Paper] 🌟 Modeling Temporal Dependencies in High-dimensional Sequences: Application to Polyphonic Music Generation and Transcription (2012) [arXiv] Towards Adaptive Music Generation By Reinforcement Learning of Musical Tension (2010) [Paper] A First Look at Music Composition using LSTM Recurrent Neural Networks (2002) [Web] [Paper]  Projects  Google Magenta [Web] [Code] Deep Jazz [Web] [Code] BachBot [Web] [Code] WaveNet [Web][Code] (not fully) GRUV [Code] Kulitta [Code]  Applications  AIVA[Link] Google A.I. Duet [Link] The Infinite Drum Machine [Link] Amper Music [Link] Intelligent Music System [Link] Unwind [Link] Tidalcycles [Link] [Video] Jukedeck [Link]  Conferences\u0026amp;Workshops  ACM MM - ACM MultiMedia [Web] ISMIR - The International Society of Music Information Retrieval [Web] ICASSP - Conference on Acoustics, Speech and Signal Processing [Web] DLM - Deep Learning for Music Workshop [Web] CSMC - Conference on Computer Simulation of Musical Creativity [Web] CCRMA - Center for Computer Research in Music and Acoustics (Stanford University) [Web] ICMC - Internatonal Computer Music Conference [Web] [Lists]  Blogs  Neural Nets for Generating Music [Web] Generative Music with JavaScript \u0026amp; Web Audio [Web] The Current State Of AI: Artificial Intelligence In Music, Movies \u0026amp; More (2017.7) [Web] Composing Music With Recurrent Neural Networks (2015.8) [Web] [Code] Analyzing deep learning tools for music generation [Web] COORD [Web] How evolved LSTMS improvise on a melogy you specify[Web] AI makes pop music in the style of any composer[Web] Richard Yang\u0026rsquo;s Blog[Blog] Thousands of bird sounds visualized using machine learning[Web] Music AI: Loop-in-the-Human[Web] ","description":"","id":105,"section":"notes","tags":["music","recourse"],"title":"A simple archive for music generation","uri":"https://nianze.ml/en/notes/2018/05/music-generation-archive/"},{"content":"There are five points worth noting if we want to mix C++ and C in the same program.\nSummary  Make sure the C++ and C compilers produce compatible object files Declare functions to be used by both languages extern C If at all possible, write main in C++ Always use delete with memory from new; always use free with memory from malloc Limit what we pass between the two languages to data structures that compile under C; the C++ version of structs may contain nonvirtual member functions  1. Compatible object files Before mix together object files produced by some C compiler with those from C++ compiler, we have to make sure they both share the same implementation-dependent features, such as the size of ints and doubles, the mechanism by which parameters are passed from caller to callee, and whether the caller or the callee orchestrates the passing.\n2. Name Mangling Name mangling is the process through which the C++ compilers give each function in our program a unique name, which is unnecessary in C because we can\u0026rsquo;t overload function names in C.\nFor example, when we write this in C++:\n1 2 3  void drawLine(int x1, int y1, int x2, int y2); // suppose this is mangled into xyzzy ... drawLine(a, b, c, d); // call to unmangled function name in source code   Then the statement will be translated by the C++ compiler into the mangled version of that function, so the object file conbtains a function call that corresponds to this:\n1  xyzzy(a, b, c, d); // call to mangled function name   However, if drawLine is a C function, the object file (or archive or dynamically linked library, etc.) that contains the compiled version of drawLine contains a function called drawLine - no name mangling occurs. When trying to link mixed style object files together, we may get an error, because the linker is looking for a function called xyzzy, and there is no such function.\nTo solve this problem, we tell C++ compilers not to mangle certain function names:\n1 2  extern \u0026#34;C\u0026#34; void drawLine(int x1, int y1, int x2, int y2);   Note that there is only extern \u0026quot;C\u0026quot;, no extern \u0026quot;Pascal\u0026quot; or extern \u0026quot;FORTRAN\u0026quot; or anything else. extern \u0026quot;C\u0026quot; means that the function should be called as if it were written in C (Technically, extern \u0026quot;C\u0026quot; means the function has C linkage, which guarantees that name mangling is suppressed.)\nFor a slew of functions whose names don\u0026rsquo;t need mangling, we enclose them in curly braces. For header files we want to share by both C++ and C, we take advantage of preprocessor symbol \u0026ldquo;__cplusplus\u0026rdquo;, which is defined only for C++ compilations:\n1 2 3 4 5 6 7 8 9 10  #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif  void drawLine(int x1, int y1, int x2, int y2); void twiddleBits(unsigned char bits); void simulate(int iterations); ... #ifdef __cplusplus } #endif   3. Initialization of Statics In C++, the constructors of static class objects and objects at global, namespace, and file scope are usually called before the body of main is executed, which is known as static initialization. Similarly, objects that are created through static initialization must have their destructors called during static destruction, which typically take place after main has finished executing.\nThe implementation of static initialization as well as static destruction is usually achieved by compilers by inserting a call to a special compiler-written function at the beginning of main, which takes care of static initialization (similarly with static destruction):\n1 2 3 4 5 6 7 8  int main(int argc, char *argv[]) { performStaticInitialization(); // generated by the compiler  the statements we put in main; performStaticDestruction(); // generated by the compiler }   The point is, if a software contains a C++ part, which is compiled with this approach to initialize and destruct static objects (they usually do), we should write main in C++.\nIf most of a program is in C and C++ is only a support library, it would make more sense to write main in C. Nevertheless, in case of static objects in C++ library (if it doesn\u0026rsquo;t now, it probably will in the future, see MECpp item 32), so it\u0026rsquo;s still a good idea to write main in C++: simply call the C version realMain in a wrapper main in C++:\n1 2 3 4 5 6 7  extern \u0026#34;C\u0026#34; int realMain(int argc, char *argv[]); // implement this function in C  int main(int argc, char *argv[]) // write this in C++ { return realMain(argc, argv); }   4. Dynamic Memory Allocation Recall MECpp Item 8: the C++ parts of a program use new and delete, and the C parts of a program use malloc (and its variants) and free. Mismatched allocation and deallocation operation for dynamic memory yields undefined behavior, so never call free on a newed pointer, nor deleteing a malloced pointer.\nSometimes this is easier said than done, because some functions are not in the standard library, or not available in the uniform implementation on different computing platforms, making it hard to judge the correct deallocation operation:\n1  char * strdup(const char *ps); // return a copy of the string pointed to by ps   If the strdup is from a C library, we need to call free; if it was written for a C++ library, we should call delete. If we can\u0026rsquo;t make sure, then simply avoid calling such functions.\n5. Data Structure Compatibility C functions can not understand C++ features, so if we want to pass data between C++ and C programs, we are limited to those concepts that C can express: naturally, structs and variables of built-in types (e.g., ints, chars, etc.)\nBecause the rules governing the layout of a struct in C++ are consistent with those of C, if we can add structs with nonvirtual member, objects of such structs (or class) containing only non-virtual functions should be compatible with their C counterparts, whose structure definition lacks only the member function declarations, and we are safe to pass them back and forth between C++ and C.\nAdding virtual functions ends the game, because the addition of virtual functions to a class cuases objects of that type to use a different memory layout (MECpp item 24). Having a struct inherit from another struct (or class) usually changes its layout, too, so structs with base structs (or classes) are also poor candidates for exchange with C functions.\n","description":"","id":106,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-34 Understand How to Combine C++ and C in the Same Program","uri":"https://nianze.ml/en/notes/2018/05/understand-how-to-combine-c++-and-c-in-the-same-program/"},{"content":"The general rule: non-leaf classes should be abstract. This will yields dividends in the form of increased reliability, robustness, comprehensibility, and extensibility throughout our software.\nRedesign concrete base classes to abstract ones If we have two concrete classes C1 and C2 and we\u0026rsquo;d like C2 to publicly inherit from C1, we should transform that two-class hierarchy into a three-class hierarchy by creating a new class A and having both C1 and C2 publicly inherit from it:\ninitial idea | the transformed hierarchy ┌─────────┐ | ┌─────┐ │ C1 │ | │ A │ └─────────┘ | └─────┘ ↑ | public inheritance ↗ ↖ public inheritance ┌─────────┐ | ┌────┐ ┌────┐ │ C1 │ | │ C1 │ │ C2 │ └─────────┘ | └────┘ └────┘ For example, we create a software dealing with animals, with two kinds of animals - lizards and chickens - require special handling:\n ┌──────────┐ │ Animal │ └──────────┘ public inheritance ↗ ↖ public inheritance ┌────────┐ ┌─────────┐ │ Lizard │ │ Chicken │ └────────┘ └─────────┘ The Animal class embodies the features shared by all the creatures, and the Lizerd and Chicken classes specialize Animal in their own ways:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Animal { public: Animal\u0026amp; operator=(const Animal\u0026amp; rhs); ... }; class Lizard: public Animal { public: Lizard\u0026amp; operator=(const Lizard\u0026amp; rhs); ... }; class Chicken: public Animal { public: Chicken\u0026amp; operator=(const Chicken\u0026amp; rhs); ... };   Now consider what happens for assignment operation:\n1 2 3 4 5 6  Lizard liz1; Lizard liz2; Animal *pAni1 = \u0026amp;liz1; Animal *pAni2 = \u0026amp;liz2; ... *pAni1 = *pAni2;   The two problems here:\n partial assignment: only Animal members in liz1 get updated from liz2, while the liz1\u0026rsquo;s Lizard members remain unchanged. it\u0026rsquo;s not uncommon for programmers to make assignments to objects via pointers.  Solution 1: virtual functions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Animal { public: virtual Animal\u0026amp; operator=(const Animal\u0026amp; rhs); ... }; class Lizard: public Animal { public: virtual Lizard\u0026amp; operator=(const Animal\u0026amp; rhs); ... }; class Chicken: public Animal { public: virtual Chicken\u0026amp; operator=(const Animal\u0026amp; rhs); ... };   We can customize the return value of the virtual assignment operators here, but the rules of C++ force us to declare identical parameter types for a virtual function in every class in which it is declared, leading to the problem that the assignment operator for the Lizard and Chicken must be prepared to accept any kind of Animal object on the right-hand side of an assignment:\n1 2 3 4 5 6 7 8 9  Lizard liz; Chicken chick; Animal *pAni1 = \u0026amp;liz; Animal *pAni2 = \u0026amp;chick; ... *pAni1 = *pAni2; // assign a chicken to a lizard!   By making Animal\u0026rsquo;s assignment operator virtual, we opened the door to such mixed-type operations. To only allow the same type assignment in virtual assignment operation, we have to make distinctions the types at runtime:\n1 2 3 4 5 6  Lizard\u0026amp; Lizard::operator=(const Animal\u0026amp; rhs) { // make sure rhs is really a lizard  const Lizard\u0026amp; rhs_liz = dynamic_cast\u0026lt;const Lizard\u0026amp;\u0026gt;(rhs); ... // proceed with a normal assignment of rhs_liz to *this }   In this case, we have to worry about std::bad_cast exceptions thrown by dynamic_cast when rhs is not a Lizard, while paying for extra runtime check cost for valid assignment cases, as well as the harder to maintain code.\nSolution 2: adding another function If we don\u0026rsquo;t want to pay for the complexity or cost of a dynamic_cast in the case of valid assignment, we add to Lizard the conventional assignment operator:\n1 2 3 4 5 6 7 8 9 10 11  class Lizard: public Animal { public: virtual Lizard\u0026amp; operator=(const Animal\u0026amp; rhs); Lizard\u0026amp; operator=(const Lizard\u0026amp; rhs); // add this  ... }; Lizard\u0026amp; Lizard::operator=(const Animal\u0026amp; rhs) { return operator=(dynamic_cast\u0026lt;const Lizard\u0026amp;\u0026gt;(rhs)); }   1 2 3 4 5 6 7 8  Lizard liz1, liz2; ... liz1 = liz2; // calls operator= taking a const Lizard\u0026amp;  Animal *pAni1 = \u0026amp;liz1; Animal *pAni2 = \u0026amp;liz2; ... *pAni1 = *pAni2; // calls operator= taking a const Animal\u0026amp;   Still, clients of Lizard and Chicken have to be prepared to catch bad_cast exceptions and do something sensible with them each time they perform an assignment, which most programmers are unwilling to do.\nSolution 3: making partial assignment illegal The easiest way to prevent partial assignments is to make Animal::operator= private so that *pAni1 = *pAni2; is illegal (which calls private Animal::operator=), but this naive solution has 2 problems:\n  Animal is a concrete class. A private operator= makes also it illegal to make assignments between Animal objects: animal1 = animal2;\n  Assignment operator in derived classes are responsible for calling assignment operators in their base classes, but a private Animal::operator= makes it impossible to implement the Lizard::operator= and Chicken::operator= correctly to assign the Animal part of *this:\n1 2 3 4 5 6  Lizard\u0026amp; Lizard::operator=(const Lizard\u0026amp; rhs) { if (this == \u0026amp;rhs) return *this; Animal::operator=(rhs); // can\u0026#39;t call private Animal::operator=  ... }     Declaring Animal::operator= as protected will solve the latter problem, but the first one still remains.\nSolution 4: redesign the inheritance hierarchy Because our orignimal design for the system presupposed that Animal objects were necessary, we can not abstract Animal class. Instead, we create a new class - AbstractAnimal that consists of the common features of Animal, Lizard, and Chicken, and we make that class abstract by making its destructor a pure virtual function1:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class AbstractAnimal { protected: AbstractAnimal\u0026amp; operator=(const AbstractAnimal\u0026amp; rhs); public: virtual ~AbstractAnimal() = 0; // still need to impl. the destructor even it\u0026#39;s a pure virtual function  ... }; class Animal: public AbstractAnimal { public: Animal\u0026amp; operator=(const Animal\u0026amp; rhs); ... }; class Lizard: public AbstractAnimal { public: Lizard\u0026amp; operator=(const Lizard\u0026amp; rhs); ... }; class Chicken: public AbstractAnimal { public: Chicken\u0026amp; operator=(const Chicken\u0026amp; rhs); };   This design gives us everything:\n homogeneous assignments ar allowed for lizards, chickens, and animals; partial assignments and heterogeneous assignments are prohibited derived class assignment operators may call the assignment operator in the base class non of the code written in terms of the Animal, Lizard, or Chicken requires modification - they behave as they did before AbstractAnimal was introduced - though the code does need to be recompiled  In reality when facing constraints If we want wot create a concrete class that inherits from a concrete class in a thirt-party libraries to which we have only read access, what are we to do?\nThen there are only unappealing options:\n  Derive the concrete class from the existing concrete class, and put up with the assignment-related problems, and watch out for the array-related pitfalls (MECpp item 3).\n  Try to find an abstract class higher in the library hierarchy that does most of what we need, then inherit from that class.\n  Implement the new class in terms of the library class we\u0026rsquo;d like to inherit from: having an object of the library class as a data member, then reimplement the library class\u0026rsquo;s interface in the new class - this requires to update the class each time the library vendor updates our dependent library classes, and we also give up the ability to redefine virtual functions declared in the library class (we can\u0026rsquo;t redefine virtual functions unless we inherit them):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Window { public: virtual void resize(int newWidth, int newHeight); virtual void repaint() const; int width() const; int height() const; }; class SpecialWindow { // class we wanted to have inherit from Window public: ... int width() const { return w.width(); } // pass through nonvirtual functions  int height() const { return w.height(); } virtual void resize(int newWidth, int newHeight); // new impl. of \u0026#34;inherited\u0026#34; virtual functions  virtual void repaint() const; private: Window w; };     Use the concrete class that\u0026rsquo;s in the library and modify the software so that the class suffices. Write non-member functions to proved the extra functionality we\u0026rsquo;d like to add to the class, but can\u0026rsquo;t - the result may not be as clear, as efficient, as maintainable, or as extensible as we\u0026rsquo;d like.\n   Declaring a function pure virtual doesn\u0026rsquo;t mean it has no implementation, it means: 1. the current class is abstract, and 2 any concrete class inheriting from the current class must declare the function as a \u0026ldquo;normal\u0026rdquo; virtual function (i.e., without the \u0026ldquo;=0\u0026rdquo;).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":107,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-33 Make Non-Leaf Classes Abstract","uri":"https://nianze.ml/en/notes/2018/05/make-non-leaf-classes-abstract/"},{"content":"Things change. Future tense thinking increases the reusability of the code we write, enhances its maintainability, makes it more robust, and facilitates gracefully in an environment where change is a certainty.\nTo program in the future tense is to accept that things will change and to be prepared for it.\nChanging world Recognize that\n new functions will be added to libraries, that new overloading will occur, and potentially ambiguous function calls that might result new classes will be added to hierarchies, present-day derived clases may be tomorrow\u0026rsquo;s base classes new application will be written so functions will be called in new contexts while still being expected to perform correctly  Changing people Acknowledge that\n programmers charged with software maintenance are typically not the code\u0026rsquo;s original developers, hence to design and implement in a fashion that facilitates comprehension, modification, and enhancement by others. \u0026ldquo;Anything somebody can do, they will do\u0026rdquo;: client developers have different level of experience with C++, so the intention of a class designer may be misunderstood.  Principle  Design the class easy to use correctly and hard to use incorrectly  do what an ints will do use C++ itself to express design constraints instead of (or in addition to) comments or documentation   Strive for portable code  if there is no great penalty for generalizing the code, generalize it   Design the code so that when changes are necessary, the impact is localized  provide complete classes even if some parts aren\u0026rsquo;t currently used - when new demands are made on our classes, we\u0026rsquo;re less likely to have to go back and modify them do:  encapsulate as much as we can; make implementation details private; use unnamed namespaces\u0026hellip;   avoid:  designs leading to virtual base classes (such classes must be initialized by every class derived from them, MECpp item 4) RTTI-based designs that make use of cascading if-then-else (MECpp item 31)     ","description":"","id":108,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-32 Program in the Future Tense","uri":"https://nianze.ml/en/notes/2018/05/program-in-the-future-tense/"},{"content":"A virtual function call is termed a \u0026ldquo;message dispatch.\u0026rdquo; A call that acts virtual on multiple parameters is called multiple dispatch, which is not directly supported in C++. Several resolutions exist, but none is without its disadvantages.\nFor example, considering we are writing a video game involving space ships, space stations, and asteroids:\n1 2 3 4  class GameObject {...}; class SpaceShip: public GameObject {...}; class SpaceStation: public GameObject {...}; class Asteroid: public GameObjecct {...};   When one GameObject collides with another, we call a function depending on both their dynamic types:\n1 2 3 4 5 6 7 8 9  void checkForCollision(GameObject\u0026amp; object1, GameObject\u0026amp; object2) { if (theyJustCollided(object1, object2)) { processCollision(object1, object2); } else { ... } }   Now comes the double dispatch: since collisions betwenn different GameObject effects the environment differently, we want processCollision to act virtual on both object1 and object2, but C++ only offers virtual support for one parameter, like object1.processCollision(object2). We must come up with some approaches ourselves instead of relyin on compilers.\nUsing Virtual Function and RTTI We need double dispatch, so we can use virtual functions for first half of what we need, and use chains of if-then-elses for rest half:\n1 2 3 4 5 6 7 8 9 10 11  class GameObject { public: virtual void collide(GameObject\u0026amp; otherObject) = 0; ... }; class SpaceShip: public GameObject { public: virtual void collide(GameObject\u0026amp; otherObject); ... };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // if colliding with an object of unknown type // throw an exception of this type: class CollisionWithUnknownObject { public: CollisionWithUnknownObject(GameObject\u0026amp; whatWeHit); ... }; void SpaceShip::collide(GameObject\u0026amp; otherObject) { const type_info\u0026amp; objectType = typeid(otherObject); if (objectType == typeid(SpaceShip)) { SpaceShip\u0026amp; ss = static_cast\u0026lt;SpaceShip\u0026amp;\u0026gt;(otherObject); process a SpaceShip-SpaceShip collision; } else if (objectType == typeid(SpaceStation)) { SpaceStation\u0026amp; ss = static_cast\u0026lt;SpaceStation\u0026amp;\u0026gt;(otherObject); process a SpaceShip-SpaceStation collision; } else if (objectType == typeid(Asteroid)) { Asteroid\u0026amp; a = static_cast\u0026lt;Asteroid\u0026amp;\u0026gt;(otherObject); process a SpaceShip-Asteroid collision; } else { throw CollisionWithUnknownObject(otherObject); } }   The danger in this design: each collide function must be aware of each of its sibling classes, so if a new type of object is added to the game, we must update each RTTI-based if-then-else chain in the proram that might encounter the new object, which in essence is unmaintainable in the long run. We added a final else clause where control winds up if we hit an unnknown object, throwing an exception to callers in the hope that they handle the error better than we can (but since we are running into something we didn\u0026rsquo;t know existed, they almost can\u0026rsquo;t do anything more satisfying.)\nUsing Virtual Functions Only We can also implement double-dispatching as two separate virtual function calls:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // forward declarations class SpaceShip; class SpaceStation; class Asteroid; class GameObject { public: virtual void collide(GameObject\u0026amp; otherObject) = 0; virtual void collide(SpaceShip\u0026amp; otherObject) = 0; virtual void collide(SpaceStation\u0026amp; otherObject) = 0; virtual void collide(Asteroid\u0026amp; otherObject) = 0; ... }; class SpaceShip: public GameObject { public: virtual void collide(GameObject\u0026amp; otherObject); virtual void collide(SpaceShip\u0026amp; otherObject); virtual void collide(SpaceStation\u0026amp; otherObject); virtual void collide(Asteroid\u0026amp; otherObject); ... };   1 2 3 4  void SpaceShip::collide(GameObject\u0026amp; otherObject) { otherObject.collide(*this); }   Note that this implementation is not a resursive call: being inside a member function of the class Spaceship, the static type of *this is of type SpaceShip, so the call is routed to the collide(SpaceShip\u0026amp;) instead of going back to collide(GameObject\u0026amp;). All the collide functions are virtual, so finally this call will resolve to the implementation of collide corresponding to the real type of otherObject, where both types are known. So the implementation is simply:\n1 2 3 4 5 6 7 8 9 10 11 12  void SpaceShip::collide(SpaceShip\u0026amp; otherObject) { process a SpaceShip-SpaceShip collision; } void SpaceShip::collide(SpaceStation\u0026amp; otherObject) { process a SpaceShip-SpaceStation collision; } void Spaceship::collide(SpaceStation\u0026amp; otherObject) { process a SpaceShip-Asteroid collision; }   There\u0026rsquo;s no RTTI, no need to throw unexpected object types. Still, there\u0026rsquo;s the same old flaw: each class must know about its siblings. Even worth, the way in which the code must be updated in the case of adding new classes is difficult to extend: if we add a new class, say class Satellite: public GameObject, to our game, we\u0026rsquo;d have to add a new collide function to each of the existing classes in the program, rather than just another else clause in one function before.\nNow let\u0026rsquo;s do a small sum-up:\n Virtual function approach is safer than the RTTI strategy, but it constrains the extensibility of the system to match that of our ability to edit header files RTTI makes no recompilation demands, but it generally leads unmaintainable software. The best recourse is to modify the design to eliminate the need for double-dispatching.  Emulating Virtual Function Tables Actually, we can build our own virtual function tables, similar to how compilers implement virtual functions by creating an array of function pointers (the vtbl) and then indexing into that array when a virtual function is called, except that this customized version support double-dispatching. Moreover, the virtual function tables is more efficient than the RTTI-based code (indexing into an array and following a function pointer vs running through a series of if-then-else tests), and we isolate the use of RTTI to a single location where the array of function pointers is initialized.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class GameObject { public: virtual void collide(GameObject\u0026amp; otherObject) = 0; ... }; class SpaceShip: public GameObject { public: virtual void collide(GameObject\u0026amp; otherObject); virtual void hitSpaceShip(GameObject\u0026amp; spaceShip); virtual void hitSpaceStation(GameObject\u0026amp; spaceStation); virtual void hitAsteroid(GameObject\u0026amp; asteroid); ... private: typedef void (SpaceShip::*HitFunctionPtr)(GameObject\u0026amp;); static HitFunctionPtr lookup(const GameObject\u0026amp; whatWeHit); typedef map\u0026lt;string, HitFunctionPtr\u0026gt; HitMap; static HitMap * initializeCollisionMap(); ... };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  SpaceShip::HitMap * SpaceShip::initializeCollisionMap() { HitMap *phm = newHitMap; (*phm)[\u0026#34;SpaceShip\u0026#34;] = \u0026amp;hitSpaceShip; (*phm)[\u0026#34;SpaceStation\u0026#34;] = \u0026amp;hitSpaceStation; (*phm)[\u0026#34;Asteroid\u0026#34;] = \u0026amp;hitAsteroid; return phm; } SpaceShip::HitFunctionPtr SpaceShip::lookup(const GameObject\u0026amp; whatWeHit) { static auto_ptr\u0026lt;HitMap\u0026gt; collisionMap(initializeCollisionMap()); HitMap::iterator mapEntry = collisionMap.find(typeid(whatWeHit).name()); if (mapEntry == collisionMap-\u0026gt;end()) return 0; return (*mapEntry).second; } void SpaceShip::collide(GameObject\u0026amp; otherObject) { HitFunctionPtr hfp = lookup(otherObject); if (hfp) { (this-\u0026gt;*htp)(otherObject); } else { throw CollisionWithUnknownObject(otherObject); } } // Each of the `dynamic_cast` will throw a `bad_cast` exception if the cast fails // they should never fail, though. void SpaceShip::hitSpaceShip(GameObject\u0026amp; spaceShip) { SpaceShip\u0026amp; otherShip = dynamic_cast\u0026lt;SpaceShip\u0026amp;\u0026gt;(spaceShip); process a SpaceShip-SpaceShip collision; } void SpaceShip::hitSpaceStation(GameObject\u0026amp; spaceStation) { SpaceStation\u0026amp; Station = dynamic_cast\u0026lt;SpaceStation\u0026amp;\u0026gt;(spaceStation) process a SpaceShip-SpaceStation collision; } void Spaceship::hitAsteroid(GameObject\u0026amp; asteroid) { Asteroid\u0026amp; theAsteroid = dynamic_cast\u0026lt;Asteroid\u0026gt;(asteroid) process a SpaceShip-Asteroid collision; }   Note that there\u0026rsquo;s another design which seems doable but is actually error-prone:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class SpaceShip: public GameObject { public: virtual void collide(GameObject\u0026amp; otherObject); virtual void hitSpaceShip(SpaceShip\u0026amp; otherObject); virtual void hitSpaceStation(SpaceStation\u0026amp; otherObject); virtual void hitAsteroid(Asteroid\u0026amp; otherObject); ... }; SpaceShip::HitMap * SpaceShip::initializeCollisionMap() { HitMap *phm = newHitMap; (*phm)[\u0026#34;SpaceShip\u0026#34;] = reinterpret_cast\u0026lt;HitFunctionPtr\u0026gt;(\u0026amp;hitSpaceShip); (*phm)[\u0026#34;SpaceStation\u0026#34;] = reinterpret_cast\u0026lt;HitFunctionPtr\u0026gt;(\u0026amp;hitSpaceStation); (*phm)[\u0026#34;Asteroid\u0026#34;] = reinterpret_cast\u0026lt;HitFunctionPtr\u0026gt;(\u0026amp;hitAsteroid); return phm; }   Here we tell the compiler that hitSpaceShip, hitSpaceStation, and hitAsteroid are functions expecting a GameObject argument, which is not true. hitSpaceShip expects a SpaceShip, hitSpaceStation expects a SpaceStation, and hitAsteroid expects an Asteroid. All these functions are declared as pass-by-reference, which in fact is implemented by passing a pointer to an object, so ideally compilers will pass the declared type of the parameter(say hitSpaceShip for function hitSpaceShip) in the function being called. However, due to the object layout of classes under an inheritance path, after the cast above, it is possible that the wrong address (say GameObject) is passed into the function, because inside a SpaceShip object there are both a derived class part as well as a base class part, each having a different address (for detailed discussion, refer to More Effective C++ Item 31-Initializing Emulated Virtual Function Talbes).\nUsing Non-Member Collision-Processing Functions Still, similar to pure virtual functions based approach, there is one remaining problem: because the associative array contains pointers to member functions, once a new type of GameObject is added to the game, every class definition needs to be updated and recompiled, even if that class does not care about the new type of object.\nTo solve this problem, we change the associative array so that it contains pointers to non-member functions. This update also helps us address a design question before: a collision between objects of types A and B should be handles by neither A nor B (depending on whichever is the left-hand argument to processCollision) but instead in some neutral location outside both classes.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  #include \u0026#34;SpaceShip.h\u0026#34;#include \u0026#34;SpaceStation.h\u0026#34;#include \u0026#34;Asteroid.h\u0026#34; namespace { // primary collision-processing functions void shipStation(GameObject\u0026amp; spaceShip, GameObject\u0026amp; spaceStation); void shipAsteroid(GameObject\u0026amp; spaceShip, GameObject\u0026amp; asteroid); void asteroidStation(GameObject\u0026amp; asteroid, GameObject\u0026amp; spaceStation); // secondary collision-processing functions that just implement symmetry void stationShip(GameObject\u0026amp; spaceStation, GameObject\u0026amp; spaceShip) { shipStation(spaceShip, spaceStation); } void asteroidShip(GameObject\u0026amp; asteroid, GameObject\u0026amp; spaceShip) { shipAsteroid(spaceShip, asteroid); } void stationAsteroid(GameObject\u0026amp; spaceStation, GameObject\u0026amp; asteroid) { asteroidStation(asteroid, spaceStation); } ... typedef void (*HitFunctionPtr)(GameObject\u0026amp;, GameObject\u0026amp;); typedef map\u0026lt; pair\u0026lt;string, string\u0026gt;, HitFunctionPtr \u0026gt; HitMap; pair\u0026lt;string, string\u0026gt; makeStringPair(const char *s1, const char *s2); HitMap * initializeCollisionMap(const string\u0026amp; class1, const string\u0026amp; class2); HitFunctionPtr lookup(const string\u0026amp; class1, const string\u0026amp; class2); } // end of unnamed namespace  void processCollision(GameObject\u0026amp; object1, GameObject\u0026amp; object2) { HitFunctionPtr phf = lookup(typeid(object1).name(), typeid(object2).name()); if (phf) phf(object1, object2); else throw UnknownCollision(object1, object2); } namespace { pair\u0026lt;string, string\u0026gt; makeStringPair(const char *s1, const char *s2) { return pair\u0026lt;stirng, string\u0026gt;(s1, s2); } HitMap * initializeCollisionMap() { HitMap *phm = new HitMap; (*phm)[makeStringPair(\u0026#34;Spaceship\u0026#34;, \u0026#34;Asteroid\u0026#34;)] = \u0026amp;shipAsteroid; (*phm)[makeStringPair(\u0026#34;Spaceship\u0026#34;, \u0026#34;SpaceStation\u0026#34;)] = \u0026amp;shipStation; ... return phm; } HitFunctionPtr lookup(const string\u0026amp; class1, const string\u0026amp; class2) { static auto_ptr\u0026lt;HitMap\u0026gt; collisionMap(initializeCollisionMap()); HitMap::iterator mapEntry = collisionMap-\u0026gt;find(make_pair(class1, class2)); if (mapEntry == collisionMap-\u0026gt;end()) return 0; return (*mapEntry).second; } } // end namespace   Note that makeStringPair, initializeColllisionMap, and lookup were declared inside an unnamed namespace, therefore each must also be implemented within the same namespace.\nNow we\u0026rsquo;ve solved the problem: if there are new classes to the hierarchy, it requires only the addition of more map insertions in initializeCollisionMap and the declarations of the new collision-processing functions in the unnamed namespace associated with the implementation of processCollision.\nHowever, as uaual, there\u0026rsquo;s still a disadvantage in this design: these non-member functions will not support inheritance-based parameter conversions such as how double-virtual-function-call mechanism does.\nFor example, suppose the concrete classes CommercialShip and MilitaryShip inherit from the newly abstract class SpaceShip (according to the guidance of MECpp item 33). If a MilitaryShip object and an Asteroid collided, we\u0026rsquo;d expect void shipAsteroid(GameObject\u0026amp;, GameObject\u0026amp;) to be called. However, in fact, an UnknownCollision would be thrown, because lookup would be asked to find a function corresponding to the type names MilitaryShip and Asteroid, and no such function would be found in collisionMap - after all, lookup has no way of knowing that MilitaryShip can be treated like a SpaceShip.\nModifying Emulated Virtual Function Talbes Dynamically If we\u0026rsquo;d like to add, remove, or change collision-processing functions as the game proceeds, the static collisionMap will not meet this requirement. In this case, we can turn the concept of a static map into a class that offers member functions allowing us to modify the contents of the map dynamically:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class CollisionMap { public: typedef void (*HitFunctionPtr)(GameObject\u0026amp;, GameObject\u0026amp;); void addEntry(const string\u0026amp; type1, const String\u0026amp; type2, HitFunctionPtr collisionFunction, bool symmetric = true); void removeEntry(const string\u0026amp; type1, const string\u0026amp; type2); HitFunctionPtr lookup(const string\u0026amp; type1, const string\u0026amp; type2) // return a reference to the one and only map  static CollisionMap\u0026amp; theCollisionMap(); private: // private to prevent the creation of multiple maps  CollisionMap(); CollisionMap(const CollisionMap\u0026amp;); };   Clients wishing to add an entry to the map simply do the following step:\n1 2  void shipAsteroid(GameObject\u0026amp; spaceShip, GameObject\u0026amp; asteroid); CollisionMap::theCollisionMap().addEntry(\u0026#34;SpaceShip\u0026#34;, \u0026#34;Asteroid\u0026#34;, \u0026amp;shipAsteroid);   We must take care to ensure that these map entries are added to the map before any collisions occurs. One way is to have constructors in GameObject subclasses check to make sure the appropriate mappings had been added each time an object was created, but then we have to pay a small performance penalty at runtime. An alternative would be to create a RegisterCollisionFunction class:\n1 2 3 4 5 6 7 8 9 10  class RegisterCollisionFunction { public: RegisterCollisionFunction(const string\u0026amp; type1, const string\u0026amp; type2, CollisionMap::HitFunctionPtr collisionFunction, bool symmetric = true) { CollisionMap::theCollisionMap().addEntry(type1, type2, collisionFunction, symmetric); } };   Clients then use global objects of this type to automatically register the functions before main is invoked to insure the map is initialized properly before any collision occurs:\n1 2 3 4 5 6 7 8  RegisterCollisionFunction cf1(\u0026#34;SpaceShip\u0026#34;, \u0026#34;Asteroid\u0026#34;, \u0026amp;shipAsteroid); RegisterCollisionFunction cf2(\u0026#34;SpaceShip\u0026#34;, \u0026#39;SpaceStation\u0026#39;, \u0026amp;shipStation); ... int main(int argc, char * argv[]) { ... }   If, later, a new derived class Satellite: public GameObject {...}; is added, and one or more new collision-processing functions are written (say, void satelliteShip(GameObject\u0026amp;, GameObject\u0026amp;), and void satelliteAsteroid(GameObject\u0026amp;,GameObject\u0026amp;), etc), we can simply add them to the map without disturbing existing code:\n1 2  RegisterCollisionFunction cf4(\u0026#34;Satellite\u0026#34;, \u0026#34;SpaceShip\u0026#34;, \u0026amp;satelliteShip); RegisterCollisionFunction cf5(\u0026#34;Satellite\u0026#34;, \u0026#34;Asteroid\u0026#34;, \u0026amp;satelliteAsteroid);   Overall, this makes it easy to provide data for a map-based implementation, but it doesn\u0026rsquo;t change the fact that there\u0026rsquo;s no perfect way to implement multiple dispatch.\n","description":"","id":109,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-31 Making Functions Virtual With Respect to More Than One Object","uri":"https://nianze.ml/en/notes/2018/05/making-functions-virtual-with-respect-to-more-than-one-object/"},{"content":"Objects that stand for other objects are often called proxy objects (or surrogates), and the classes that give rise to proxy objects are often called proxy classes, which is useful for implementing multidimensional arrays, differentiating lvalue/rvalue, and suppressing implicit conversions.\nImplementing Two-Dimensional Arrays Consider this statement:\n1 2 3  int data[10][20]; ... cout \u0026lt;\u0026lt; data[3][6]; // fine   We want to create a general 2D array supporting operations such as data[3][6]. However, there\u0026rsquo;s no such thing as a operator[][] in C++. The reason it is legal to write code above that appears to use operator[][] is because the variable data is not really a two-dimensinal array at all, but a 10-element one-dimensional array, each element of which is itself a 20-element array. So the expression data[3][6] really means (data[3])[6] - the seventh element of the array that is the fourth element of data.\nPlaying the same trick as above, we can define our Array2D class by overloading operator[] to return an object of a new class, Array1D:\n1 2 3 4 5 6 7 8 9 10 11 12 13  template\u0026lt;class T\u0026gt; class Array2D { public: class Array1D { public: T\u0026amp; operator[](int index); const T\u0026amp; operator[](int index) const; }; Array1D operator[](int index); const Array1D operator[](int index) const; ... };   Then it is legal to write code like this:\n1 2 3  Array2D\u0026lt;float\u0026gt; data(10, 20); ... cout \u0026lt;\u0026lt; data[3][6];   Conceptually intances of Array1D class (which is a proxy class) do not exist for clients of Array2D. Such clients program as if they were using real, live two-dimensional arrays.\nDistinguishing Reads from Writes via operator[] operator[] can be called in two different contexts:\n rvalue usage for read lvalue usage for write  In general, using an object as an lvalue means using it such that it might be modified, and using it as rvalue means using it such that it cannot be modified.\nFrom MECpp item 29 reference counting, we can see reads can be much less expensive than writes - writes of reference-counted object may involve copying an entire data structure, while reads never require more than the simple returning of a value - so it will save a lot to differentiate lvalue usage from rvalue usage. However, it is impossible to tell whether operator[] is beeing invoked in an lvalue or an rvalue context from within operator[] - operator[] alone does not have the ability to determine the calling context.\nThe solution: we delay our lvalue-vs-rvalue actions until we see how the result of operator[] is used - by using proxy class to postpone our decision until after operator[] has returned (lazy evaluation, see MECpp item 7):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class String { // reference-counted strings public: class CharProxy { // proxy fro string chars  public: CharProxy(String\u0026amp; str, int index); // creation  CharProxy\u0026amp; operator=(const CharProxy\u0026amp; rhs); // lvalue uses  CharProxy\u0026amp; operator=(char c); // lvalue uses  operator char() const; // rvalue uses  private: String\u0026amp; theString; // string this proxy pertains to  int charIndex; // char within that string this proxy stands for  }; const CharProxy operator[](int index) const; // for const Strings  CharProxy operator[](int index); // for non-const Strings  ... friend class CharProxy; // CharProxy need access to private data member: value private: RCPtr\u0026lt;StringValue\u0026gt; value; };   Now let\u0026rsquo;s see how it works. Given reference-counted stirngs using proxies above String s1, s2;,\nFor rvalue usage Consider this statement cout \u0026lt;\u0026lt; s1[5];: s1[5] yields a CharProxy object, and compiler implicitly converts this CharProxy into char using the conversion operator declared in the CharProxy class. This is representitive of the CharProxy-to-char conversion that takes place for all CharProxy objects used as rvalues.\nFor lvalue usage Lvalue usage is handled differently:\nSay, for statement s2[5] = 'x';, the expression s2[5] yields a CharProxy object, which is the target of an assignment, so the assignment operator in the CharProxy class will be called - this is the crucial postponed step to differentiate writes from reads. Inside this CharProxy assignment operator, we know the string character for which the proxy stands is being used as an lvalue.\nSimilarly, the statement s1[3] = s2[7]; calls the assignment operator for two CharProxy objects, and inside the operator, we know the object on the left is being used as an lvalue and the object on the right as an rvalue.\nNow that we know exactly the context in which caller invokes the operator[], it is easy to implement them:\n1 2 3 4 5 6 7 8 9 10 11 12  const String::CharProxy String::operator[](int index) const { // return a const proxy  // Because CharProxy::operator= isn\u0026#39;t a const member function,  // the returned proxies can\u0026#39;t be used as the target of assignment, and this behavior is exactly what we want for const version of operator[]  return CharProxy(const_cast\u0026lt;String\u0026amp;\u0026gt;(*this), index); } String::CharProxy String::operator[](int index) { return CharProxy(*this, index); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  String::CharProxy::CharProxy(String\u0026amp; str, int index) : theString(str), charIndex(index) {} String::CharProxy::operator char() const { return theString.value-\u0026gt;data[charIndex]; } String::CharProxy\u0026amp; String::CharProxy::operator=(const CharProxy\u0026amp; rhs) { if (theString.value-\u0026gt;isShared()) { theString.value = new StringValue(theString.value-\u0026gt;data); } theString.value-\u0026gt;data[charIndex] = rhs.theString.value-\u0026gt;data[charIndex]; return *this; } String::CharProxy\u0026amp; String::CharProxy::operator=(char c) { if (theString.value-\u0026gt;isShared()) { theString.value = new StringValue(theString.value-\u0026gt;data); } theString.value-\u0026gt;data[charIndex] = c; return *this; }   Preventing implicit conversions in single-argument constructor Refer to MECpp item 5.\nLimitations   Taking the address\nIn general, taking the address of a proxy yields a different type of pointer than does taking the address of a real object. Thus, the statement char *p = \u0026amp;s1[1]; will cause error. To eliminate the problem, we\u0026rsquo;ll have to overload the address-of operators for CharProxy class:\n1 2 3 4 5 6 7 8 9 10  class String { public: ... class CharProxy { char * operator\u0026amp;(); const char * operator\u0026amp;() const; ... }; ... };   1 2 3 4 5 6 7 8 9 10 11 12 13  const char * String::CharProxy::operator\u0026amp;() { return \u0026amp;(theString.value-\u0026gt;data[charIndex]); } char * String::CharProxy::operator\u0026amp;() { if (theString.value-\u0026gt;isShared()) { theString.value = new StringValue(theString.value-\u0026gt;data); } theString.value-\u0026gt;markUnshareable(); return \u0026amp;(theString.value-\u0026gt;data[charIndex]); }     Integrating with templates\nIf we have a template for reference-counted arrays that use proxy classes to distringuish lvalue and rvalue invocations of operator[]:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  template\u0026lt;class T\u0026gt; class Array { public: class Proxy { public: Proxy(Array\u0026lt;T\u0026gt;\u0026amp; array, int index); Proxy\u0026amp; operator=(const T\u0026amp; rhs); operator T() const; ... }; const Proxy operator[](int index) const; Proxy operator[](int index); ... };   Then for Array\u0026lt;int\u0026gt; intArray;, we can\u0026rsquo;t make statement such as intArray[5] += 5; or ++intArray[5];, since operator+= and operator++ is not defined for proxy objects. To solve this problem, we have to define each of these functions for the Array\u0026lt;T\u0026gt;::Proxy, which, unfortunately, is a lot of work.\nSimilarly, we can\u0026rsquo;t invoke member functions on real objects through proxies. For an array taking Rational as elements (Array\u0026lt;Rational\u0026gt; array;), there is no way to invoke Rational\u0026rsquo;s member function like this:\n1 2  cout \u0026lt;\u0026lt; array[4].numerator(); // error! int denom = array[22].denominator(); // error!   The solution is similar: we need to overload these functions so that they also apply to proxies.\n  Passed to functions taking references to non-const objects\n1 2 3  void swap(char\u0026amp; a, char\u0026amp; b); String s = \u0026#34;+C+\u0026#34;; swap(s[0], s[1]); // won\u0026#39;t compile   A CharProxy may be implicitly converted into a char, but there is no conversion function to a char\u0026amp;. Further more, the char to which it may be converted can\u0026rsquo;t be bound to swap\u0026rsquo;s char\u0026amp; parameters, because that char is a temporary object (operator char returns by value,) and, as MECpp item 19 explains, temporary objects are refused to be bound to non-const reference parameters.\n  Implicit type conversions\nThe process where a proxy object implicitly converted into the real object it stands for, a user-defined conversion function is invoked. As MECpp item 5 explains, only one user-defined conversion function is used by compiler when implicitly converting a parameter at a call site into the type needed by the corresponding function parameter.\n ","description":"","id":110,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-30 Proxy Classes","uri":"https://nianze.ml/en/notes/2018/05/proxy-classes/"},{"content":"Reference counting is technique that allows multiple objects with the same value to share a sinple representation of that value.\nConsider a customized naive version of class String;: its assignment operator is implemented in a naive way:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class String { public: String(const char *value = \u0026#34;\u0026#34;); String\u0026amp; operator=(const String\u0026amp; rhs); ... private: char *data; }; String\u0026amp; String::operator=(const String\u0026amp; rhs) { if (this == \u0026amp;rhs) return *this; delete[] data; data = new char[strlen(rhs.data)+1]; strcpy(data, rhs.data); return *this; }   When we write statement a = b = c = d = e = \u0026quot;Hello\u0026quot;; where a, b, c, d and e are all String type, we get five objects, each with the same value \u0026ldquo;Hello\u0026rdquo;:\n┌───┐ ┌───────┐ ┌───┐ ┌───────┐ │ a │ --\u0026gt; │ Hello │ │ b │ --\u0026gt; │ Hello │ └───┘ └───────┘ └───┘ └───────┘ ┌───┐ ┌───────┐ ┌───┐ ┌───────┐ │ c │ --\u0026gt; │ Hello │ │ d │ --\u0026gt; │ Hello │ └───┘ └───────┘ └───┘ └───────┘ ┌───┐ ┌───────┐ │ e │ --\u0026gt; │ Hello │ └───┘ └───────┘ Ideally, we\u0026rsquo;d like to change the picture to look like this:\n┌───┐ │ a ├──┐ └───┘ | ┌───┐ | │ c ├──┤ └───┘ | ┌───┐ | ┌───────┐ │ e ├──┼─\u0026gt;│ Hello │ └───┘ | └───────┘ ┌───┐ | │ e ├──┤ └───┘ │ ┌───┐ │ │ e ├──┘ └───┘ In practice, we need to keep track of how many objects are sharing - refering to- a value to make sure the best time to destroy or modify the value \u0026ldquo;Hello\u0026rdquo;, so we need to add reference count into the picuture:\n┌───┐ │ a ├──┐ └───┘ | ┌───┐ | │ c ├──┤ └───┘ | ┌───┐ | ┌───┐ ┌───────┐ │ c ├──┼─\u0026gt;│ 5 ├───\u0026gt;│ Hello │ └───┘ | └───┘ └───────┘ ┌───┐ | │ d ├──┤ └───┘ │ ┌───┐ │ │ e ├──┘ └───┘ Implementing Reference Counting From the picture above, we can see we need one reference count per string value, instead of one per string object. This implies a decoupling between values and reference counts, leading to our first design: nesting a StringValue struct in the private part of String class, so that all the members of String class get full access to this inner data structure, while everybody else get denied (except friends of the class).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class String { public: ... private: struct StringValue { // holds a reference count and a string value  size_t refCount; char *data; StringValue(const char *initValue); ~StringValue(); } StringValue *value; // value of this String }; String::StringValue::StringValue(const char *initValue) : refCount(1) { data = new char[strlen(initValue)+1]; strcpy(data, initValue); } String::StringValue::~StringValue() { delete [] data; }   The primary purpose of StringValue is to provide a place to associate a particular value with a count of the number of String objects sharing that value, so there\u0026rsquo;s need to define copy constructor or assignment operator for this inner struct, and we provide the manipulation of the refCount field in String class:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  class String { public: String(const char *initValue = \u0026#34;\u0026#34;); String(const String\u0026amp; rhs); ~String(); String\u0026amp; operator=(const String\u0026amp; rhs); ... }; String::String(const char *initValue) : value(new StringValue(initValue)) {} String::String(const String\u0026amp; rhs) : value(rhs.value) { ++value-\u0026gt;refCount; } String::~String() { if (--value-\u0026gt;refCount == 0) delete value; } String\u0026amp; String::operator=(const String\u0026amp; rhs) { if (value == rhs.value) { return *this; } if (--value-\u0026gt;refCount == 0) { // destroy *this\u0026#39;s value  delete value; // if no one else is using it  } value = rhs.value; ++value-\u0026gt;refCount; return *this; }   Copy-on-write Now comes the troublesome one: an array-bracket operator([]), which allows individual characters within strings to be read and written:\n1 2 3 4 5 6  class String { public: const char\u0026amp; operator[](int index) const; // for const Strings  char\u0026amp; operator[](int index); // for non-const Strings  ... };   It\u0026rsquo;s straightforward to implement the const version, because it\u0026rsquo;s a read-only operation:\n1 2 3 4  const char\u0026amp; String::operator[](int index) const { return value-\u0026gt;data[index]; // here\u0026#39;s no sanity checking on index, just like C++ tradition; easy to add though }   However, since non-const version of operator[] might be called to write a character, the implementation must consider more scenario to avoid modifying the value of other String objects that happen to be sharing the same StringValue object - since there\u0026rsquo;s no way for C++ compilers to tell us whether a particular use of operator[] is for a read or a write, we must be pessimistic and assume all calls to the non-const operator[] are for writes (Proxy classes casn help us differentiate reads from writes, see MECpp item 30.)\n1 2 3 4 5 6 7 8 9 10  char\u0026amp; String::operator[](int index) { // if sharing a value with other String obj.  // break off a separate copy of the value  if (value-\u0026gt;refCount \u0026gt; 1) { --value-\u0026gt;refCount; value = new StringValue(value-\u0026gt;data); } return value-\u0026gt;data[index]; }   This technique - to share a value with other objects until we have to write on our own copy of the value - is the well-knwon copy-on-write, which is a specific example of lazy evaluation (MECpp item 17), which is a more general approach to efficiency.\nPointers, References, and Copy-on-write Consider this code:\n1 2 3  String s1 = \u0026#34;Hello\u0026#34;; char *p = \u0026amp;s1[1]; Stirng s2 = s1;   The data structure looks like this:\n┌───┐ │s1 ├──┐ ┌───┐ ┌───────┐ └───┘ ├─\u0026gt;│ 2 ├───\u0026gt;│ Hello │ ┌───┐ │ └───┘ └───────┘ │s2 ├──┘ ↑ └───┘ p Now there is a dangerous situation, where pointer p modifies both s1 and s2:\n1  *p = \u0026#39;x\u0026#39;; // modifies both s1 and s2   To eliminate the problem, we add a flag to each StringValue object indicating whether that object is shareable. Initially, the flag is set to true (indicating shareable), but turn it off whenever the non-const operator[] is invoked on the value represented by that object (once the flag is set to false, it stays that way forever).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  class String { public: struct StirngValue { size_t refCount; bool shareable; // add this line  char *data; ... }; ... }; String::StringValue::StringValue(const char *initValue) : refCount(1), shareable(true) // add this line { data = new char[strlen(initValue) + 1]; strcpy(data, initValue); } String::String(const String\u0026amp; rhs) { if (rhs.value-\u0026gt;shareable) { // add this checking  value = rhs.value; ++value-\u0026gt;refCount; } else { value = new StringValue(rhs.value-\u0026gt;data); } } char\u0026amp; String::operator[](int index) { if (value-\u0026gt;refCount \u0026gt; 1) { --value-\u0026gt;refCount; value = new StringValue(value-\u0026gt;data); } value-\u0026gt;shareable = false; // add this  return value-\u0026gt;data[index]; }   A Reference-Counting Base class Reference counting is useful for more than just strings, so it\u0026rsquo;s good practice to separate reference counting code in a context-independent manner. This leads us to the design of a base class RCObject. Any class wishing to take advantage of automatic reference counting may inherit from this class. Basically, for general purpose usage, RCObject class should include\n the reference count, as well as functions for incrementing and decrementing that count. the code for destroying a value when it is no longer in use (count == 0) a field that keeps track of whether this value is shareable, as well as functions to query this flag and set it to false  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class RCObject { public: RCObject(); RCObject(const RCObject\u0026amp; rhs); RCObject\u0026amp; operator=(const RCObject\u0026amp; rhs); virtual ~RCObject() = 0; // virtual shows this class is designed as a base class; pure virtual so that this class should be used only as a base class  void addReference(); void removeReference(); void markUnshareable(); bool isShareable() const; bool isShared() const; private: size_t refCount; bool shareable; };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  RCObject::RCObject() : refCount(0), shareable(true) {} RCObject::RCObject(const RCObject\u0026amp;) : refCount(0), shareable(true) {} RCObject\u0026amp; RCObject::operator=(const RCObject\u0026amp;) { return *this; } RCObject::~RCObject() {} // pure virtual dtor still need to be impl. see MECpp item 33  void RCObject::addReference() { ++refCount; } void RCObject::removeReference() { if(--refCount == 0) delete this; } void RCObject::markUnshareable() { shareable = false; } bool RCObject::isShareable() const { return shareable; } bool RCObject::isShared() const { return refCount \u0026gt; 1; }   In this design, there are a few things worth noting:\n The refCount is set to 0 in both constructors to simplifies the set up process for the creaters of RCObjects when they set refCount to 1 themselves Copy constructor sets refCount to 0, because this function is meant to create a new object representing a value, which is always unshared and referenced only by their creator (who will set up refCount properly later). The assignment operator is unlikely to be called, since RCObject is a base class for a shared value object, which means in a reference counting system, it is usually the object pointing to these base-class objects that are assigned to one another, with only refCount being modified as a result. We don\u0026rsquo;t declare assignment operator private, because there\u0026rsquo;s a chance that someone does have a reason to allow assignment of reference-counted values(e.g., change the string value stored inside StringValue in the example above), so we adopt this \u0026ldquo;do nothing\u0026rdquo; implementation, which is exactly the right thing to do, because the assignment of value objects doesn\u0026rsquo;t affect the reference count of objects pointing to either lhs or rhs of assignment operation: this base-class level assignment is meant to change lhs\u0026rsquo;s value, meaning all the objects pointing to lhs now pointing to a new value. Here we use delete this; for removeReference, which is safe only if we know that *this is a heap object. In order to ensure this, we might need technichs discussed in MECpp item 27 to restrict RCObject to be created only on the heap1.  Now taking advantage of this new reference-counting base class, we modify StringValue to inherit its reference counting capabilities from RCObject:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class String { private: struct StringValue: public RCObject { char *data; StringValue(const char *initValue); ~StringValue(); }; ... }; String::StringValue::StringValue(const char *initValue) { data = new char[strlen(initValue) + 1]; strcpy(data, initValue); } String::StringValue::~StringValue() { delete [] data; }   After this change, RCObject now provide the manipulation ability of the refCount field, instead of StringValue.\nAutomating Reference Count Manipulations The RCObject class only gives us a place to store a reference count, as well as the member functions to manipulate the refCount field. However, the calls to these functions must still be mannually inserted in other classes: String copy constructor and assignment operator need to call addReference and removeReference on StringValue objects, which is not good practice for reuse.\nTo remove such manual works, we introduce smart pointer for help:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // template class for smart pointers-to-T object. T must // support the RCObject interface, typically by inheriting from RCObject template\u0026lt;class T\u0026gt; class RCPtr { public: RCPtr(T* realPtr = 0); RCPtr(const RCPtr\u0026amp; rhs); ~RCPtr(); RCPtr\u0026amp; operator=(const RCPtr\u0026amp; rhs); T* operator-\u0026gt;() const; T\u0026amp; operator*() const; private: T *pointee; // dumb pointer this object is emulating  void init(); // common init. code };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  template\u0026lt;class T\u0026gt; RCPtr\u0026lt;T\u0026gt;::RCPtr(T* realPtr): pointee(realPtr) { init(); } template\u0026lt;class T\u0026gt; RCPtr\u0026lt;T\u0026gt;::RCPtr(const RCPtr\u0026amp; rhs): pointee(rhs.pointee) { init(); } template\u0026lt;class T\u0026gt; void RCPtr\u0026lt;T\u0026gt;::init() { if (pointee == 0) { return; } if (pointee-\u0026gt;isShareable() == false) { pointee = new T(*pointee); } pointee-\u0026gt;addReference(); // always add a new reference to the value } template\u0026lt;class T\u0026gt; RCPtr\u0026lt;T\u0026gt;\u0026amp; RCPtr\u0026lt;T\u0026gt;::operator=(const RCPtr\u0026amp; rhs) { if (pointee != rhs.pointee) T *oldPointee = pointee; pointee = rhs.pointee; init(); // if possible, share it; else make own copy  if (oldPointee) { oldPointee-\u0026gt;removeReference(); } } return *this; } template\u0026lt;class T\u0026gt; RCPtr\u0026lt;T\u0026gt;::~RCPtr() { if (pointee) pointee-\u0026gt;removeReference(); } template\u0026lt;class T\u0026gt; T* RCPtr::operator-\u0026gt;() const { return pointee; } template\u0026lt;class T\u0026gt; T\u0026amp; RCPtr::operator*() const { return *pointee; }   There are three assumptions in this implementation:\n T has a deep-copying constructor, because pointee = new T(*pointee); will call T\u0026rsquo;s copy constructor. In the example above, String::StringValue lack such a user-defined copy constructor, and compiler generated default copy constructor will not copy char* string data points to, so we need to add a customized version of copy constructor:  1 2 3 4 5  String::StringValue::StirngValue(const StringValue\u0026amp; rhs) { data = new char(strlen(rhs.data) + 1); strcpy(data, rhs.data); }   For the same statement calling T\u0026rsquo;s copy constructor, we assume the type of *pointee is T rather than T\u0026rsquo;s derived class. If, however, chances are poinee might point to T\u0026rsquo;s derived class instances, we need to use a virtual copy constructor. T should prove all the functionality that RCObject does, either or not by inheriting from RCObject.  Puting Everyting Together  ┌──────────┐ ┌──────────┐ │ RCObject │ │ String │ │ class │ │ object │ └──────────┘ │ │ ↑ public inheritance │ ┌─────┐ │ ┌───────────┐ ┌────────────┐ │ │RCPtr├──┼────────\u0026gt;│StringValue├────────\u0026gt;| Heap Memory| │ └─────┘ │ pointer │ object | pointer └────────────┘ └──────────┘ └───────────┘ The class declaration looks like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  template\u0026lt;class T\u0026gt; class RCPtr { public: RCPtr(T* realPtr = 0); RCPtr(const RCPtr\u0026amp; rhs); RCPtr\u0026amp; operator=(const RCPtr\u0026amp; rhs); ~RCPtr(); T* operator-\u0026gt;() const; T\u0026amp; operator*() const; private: T *pointee; void init(); }; class RCObject { public: RCObjet(); RCObject(const RCObject\u0026amp; rhs); RCObject\u0026amp; operator=(const RCOBject\u0026amp; rhs); virtual ~RCObject() = 0; void addReference(); void removeReference(); void markUnshareable(); bool isShareable() const; bool isShared() const; private: size_t refCount; bool shareable; }; class String { public: String(const char *value = \u0026#34;\u0026#34;); const char\u0026amp; operator[](int index) const; char\u0026amp; operator[](int index); private: // class representing string value  struct StringValue: public RCObject { char *data; StringValue(const char *initValue); StringValue(const StringValue\u0026amp; rhs); void init(const char *initValue); ~StringValue(); }; RCPtr\u0026lt;StringValue\u0026gt; value;   It is worth to note that we don\u0026rsquo;t need the copy constructor or assignment operator for String anymore: compiler-generated copy constructor for Stirng will automatically call the copy constructor for Stirng\u0026rsquo;s RCPtr member, and the copy constructor for that class will perform all the necessary manipulations of the StringValue object, including its reference count, and the same goes for assignment and destruction. That\u0026rsquo;s why it is called smart pointer.\nNow here is all the implementation:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  RCObject::RCObject() : refCount(0), shareable(true) {} RCObject::RCObject(const RCObject\u0026amp;) : refCount(0), shareable(true) {} RCObject\u0026amp; RCObject::operator=(const RCObject\u0026amp;) { return *this; } RCObject::~RCObject() {} void RCObject::addReference() { ++refCount; } void RCObject::removeReference() { if (--refCount == 0) delete this; } void RCObject::markUnshareable() { shareable = false; } bool RCObject::isShareable() const { return shareable; } bool RCObject::isShared() const { return refCount \u0026gt; 1; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  template\u0026lt;class T\u0026gt; void RCPtr\u0026lt;T\u0026gt;::init() { if (pointee == 0) { return; } if (pointee-\u0026gt;isShareable() == false) { pointee = new T(*pointee); } pointee-\u0026gt;addReference(); } template\u0026lt;class T\u0026gt; RCPtr\u0026lt;T\u0026gt;::RCPtr(T* realPtr): pointee(realPtr) { init(); } template\u0026lt;class T\u0026gt; RCPtr\u0026lt;T\u0026gt;::RCPtr(const RCPtr\u0026amp; rhs): pointee(rhs.pointee) { init(); } template\u0026lt;class T\u0026gt; RCPtr\u0026lt;T\u0026gt;\u0026amp; RCPtr\u0026lt;T\u0026gt;::operator=(const RCPtr\u0026amp; rhs) { if (pointee != rhs.pointee) T *oldPointee = pointee; pointee = rhs.pointee; init(); // if possible, share it; else make own copy  if (oldPointee) { oldPointee-\u0026gt;removeReference(); } } return *this; } template\u0026lt;class T\u0026gt; RCPtr\u0026lt;T\u0026gt;::~RCPtr() { if (pointee) pointee-\u0026gt;removeReference(); } template\u0026lt;class T\u0026gt; T* RCPtr::operator-\u0026gt;() const { return pointee; } template\u0026lt;class T\u0026gt; T\u0026amp; RCPtr::operator*() const { return *pointee; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  void String::StringValue::init(const char *initValue) // ctor and deep copy ctor share this same init function { data = new char[strlen(initValue) + 1]; strcpy(data, initValue); } String::StringValue::StringValue(const char *initValue) { init(initValue); } String::StringValue::StringValue(const StringValue\u0026amp; rhs) { init(rhs.data); } String::StringValue::~StringValue() { delete [] data; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  String::String(const char *initValue) : value(new StringValue(initValue)) {} const char\u0026amp; String::operator[](int index) const { return value-\u0026gt;data[index]; } char\u0026amp; String::operator[](int index) { if (value-\u0026gt;isShared()) { value = new StirngValue(value-\u0026gt;data); } value-\u0026gt;markUnshareable(); return value-\u0026gt;data[index]; }   Adding Refenrence Counting to Existing Classes Given some class Widget that\u0026rsquo;s in a library we can\u0026rsquo;t modify, and suppose we want to apply the benefits of reference counting to Widget without being able to inherit Widget from RCObject, we solve the problem with an additional level of indirection by adding a new class CountHolder, which does three jobs:\n Hold the reference Inherit from RCObject Contain a pointer to a Widget  The only thing left to do is just an equivalent smart pointer as RCPtr, and we call it RCIPtr, where \u0026ldquo;I\u0026rdquo; stands for \u0026ldquo;indirect\u0026rdquo;. Thus, we get someting like this:\n ┌──────────┐ ┌──────────┐ │ RCObject │ │ RCWidget │ │ class │ │ object │ └──────────┘ │ ┌──────┐ │ ↑ public inheritance │ |RCIPtr| │ ┌───────────┐ ┌─────────────┐ │ |Object├─┼────────\u0026gt;│CountHolder├────────\u0026gt;|Widget Object| │ └──────┘ │ pointer │ object | pointer └─────────────┘ └──────────┘ └───────────┘ Since here CountHolder is just an implementation detial of RCIPtr, we can simply nested it inside RCIPtr, just as how StringValue relates with String.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  template\u0026lt;class T\u0026gt; class RCIPtr { public: RCIPtr(T* realPtr = 0); RCIPtr(const RCIPtr\u0026amp; rhs); ~RCIPtr(); RCIPtr\u0026amp; operator=(const RCIPtr\u0026amp; rhs); T* operator-\u0026gt;() const; T\u0026amp; operator*() const; RCObject\u0026amp; getRCObject(); // give clients access  { return *counter; } // isShared, etc. private: struct CountHolder: public RCObject { ~CountHolder() { delete pointee; } T *pointee; }; CountHolder *counter; void init(); }; template\u0026lt;class T\u0026gt; void RCIPtr\u0026lt;T\u0026gt;::init() { if (counter-\u0026gt;iShareable() == false) { T *oldValue = counter-\u0026gt;pointee; counter = new CountHolder; counter-\u0026gt;pointee = oldValue ? new T(*oldValue) : 0; } counter-\u0026gt;addReference(); } template\u0026lt;class T\u0026gt; RCIPtr\u0026lt;T\u0026gt;::RCIPtr(T* realPtr) : counter(new CountHolder) { counter-\u0026gt;ponitee = realPtr; init(); } template\u0026lt;class T\u0026gt; RCIPtr\u0026lt;T\u0026gt;::RCIPtr(const RCIPtr\u0026amp; rhs) : counter(rhs.counter) { init(); } template\u0026lt;class T\u0026gt; RCIPtr\u0026lt;T\u0026gt;::~RCIPtr() { counter-\u0026gt;removeReference(); } template\u0026lt;class T\u0026gt; RCIPtr\u0026lt;T\u0026gt;\u0026amp; RCIPtr\u0026lt;T\u0026gt;::operator=(const RCIPtr\u0026amp; rhs) { if (counter != rhs.counter) { counter-\u0026gt;removeReference(); counter = rhs.counter; init(); } return *this; } template\u0026lt;class T\u0026gt; T* RCIPtr\u0026lt;T\u0026gt;::operator-\u0026gt;() const { return counter-\u0026gt;pointee; } template\u0026lt;class T\u0026gt; T\u0026amp; RCIPtr\u0026lt;T\u0026gt;::operator*() const { return *(counter-\u0026gt;pointee); }   Then, for a library class Widget with following interface:\n1 2 3 4 5 6 7 8 9 10 11  class Widget { public: Widget(int size); Widget(const Widget\u0026amp; rhs); ~Widget(); Widge\u0026amp; operator=(const Widget\u0026amp; rhs); void doThis(); int showThat() const; };   We can implementing wrapper RCWidget by simply forwarding the call through underlying RCIPtr to a Widgetobject:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class RCWidget { public: RCWidget(int size): value(new Widget(size)) {} void doThis() { if (value.getRCObject().isShared()) { value = new Widget(*value); } value-\u0026gt;doThis(); } int showThat() const { return value-\u0026gt;showThat(); } private: RCIPtr\u0026lt;Widget\u0026gt; value; };   As with Stirng class, there\u0026rsquo;s no need to write copy constructor, assignment operator, or destructor, because the default versions do the right thing.\n In this example, we guarantee the value objects should be created only via new by declaring StringValue as private in String, so only String can create StringValue objects and the auther of the String class is able to ensure all such objects are allocated via new.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":111,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-29 Reference Counting","uri":"https://nianze.ml/en/notes/2018/05/reference-counting/"},{"content":"Smart pointers are designed to look, act, and feel like built-in pointers, but to offer greater functionality.\nAdvantages of smart pointers With the help of smart pointers, we gain control over the following aspects of pointer behavior:\n Construction and destrucrtion (default value, reference counting, etc) Copying and assignment (deep copy, not allowed to copy, etc) Dereferencing (lazy fetching, etc)  Using smart pointer in client perspective Consider a distributed system in which some objects are local and some are remote. We can use smart pointer to manage the local and remote objects handling in order to offer such an illusion that all objects appear to be located in the same place.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  template\u0026lt;class T\u0026gt; // template for smart ptrs class DBPtr { // to obj. in a distributed DB public: DBPtr(T *realPtr = 0); // create a smart ptr to a DB obj given a local dumb pointer \tDBPtr(DataBaseID id); // create a smart ptr to a DB obj given its unique DB identifier \t... // other smart ptr functions }; class Tuple { // class for database tuples public: ... void displayEditDialog(); // present a graphical dialog box allowing a user to edit the typle \tbool isValid() const; // return whether *this passes validity check }; // class template for making log entries whenever a T object is modified template\u0026lt;class T\u0026gt; class LogEntry { public: LogEntry(const T\u0026amp; objectToBeModified); ~LogEntry(); }; void editTuple(DBPtr\u0026lt;Tuple\u0026gt;\u0026amp; pt) { LogEnty\u0026lt;Tuple\u0026gt; entry(*pt); // make log entry for this editing operation \t// repeatedly display edit dialog until valid values are provided \tdo { pt-\u0026gt;displayEditDialog(); } while (pt-\u0026gt;isValid() == false) }   The tuple to ber edited inside editTuple may be physically located on a remote machine, but the programmer writing editTuple need not be converned with such matters. Wrapped by objects, all kinds of tuples are accessed through smart pointers, which act just like built-in pointers (except for how they\u0026rsquo;re declared).\nNotice the use of LogEntry object here is to take the advantage of LogEntry\u0026rsquo;s constructor and destructor to begin and end the log entry, which is more robust in the face of exceptions than explicitly calling functions (MECpp item 9).\nIn a word, clients of smart pointers are supposed to be able to treat them as dumb pointers.\nConstruction, assignment, and destruction of smart pointers Construction of a smart pointer is usually straightforward: locate an object to point to, then make the smart pointer\u0026rsquo;s internal dumb pointer point there. If no object can be located, set the internal pointer to 0 or signal an error (by throwing an exception).\nHowever, the issue of ownership makes it complicated to implement a smart pointer\u0026rsquo;s copy constructor, assignment operator(s), and destructor: depending on wheter a smart pointer owns the object it points to, should it delete the object when the smart pointer itself is destroyed?\n  if we just copied the internal dumb pointer in copy constructor and call delete in destructor, we end up with two smart pointers pointing to the same object, resulting to multiple deletes, which is undefined behavior.\n  if we create a new copy of what was pointed to by calling new in the copy constructor, we may have to face an unacceptable performance hit for the creation (and later destruction) of the new object. Further more, we wouldn\u0026rsquo;t know what type of object to create, because a smart pointer of type T might point to an object of a type derived from T. Virtual constructors can help solve this problem, but it seems inappropriate to require their use in a general-purpose smart pointer class.\n  The problem would vanish if we prohibit copying and assignment, but a more flexible solution was adopted by the auto_ptr template from the standard C++ library: object ownership is transferred when an auto_ptr is copied or assigned:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  template\u0026lt;class T\u0026gt; class auto_ptr { public: auto_ptr(T *ptr = 0): pointee(ptr) {} auto_ptr(auto_ptr\u0026lt;T\u0026gt;\u0026amp; rhs); // copy constructor \tauto_ptr\u0026lt;T\u0026gt;\u0026amp; operator=(auto_ptr\u0026lt;T\u0026gt;\u0026amp; rhs); // assignment operator \t~auto_ptr\u0026lt;T\u0026gt;() { delete pointee; } private: T *pointee; }; template\u0026lt;class T\u0026gt; auto_ptr\u0026lt;T\u0026gt;::auto_ptr(auto_ptr\u0026lt;T\u0026gt;\u0026amp; rhs) { pointee = rhs.pointee; rhs.pointee = 0; } template\u0026lt;class T\u0026gt; auto_ptr\u0026lt;T\u0026gt;\u0026amp; auto_ptr\u0026lt;T\u0026gt;::operator=(auto_ptr\u0026lt;T\u0026gt;\u0026amp; rhs) { if (this == \u0026amp;rhs) return *this; delete pointee; pointee = rhs.pointee; rhs.pointee = 0; return *this; }   For this design, there are three points woth noting:\n1. Pass by reference to const Because object ownership is transferred when auto_ptr\u0026rsquo;s copy constructor is called, passing auto_ptrs by value is often a very bad idea:\n1 2 3 4 5 6 7 8 9  void printTreeNode(ostream\u0026amp; s, auto_ptr\u0026lt;TreeNode\u0026gt; p) { s \u0026lt;\u0026lt; *p; } int main() { auto_ptr\u0026lt;TreeNode\u0026gt; ptn(new TreeNode); ... printTreeNode(cout, ptn); // pass auto_ptr by value }   When printTreeNode\u0026rsquo;s parameter p is initialized by calling auto_ptr\u0026rsquo;s copy constructor, ownership of the object pointed to by ptn is transferred to p. After printTreeNode finishes execution, p goes out of scope and its destructor deletes what it points to, so ptn no longer points to anything (its underlying dumb pointer is null). This is rarely what we want to do.\nInstead, pass-by-reference-to-const:\n1 2 3  // this function behaves much more intuitively void printTreeNode(ostream\u0026amp; s, const auto_ptr\u0026lt;TreeNode\u0026gt;\u0026amp; p) { s \u0026lt;\u0026lt; *p; }   Since this is pass by reference, no constructor is called to initialize p, and ptn retains ownership of the object it points after function execution.\n2. Unconventional copy constructor and assignment operator Normally the copy constructor and assignment operator take const parameters during the copy or the assignment. However, auto_ptr objects are modified if they are copied or are the source of an assignment, so we don\u0026rsquo;t declare const here for the copy constructor and assignment operator in auto_ptr.\n3. No ownership testing in desturctor An auto_ptr always owns what it points to, so there is no need for the ownership test in destructor. However, a smart pointers that employs reference counting (MECpp item 29) must adjust a reference count before detrmining whether it has the right to delete what it points to, so their destructor often looks like this:\n1 2 3 4 5 6 7  tempalte\u0026lt;class T\u0026gt; SmartPtr\u0026lt;T\u0026gt;::~SmartPtr() { if (*this owns *pointee) { delete pointee; } }   Implementing the dereferencing operators operator* 1 2 3 4 5 6  template\u0026lt;class T\u0026gt; T\u0026amp; SmartPtr\u0026lt;T\u0026gt;::operator*() const { perform \u0026#34;smart pointer\u0026#34; processing; return *pointee;\t}   A few things woth noting:\n The \u0026ldquo;smart pointer\u0026rdquo; processing does whatever is needed to initialize or otherwise make pointee valid. For example, if lazy fetching is being used (MECpp item 17), the process may conjure up a new object for pointee to point to. The operator* returns a reference to the pointed-to object, instead of an object. This is for concerns of both correctness and efficiency.  Correctness: if returning an object, this is possible for slicing problem - see MECpp item 13 - where a T object is returned instead of an actual derived class object that is expected. Efficiency: there is no need to construcrt a temporary object (MECpp 19), so returning a reference is more efficient.   The result of dereferencing a null pointer is undefined, so we are free to do anything we want if operator* is invoked with a null smart pointer. (i.e., throw an exception, call abort, etc)  operator-\u0026gt; When we call operator-\u0026gt; in the statement pt-\u0026gt;displayEditDialog();, the compilers treat it as:\n1  (pt.operator-\u0026gt;())-\u0026gt;displayEditDialog();   This means it must be legal to apply the member-selection operator(-\u0026gt;) to whatever operator-\u0026gt; returns, leading to only two options:\n a dumb pointer to an object another smart pointer object  Most of the time we want to return an ordinary dumb pointer, so the implementation for operator-\u0026gt; is:\n1 2 3 4 5 6  template\u0026lt;class T\u0026gt; T* SmartPtr::operator-\u0026gt;() const { perform \u0026#34;smart pointer\u0026#34; processing return pointee; }   Note that since this function returns a pointer, virtual function calls via operator-\u0026gt; will behave the way they\u0026rsquo;re supposed to.\nTesting smart pointers for nullness So far we can not do the following operation to find out if a smart pointer is null:\n1 2 3 4 5  SmartPtr\u0026lt;TreeNode\u0026gt; ptn; ... if (ptn == 0) ... // error! if (ptn) ... // error! if (!ptn) ... // error!   If we want to make smart pointer act like dumb pointers when testing for nullness, an additional isNull member function will not be ideal solution. We may be attempted to provide an implicit conversion operator: operator void*(), but this will also introduce the draback of letting function calls succeed that most programmers would expect to fail (see MECpp item 5). In particular, it allows comparisons of smart pointers of completely different types:\n1 2 3 4  SmartPtr\u0026lt;Apple\u0026gt; pa; SmartPtr\u0026lt;Orange\u0026gt; po; ... if (pa == po) ... // this compiles!   This compiles because both smart pointers can be implicitly converted into void* pointers, and there is a built-in comparison function for built-in pointers. Similarly, even if we advocate conversion to const void* or bool, neither of these variations eliminates the problem of allowing mixed-type comparisons. There is simply too much conversion freedom in this wild solution.\nThere is a middle middle ground that allows us to offer a reasonable syntactic form for testing for nullness while minimizing the chances of accidentally comparing smart pointers of of different types. That is to overload operator! to return true if and only if the smart pointer on which it\u0026rsquo;s invoked is null:\n1 2 3 4 5 6  template\u0026lt;class T\u0026gt; class SmartPtr { public: ... bool operator!() const; // returns true if and only if the smart ptr is null };   This will lead to:\n1 2 3  if (!ptn) ... // fine if (ptn == 0) ... // still an error if (ptn) ... // still an error   And the only risk for mixed-type comparisons is statements such as this:\n1 2  ... if (!pa == !po) ... // this still compiles   Fortunately, programmers usually don\u0026rsquo;t write code like this.\nConverting smart pointers to dumb pointers When a dump pointer is expected for some lagacy libraries (say normalize(Tuple *pt);), we can not simply call the library function with a smart pointer-to-Tuple, because there is no way to convert a DBPtr\u0026lt;Tuple\u0026gt; to a Tuple*. We can make it work by doing this:\n1  normalize(\u0026amp;*pt); // gross, but legal   but apparently this is not elegant.\nA dangerous solution will be to add to the smart pointer-to-T template an implicit conversion operator to a dumb pointer-to-T:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  template\u0026lt;class T\u0026gt; class DBPtr{ public:\t... operator T*() { return pointee; } ... }; DBPtr\u0026lt;Tuple\u0026gt; pt; ... normalize(pt); // this now works if (pt == 0) ... // fine, too if (pt) ... // fine, too if (!pt) ... // fine, too   However, as stated in MECpp item 5, there\u0026rsquo;s dark side to such conversion function: it\u0026rsquo;s so easy for clients to get access to dumb pointers that they bypass all the smart behavior (such as reference-counting ability) our pointer-like objects designed to provide, which will almost certainly lead to disaster (such as bookkeeping errors that corrupt the reference-counting data structures):\n1 2 3 4 5  void processTuple(DBPtr\u0026lt;Tuple\u0026gt;\u0026amp; pt) { Tuple *rawTuplePtr = pt; // convert DBPtr\u0026lt;Tuple\u0026gt; to Tuple* \tuse rawTuplePtr to modify the tuple; }   Besides, even we provide such implicit conversion operator, our smart pointer will never be truly interchangeable with the dumb pointer: the conversion from a smart pointer to a dumb pointer is a user-defined conversion, and compilers are forbidden from applying more than one user-defined conversion at a time. Following example shows this difference, where conversion from DBPtr\u0026lt;Tuple\u0026gt; to TupleAccessors calls for two user-defined conversions (1. DBTpr\u0026lt;Tuple\u0026gt; -\u0026gt; Tuple*; 2. Tuple* -\u0026gt; TupleAccessors), which are prohibited by the language:\n1 2 3 4 5 6 7 8 9 10 11 12  class TupleAccessors { public: TupleAccessors(const Tuple *pt); // this ctor also acts as a type-conversion operator \t... }; TupleAccessors merge(const TupleAccessors\u0026amp; ta1, const TupleAccessors\u0026amp; ta2); ... Tuple *pt1, *pt2; merge(pt1, pt2); // fine, both pointers are converted to TupleAccessors objects ... DBPtr\u0026lt;Tuple\u0026gt; smart_pt1, smart_pt2; merge(smart_pt1, smart_pt2); // error! no way to convert smart_pt1 and smart_pt2 to TupleAccessors implicitly   Moreover, implicit conversion functino makes it possible to let evil statement compile, which will almost certainly break our program later1:\n1 2 3  DBPtr\u0026lt;Tuple\u0026gt; pt = new Tuple; ... delete pt; // this compiles   All in all, keep in mind the bottom line: don\u0026rsquo;t provide implicit conversion operators to dumb pointers unless there is a compelling reason to do so.\nSmart pointers and inheritance-based type conversions Given the following public inheritance hierarchy:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class MusicProduct { public: MusicProduct(const string\u0026amp; title); virtual void play() const = 0; virtual void displayTitle() const = 0; }; class Cassette: public MusicProduct { public: Cassette(const string\u0026amp; title); virtual void play() const; vitual void displayTitle() const; ... }; class CD: public MusicProduct { public: CD(const string\u0026amp; title); virtual void play() const; virtual void displayTitle() const; ... };   It is expected that the virtual function will work properly with dumb pointers:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  void displayAndPlay(const MusicProduct* pmp, int numTimes) { for (int i = 1; i \u0026lt;= numTimes; ++i) { pmp-\u0026gt;displayTitle(); pmp-\u0026gt;play(); } } Cassette *funMusic = new Cassette(\u0026#34;Alapalooza\u0026#34;); CD *nightmareMusic = new CD(\u0026#34;Disco Hits of the 70s\u0026#34;); displayAndPlay(funMusic, 10); displayAndPlay(nightmareMusic, 0);   However, as far as compilers are converned, SmartPtr\u0026lt;CD\u0026gt;, SmartPtr\u0026lt;Cassette\u0026gt;, and SmartPtr\u0026lt;MusicProduct\u0026gt; are three seperate classes without any relationship to one another, so if we pass an object of type SmartPtr\u0026lt;CD\u0026gt; into a function with signature void displayAndPlay(const SmartPtr\u0026lt;MusicProduct\u0026gt;, int), there will be error.\nManually adding implicit conversion operator A naive solution: adding into each smart pointer class an implicit type conversion operator. Take SmartPtr\u0026lt;Cassette\u0026gt; for example:\n1 2 3 4 5 6  class SmartPtr\u0026lt;Cassette\u0026gt; { public: operator SmartPtr\u0026lt;MusicProduct\u0026gt;() { return SmartPtr\u0026lt;MusicProduct\u0026gt;(pointee); } ... };   Yet there are two drawbacks in this design:\n manually adding the necessary implicit type conversion operators specializes the SmartPtr class instantiations, which defeats the purpose of templates too many conversion operators to add - given a deep inheritance hierarchy, we must provide a conversion operator for each base class from that object directly or indirectly inherits (again, compilers are prohibited from employing more than one user-defined type conversion function at a time.)  Generating conversion operators via member templates The right way to take is to take advantage of member function templates (or just member templates):\n1 2 3 4 5 6 7 8 9 10 11 12 13  template\u0026lt;class T\u0026gt; class SmartPtr { public: SmartPtr(T* realPtr = 0); T* operator-\u0026gt;() const; T* operator*() const; template\u0026lt;class newType\u0026gt; // template function for \toperator SmartPtr\u0026lt;newType\u0026gt;() // implicit conversion ops. \t{ return SmartPtr\u0026lt;newType\u0026gt;(pointee); } };   Here\u0026rsquo;s what happens:\n Compiler needs to convert a smart pointer-to-T object into a smart pointer-to-base-class-of-T Compiler checks the class definition for SmartPtr\u0026lt;T\u0026gt; to see if the requisite conversion operator is declared -\u0026gt; it is not Compiler then checks to see if there\u0026rsquo;s a member function template it can instantiate that would perform the wanted conversion -\u0026gt; it finds a template Compiler instantiates the template with newType bound to the base class of T Given this instantiated member function, compiler finds it legal to pass the dumb pointer pointee to the constructor for the smart pointer-to-base-of-T, because T-type pointee is legal to be converted into a pointer to its (public or protected) base classes The code compiles -\u0026gt; the implicit conversion from smart pointer-to-T to smart pointer-to-base-of-T succeeds  Note that this implicit conversion will succeed for any legal implicit conversion between pointer types: if (and only if) a dumb pointer type T1* can be implicitly converted to another pointer type T2*, we can implicitly convert a smart pointer-to-T1 to a smart pointer-to-T2.\nHowever, there\u0026rsquo;s still a drawback: suppose following augmented MusicProduct hierarchy:\n ┌──────────────┐ │ MusicProduct │ └──────────────┘ ↗ ↖ ┌──────────┐ ┌────┐ │ Cassette │ │ CD │ └──────────┘ └────┘ ↑ ┌───────────┐ │ CasSingle │ └───────────┘ 1 2 3 4 5 6 7 8  template\u0026lt;class T\u0026gt; // as above, including member tempate class SmartPtr {...}; void displayAndPlay(const SmartPtr\u0026lt;MusicProduct\u0026gt;\u0026amp; pmp, int howMany); void displayAndPaly(const SmartPtr\u0026lt;Cassette\u0026gt;\u0026amp; pc, int howMany); SamrtPtr\u0026lt;CasSingle\u0026gt; dumbMusic(new CasSingle(\u0026#34;Achy Breaky Heart\u0026#34;)); displayAndPlay(dumbMusic, 1); // error!   When invoking displayAndPlay with a SmartPtr\u0026lt;CasSingle\u0026gt;, according to the inheritance hierarchy, we may expect the SmartPtr\u0026lt;Cassette\u0026gt; function to be chosen, because CasSingle inherits directly from Casssette and only indirectly from MusicProduct. However, it will only work in the case of dumb pointers. For our smart pointers, as far as C++ compilers are concerned, both calls to conversion functions here are equally good (the conversion from SmartPtr\u0026lt;CasSingle\u0026gt; to SmartPtr\u0026lt;Cassette\u0026gt; is no better than the conversion to SmartPtr\u0026lt;MusicProduct\u0026gt;), leading to an error of ambiguous call to displayAndPlay. The best we can do, then, is to use casts (MECpp item 2) in this ambiguous case.\nSmart pointers and const To mimic the flexibility of constness in terms of smart pointers, we use follwoing ways to create four combinations of const and non-const objects and pointers:\n1 2 3 4 5  CD goodCD(\u0026#34;Flood\u0026#34;); SmartPtr\u0026lt;CD\u0026gt; p; // non-const object, non-const pointer SmartPtr\u0026lt;const CD\u0026gt; p; // const object, non-const pointer const SmartPtr\u0026lt;CD\u0026gt; p = \u0026amp;goodCD; // non-const object, const pointer const SmartPtr\u0026lt;const CD\u0026gt; p = \u0026amp;goodCD; // const object, const pointer   Moreover, we can use the member templates technique shown above for automatically generating the implicit type conversion operators from SmartPtr\u0026lt;CD\u0026gt; to SmartPtr\u0026lt;const CD\u0026gt; - this technique works anytime the corresponding conversion for dumb pointers would work， and conversions involving const are no exception.\n It is possible that, after delete pt;, pt\u0026rsquo;s destructor (or some true owner of pt) will invoke delete pt; for a second time, and double deletion yields undefined behavior.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":112,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-28 Smart Pointers","uri":"https://nianze.ml/en/notes/2018/05/smart-pointers/"},{"content":"Techniques for requiring or prohibiting heap-based objects\nRequiring Heap-Based Objects 1. The straightforward way The brutle way is to declare the constructors and the destructor private, but this is overkill. Either one of them need to be private to ensure objects only be created on the heap. Since there are usually many constructors but only one destructor per class, a more elegant way is to make the destructor private and the constructors public, prividing privileged pseudo-destructor function (which has access to the real destructor) for clients to call, as suggested in MECpp item 26.\nExample:\n1 2 3 4 5 6 7 8 9 10 11 12  class UPNumber { // unlimited precision numbers that should only exist on the heap public: UPNumber(); UPNumber(int initValue); UPNumber(double initValue); UPNumber(const UPNumber\u0026amp; rhs); // pseudo-destructor (a const member function, because even const obj. may be destroyed)  void destroy() const { delete this; } ... private: ~UPNumber(); };   Clients would program like this:\n1 2 3 4 5  UPNumber n; // error! (legal here, but illegal when n\u0026#39;s dtor is implicitly invoked later) UPNumber *p = new UPNumber; // fine ... delete p; // error! attempt to call private dtor p-\u0026gt;destroy(); // fine   2. Inheritance-and-containment friendly Restricting access to a class\u0026rsquo;s destructor or constructors prevents the creation of not only non-heap objects, but also both inheritance and containment. To work this out:\n To be friendly for inheritance, we declare protected for UPNumber\u0026rsquo;s destructor. To be friendly for containment, classes that need objects of type UPNumber can be modified to contain pointers to UPNumber object instead:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class UPNumer {...}; // declare dtor protected class NonNegativeUPNumber: public UPNumber {...}; // okay to access protected members  class Asset { public: Asset(int initValue); ~Asset(); ... private: UPNumber *value; }; Asset::Asset(int initValue) : value(new UPNumber(initValue)) // fine {...} Asset::~Asset() { value-\u0026gt;destroy(); } // fine   3. Determining Whether an Object is On The Heap It\u0026rsquo;s hard to tell whether an object is on the heap. For example, given the class definition above, it\u0026rsquo;s ligal to define a non-heap NonNegativeUPNumber object, which will not construct its base UPNumber part on the heap. There is no way to detect whether a constructor is being invoked as the base class part of a heap-based object, which means for the following contexts, it is not possible for the UPNumber constructor to detect the difference:\n1 2  NonNegativeUPNumber *n1 = new NonNegativeUPNumber; // on heap NonNegativeUPNumber n2; // not on heap   Sadly, there\u0026rsquo;s no portable way to determine whether an object is on the heap, and there isn\u0026rsquo;t even a semi-portable way that works most of the time. Detailed dicussion on this topic could be found at Comments on Item 27 of More Effective C++.\nWe\u0026rsquo;ll have to turn to unportable, implementation-dependent system calls if we absolutely have to tell whether an address is on the heap. That being the case, we\u0026rsquo;d better off trying to redesign the software so we don\u0026rsquo;t need to determine whether an object is on the heap in the first place.\n4. Determine whether it\u0026rsquo;s safe to delete a pointer To answer this easier question, all we need to do is to create a collection of addresses that have been returned by operator new. One possible solution is to provide an abstract mixin base class that offers derived classes the ability to determine whether a pointer was allocated from operator new:\n1 2 3 4 5 6 7 8 9 10 11 12 13  class HeapTracked { // mixin class; keeps track of ptrs returned from op. new public: class MissingAddress(); // exception class  virtual ~HeapTracked() = 0; static void *operator new(size_t size); static void operator delete(void *ptr); bool isOnHeap() const; private: typedef const void* RawAddress; static list\u0026lt;RawAddress\u0026gt; addresses; };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // mandatory definition of static class member list\u0026lt;RawAddress\u0026gt; HeapTracked::address; // tho being pure virtual, dtor still needs to be defined HEapTracked::~HeapTracked() {} void * HeapTracked::operator new(size_t size) { void *memPtr = ::operator new(size); // get the memory  addresses.push_front(memPtr); return memPtr; } void HeapTracked::operator delete(void *ptr) { // gracefully handle null pointer  if (ptr == 0) return; list\u0026lt;RawAddress\u0026gt;::iterator it = find(addresses.begin(), addresses.end(), ptr); if (it != addresses.end()) { addresses.erase(it); // remove the entry  ::operator delete(ptr); // deallocate the memory  } else { throw MissingAddress(); // ptr wasn\u0026#39;t allocated by op. new. throw an exception  } } bool HeapTracked::isOnHeap() const { // get a pointer to the beginning of the memory occupied by *this  const void *rawAddress = dynamic_cast\u0026lt;cosnt void*\u0026gt;(this); list\u0026lt;RawAddress\u0026gt;::iterator it = find(addresses.begin(), addresses.end(), rawAddress); return it != addresses.end(); // return whether it was found }   Note that dynamic_cast is applicable only to pointers to objects that have at least one virtual function, and dynamic_casting a pointer to void* (or const void* or volatile void* or const volatile void*) yields a pointer to the beginning of the memory for the object pointed to by the pointer. Here dynamic_casting this to const void* gives us a pointer to the beginning of the memory for the current object, which is the pointer previously returned by HeapTracked::operator new as long as the memory for the current object was allocated by HeapTracked::operator new in the first place.\nTo use this basic class, say we want to be able to determine whether a pointer to an Asset object points to a heap-based object, simply modify Asset\u0026rsquo;s class definition to specify HeapTracked as a base class:\n1 2 3 4 5  class Asset: public HeapTracked { private: UPNumber value; ... };   And we could query Asset* pointers as follows:\n1 2 3 4 5 6 7 8 9  void inventoryAsset(const Asset *ap) { if (ap-\u0026gt;isOnHeap()) { as is a heap-based asset -- inventory it as such } else { ap is non-heap-based asset -- record it that way } }   Since built-in types such as int and char can\u0026rsquo;t inherit from anything, HeapTracked can\u0026rsquo;t be used with these built-in types. Still, the most common reason for wanting to use a class like HeapTracked is to determine whether it\u0026rsquo;s okay to delete this, and we don\u0026rsquo;t want to do that with a built-in type because such types have no this pointer.\nProhibiting Heap-Based Objects To preventing objects from being allocated on the heap, there are three cases:\n objects that are directly instantiated objects instantiated as base class parts of derived class objects objects embedded inside other objects  1. Preventing directly instantiation on heap To prevent clients from directly instantiating objects on the heap: we can declare operator new (and possibly operator new[]) as private:\n1 2 3 4 5 6  class UPNumber { private: static void *operator new(size_t size); static void operator delete(void *ptr); ... };   1 2 3  UPNumber n1; // okay static UPNumber n2; // okay UPNumber *p = new UPNumber; // error! attempt to call private operator new   Declaring operator new private often also prevents UPNumber objects from being instantiated as base class parts of heap-based derived class objects, because operator new and operator delete are inherited, so if these functions aren\u0026rsquo;t declared public in a derived class, that class inherits the private versions declared in its base(s):\n1 2 3 4 5 6 7 8  class UPNumber {...}; // as above class NonNegativeUPNumber: public UPNumber { // declares no operator new  ... }; NonNegativeUPNumber n1; // okay static NonNegativeUPNumber n2; // okay NonNegativeUPNumber *p = new NonNegativeUPNumber; // error! attempt to call private operator new   2. Preventing base class parts instantiated on heap However, if the derived class declares an operator new of its own, which will be called when allocating derived class objects on the heap, it is hard to prevent UPNumber base class parts from winding up there.\n3. Preventing base class parts instantiated on heap Similarly, the fact that UPNumber\u0026rsquo;s operator new is private has no effect on attempts to allocate objects containing UPNumber objects as members:\n1 2 3 4 5 6 7 8 9 10  class Asset { public: Asset(int initValue); ... private: UPNumber value; }; Asset *pa = new Asset(100); // fine, calls Asset::operator new or ::operator new,  // not UPNumber::operator new   Just as there\u0026rsquo;s no portable way to determine if an address is on the heap, however, there is no portable way to determine that it is not on the heap, so we can\u0026rsquo;t throw an exception in the UPNumber constructors if a to-be-tested UPNumber object being constructed is on the heap. We\u0026rsquo;re out of luck.\n","description":"","id":113,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-27 Requiring or Prohibiting Heap Based Objects","uri":"https://nianze.ml/en/notes/2018/05/requiring-or-prohibiting-heap-based-objects/"},{"content":"Combining object-counting technique with the pseudo-constructors, we can limit the number of objects of a class.\nAllowing zero or one objects Using the classic singleton design pattern, it\u0026rsquo;s easy to limit the number of object to either zero or one. There are three points worth noting in this design:\n Declaring the constructors of the class private Using static object In order to access the single object, encapsulate the single object inside a accessor function (either a friend function inside some namespace/globally, or a static member function of that class). Note that:  Remember to put the static object inside this wrapper function to make it a function static instead of a class static, because  A class static is always constructed even if it\u0026rsquo;s never used, while a function static is created the first time through the function C++ says noting about the initialization order of static objects in different translation units, so class statics turn out to be a source of headaches, which can be avoided in the case of function statics (ECpp Item 4).   If this wrapper function is also declared as inline, it\u0026rsquo;s possible for some compilers to create more than one copy of the static objects in the program due to internal linkage (the object code for the program may contain more than one copy of each function with internal linkage, and this duplication includes function statics). So shy away from inline functions with static data.    Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  namespace PrintingStuff { class Printer { public: void submitJob(const PrintJob\u0026amp; job); void reset(); void performSelfTest(); ... friend Printer\u0026amp; thePrinter(); private: Printer(); Printer(const Printer\u0026amp; rhs); ... }; Printer\u0026amp; thePrinter() // no inline in case of duplication caused by internal linkage { static Printer p; return p; } } // namespace PrintingStuff   Since the accessor returns a reference to a Printer object, clients may use thePrinter in any context where a Printer object itself is expected:\n1 2 3 4  using PrintingStuff::thePrinter; thePrinter().reset(); thePrinter().submitJob(buffer);   However, there\u0026rsquo;s still an inconvenience in this design: we\u0026rsquo;re limited to a single Printer object for each run of the program. As a result, it\u0026rsquo;s not possible to write code like this:\n1 2 3 4 5 6  create Printer object p1; use p1; destroy p1; create Printer object p2; use p2; destroy p2;   This design never instantiates more than a single Printer object at a time, but it does use different Printer objects in different parts of the program. It does not violate the constraint that only one printer may exist, but is still illegal with a single function static implementation.\nThis need for flexibility leads us to the design of object-counting.\nAllowing multimple objects: object-counting with pseudo-constructor Object-counting The good point of object-counting is that, it provides us with more flexibility than the function static, and makes it easier to generalize the limit number to more than one. However, object-counting alone will not work. For example:\n1 2 3 4 5 6 7 8 9 10 11  class Printer { public: class TooManyObjects{}; // exception class for use when too many obj. are requested; may also returning null for too-many-object cases  Printer(); Printer(const Printer\u0026amp; rhs); ~Printer(); ... private: static size_t numObjects; static const size_t maxObjects = 10; // may need enum hack here for old compiler };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // Obligatory definitions of class statics size_t Printer::numObjects = 0; const size_t Printer::maxObjets; Printer::Printer() { if (numObjects \u0026gt;= maxObjects) { throw TooManyObjects(); } process with normal construction here; ++numObjects; } Printer::~Printer() { perform normal destruction here; --numObjects; } Printer::Printer(const Printer\u0026amp; rhs) { if (numObjects \u0026gt;= maxObjects) { throw TooManyObjects(); } perform normal copy construction here ++numObjects; }   The problem here is that, in order to set a limit on the number of instantiations, we should not declare the class constructor public, because that will allow clients to put the class as base class parts of more derived objects, or embedded inside larger objects, which is totally different usage context, and the presence of these different contexts significantly muddies the waters regarding what it means to keep track of the \u0026ldquo;number of objects in existence.\u0026rdquo; For example:\n1 2 3  class ColorPrinter: public Printer { ... }   1 2  Printer p; ColorPrinter cp;   From object definition above, there are two Printer objects, one for p and one for the Printer part of cp. This is usually unwanted behavior.\nOften we are interested only in allowing objects to exist on their own, and limit the number of those kinds of instantiations. To satisfy such restrictions, we should declare the class constructors private, and (in the absence of friend declarations) classes with private constructors can\u0026rsquo;t be used as base classes, nor can they be embedded inside other objects.\nPseudo-constructor In fact, private constructors are a general solution for preventing derivation. Instead of returning a reference to a single object (like what thePrinter does), we can declare a pseudo-constructor returning a pointer to a unique object to allow multiple objects.\nThat is, we combine the object-counting with pseudo-consturctors:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Printer { public: class TooManyObjects{}; // exception class for use when too many obj. are requested; may also returning null for too-many-object cases  // pseudo-constructor  static Printer * makePrinter(); static Printer * makePrinter(const Printer\u0026amp; rhs); ~Printer(); ... private: static size_t numObjects; static const size_t maxObjects = 10; // may need enum hack here for old compiler  Printer(); Printer(const Printer\u0026amp; rhs); };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // Obligatory definitions of class statics size_t Printer::numObjects = 0; const size_t Printer::maxObjets; Printer::Printer() { if (numObjects \u0026gt;= maxObjects) { throw TooManyObjects(); } process with normal construction here; ++numObjects; } Printer::Printer(const Printer\u0026amp; rhs) { if (numObjects \u0026gt;= maxObjects) { throw TooManyObjects(); } perform normal copy construction here ++numObjects; } Printer::~Printer() { perform normal destruction here; --numObjects; } Printer * Printer::makePrinter() { return new Printer; } Printer * Printer::makePrinter(const Printer\u0026amp; rhs) { return new Printer(rhs); }   An object-counting base class We can split the instance counting ability apart from the Printer class to reuse the limited-number-of-instance functionality.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  template\u0026lt;class BeingCounted\u0026gt; class Counted { public: class TooManyObjects{}; // for throwing exceptions  static size_t objectCount() { return numObjects; } protected: Counted(); Counted(const Counted\u0026amp; rhs); ~Counted() { --numObjects; } private: static size_t numObjects; static const size_t maxObjects; void init(); // to avoid ctor code duplication }; template\u0026lt;class BeingCounted\u0026gt; // defines numObjects and size_t Counted\u0026lt;BeingCounted\u0026gt;::numObjects; // automatically init. it to 0  template\u0026lt;class BeingCouted\u0026gt; Counted\u0026lt;BeingCounted\u0026gt;::Counted() { init(); } template\u0026lt;class BeingCounted\u0026gt; void Counted\u0026lt;BeingCounted\u0026gt;::Counted(const Counted\u0026lt;BeingCounted\u0026gt;\u0026amp;) { init(); } template\u0026lt;class BeingCounted\u0026gt; void Counted\u0026lt;BeingCounted\u0026gt;::init() { if (numObjects \u0026gt;= maxObjects) throw TooManyObjects(); ++numObjects; }   Now modify the Printer class to use the Counted template:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Printer: private Counted\u0026lt;Printer\u0026gt; { public: // pseudo-constructors  static Printer * makePrinter(); static Printer * makePrinter(const Printer\u0026amp; rhs); ~Printer(); void submitJob(const PrintJob\u0026amp; job); void reset(); void performSelfTest(); ... using Counted\u0026lt;Printer\u0026gt;::objectCount; // make this function public for clients of Printer  using Counted\u0026lt;Printer\u0026gt;::TooManyObjects; private: Printer(); Printer(const Printer\u0026amp; rhs); };   Note that:\n  We use private inheritance here because the implementation detials of keeping track of the number of instantiated objects are nobody\u0026rsquo;s business but the author of Printer\u0026rsquo;s. If we use the alternative public inheritance design, then we have to give the Counted class a virtual destructor - that will almost certainly affect size and layout of objects of classes inheriting from Counted, as MECpp item 24 states.\n  Clients may still want to know how many Printer objects exists, but objectCount becomes private due to the private inheritance. To restore the public accessibility, we employ a using declaration.\n  After inheritance, Printer can forget about counting objects, so the Printer constructor now looks like this:\n1 2 3 4  Printer::Printer() { proceed with normal object construction; }   The benifits:\n No checking of the number of objects to see if the limit is about to be exceeded No incrementing the number of objects in existence once the constructor is done Base class will always be invoked first, so if too many objects are created, a Connted\u0026lt;Printer\u0026gt; constructor throws an exception, and the Printer constructor won\u0026rsquo;t even be invoked    Clients of the Printer class are required to initialize maxObjects, or there will be an error during linking for undefined maxObjects:\n1  const size_t Counted\u0026lt;Printer\u0026gt;::maxObjects = 10;    ","description":"","id":114,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-26 Limiting the Number of Objects of a Class","uri":"https://nianze.ml/en/notes/2018/04/limiting-the-number-of-objects-of-a-class/"},{"content":"Depending on the different input or dynamic types of function parameters, \u0026ldquo;virtualization\u0026rdquo; is a useful technique to construct new objects of different types accordingly, or to conceive of non-member functions whose behavior changes accordingly.\nConstructors and non-member functions can\u0026rsquo;t really be virtual. We just make them act \u0026ldquo;virtually\u0026rdquo; so that it is easier to use. The term \u0026ldquo;virtual\u0026rdquo; means that a function will achieve type-specific behavior when we have a pointer or reference to an object without knowing its dynamic type in advance.\nVirtual constructor Suppose we write applications for working with newsletters, where a newsletter consists of components that are either textual or graphical:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class NLComponent { // abstract base class for newsletter components public: // constain at least one pure virtual function  virtual NLComponet * clone() const = 0; // virtual copy constructor  ... }; class TextBlocks: public NLComponent { // public: virtual TextBlock * clone() const // virtual copy constructor  { return new TextBlock(*this); } ... // constain no pure virtual function }; class Graphic: public NLComponent { public: virtual Graphic * clone() const // virtual copy constructor  { return new Graphic(*this); } ... // constain no pure virtual function }; class NewsLetter { // a newsletter object consists of a list of NLComponent objects public: NewsLetter(istream\u0026amp; str); NewsLetter(const NewsLetter\u0026amp; rhs); // normal copy constructor  ... private: list\u0026lt;NLComponet*\u0026gt; components; static NLComponet * readComponet(istream\u0026amp; str); // read the data for the next NLComponet from str, create the component and return a pointer to it };   The classes relate in this way:\nNewsLetter object ┌───────────────┐ │ ... │ ├───────────────┤ ┌──────────────┐ │[list object]--│-----pointers------\u0026gt;│ NLComponent │ └───────────────┘ └──────────────┘ public inheritance ↗ ↖ public inheritance ┌───────────┐ ┌──────────┐ │ TextBlock │ │ Graphic │ └───────────┘ └──────────┘ Suppose NewsLetter objects are stored on disk, it is convevient that NewsLetter takes an istream to read information from the stream as it creates the necessary in-core data structures. Depending on the data it reads, we need to create either a TextBlock or a Graphic, which are different types of objects. Here comes the readComponent, which acts like constructor for its creating new objects, while it is also able to create different types of objects according to the iput it is given. Thus we call such a constructor as the virtual constructor, which are useful in many constexts.\nGiven readComponent acting as a virtual constructor, it is easy to implement the constructor for NewsLetter:\n1 2 3 4 5 6  NewsLetter::NewsLetter(istream\u0026amp; str) { while (str) { componets.push_back(readComponet(str)); } }   Among all kinds of virtual functions, there is another widely useful one: the virtual copy constructor, which returns a pointer to a new copy of the object invoking the function, and is typically named like copySelf, cloneSelf, or simply clone. These virtual copy constructors just calls its real copy constructor, so that the meaning of \u0026ldquo;copy\u0026rdquo; keeps the same for both functions1 - consistency.\nNotice that a derived class\u0026rsquo;s redefinition of a base class\u0026rsquo;s virtual function declare different return types here: if the function\u0026rsquo;s return type is a pointer (or a reference) to a base class, the derived class\u0026rsquo;s function may return a pointer (or reference) to a class derived from that base class. Thus TextBlock\u0026rsquo;s clone returns a TextBlock* and Graphic\u0026rsquo;s clone returns a Graphic* while the return type of NLComponent\u0026rsquo;s clone is NLComponent*.\nTaking advantage of the virtual copy constructor in NLComponent, NewsLetter only need to implement a normal copy constructor:\n1 2 3 4 5 6 7 8  NewsLetter::NewsLetter(const NewsLetter\u0026amp; rhs); // normal copy constructor impl. in terms of virtual copy constructor { for (list\u0026lt;NLComponent*\u0026gt;::const_iterator it = rhs.components.begin(); it != rhs.componets.end(); ++it) { componets.push_back((*it)-\u0026gt;clone()); } }   Virtual Non-member functions Suppose we\u0026rsquo;d like to implement output operators for the TextBlock and Graphic classes. Given that the defaultly output operator operator\u0026lt;\u0026lt; takes an ostream\u0026amp; as its left-hand argument, we can not make it a member function of the TextBlock or Graphic classes, so it can\u0026rsquo;t be declared as virtual. On the other hand, if we insist on declaring a virtual function for printing (e.g., print), and thus define a print for the TextBlock and Graphic, the syntax for printing TextBlock and Graphic objects is inconsistent with that for the other types in the language, which makes our clients unhappy.\nWhat we want it a non-member function called operator\u0026lt;\u0026lt; that exhibits the behavior of a virtual function like print. The solution? We define both operator\u0026lt;\u0026lt; and print and have the former call the latter, and we get the virtual-acting non-member function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class NLComponent { public: virtual ostream\u0026amp; print(ostream\u0026amp; s) const = 0; ... }; class TextBlock: public NLComponent { public: virtual ostream\u0026amp; print(ostream\u0026amp; s) const; ... } class Graphic: public NLComponent { public: virtual ostream\u0026amp; print(ostream\u0026amp; s) const; ... } iinline ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; s, const NLComponent\u0026amp; c) { return c.print(s); }   Since the non-virtual function does nothing but call the virtual function that does the real work, we inline the non-virtual function to avoid the cost of a function call.\nNote that, although not easy, it is possible to make non-member functions act virtually on more than one of their arguments - details in MECpp item 31.\n If the real copy constructor performs a deep copy, so does the virtual copy constructor. If the real copy constructor does something fancy like reference counting or copy-on-write (MECpp item 29), so does the virtual copy constructor.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":115,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-25 Virtualizing Constructors and Non-Member Functions","uri":"https://nianze.ml/en/notes/2018/04/virtualizing-constructors-and-non-member-functions/"},{"content":"It\u0026rsquo;s important to have a basic understanding of the cost of some C++ features that can have a noticeable impact on the size of objects and the speed at which member functions execute.\nVirtual Functions Virtual function feature in C++ gives us the ability to execute the code corresponding to the dynamic type of the object on which the virtual function is invoked. Most implementations use virtual tables (vtbls) and virtual table pointers (vptrs).\nCost of vtbl A vtble is usually an array of pointers to functions. Each class that declares or inherits virtual functions has its own vtbl, which holds pointers to the implementations of the virtual functions for that class.\nFor example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class C1 { public: C1(); // nonvirtual func  virtual ~C1(); // virtual func  virtual void f1(); // virtual func  virtual int f2(char c) const; // virtual func  virtual void f3(const string\u0026amp; s); // virtual func  void f4() const; // nonvirtual func  ... }; class C2: public C1 { public: C2(); // nonvirtual func  virtual ~C2(); // virtual func  virtual void f1(); // redefined virtual func  virtual void f5(char *str); // new virtual func  ... };   The vtbls for C1 and C2 looks like this:\nC1's vtbl: ┌──┐ │ │--\u0026gt; impl. of C1::~C1 ├──┤ │ │--\u0026gt; impl. of C1::f1 ├──┤ │ │--\u0026gt; impl. of C1::f2 ├──┤ │ │--\u0026gt; impl. of C1::f3 └──┘ C2's vtbl: ┌──┐ │ │--\u0026gt; impl. of C2::~C2 ├──┤ │ │--\u0026gt; impl. of C2::f1 ├──┤ │ │--\u0026gt; impl. of C1::f2 ├──┤ │ │--\u0026gt; impl. of C1::f3 ├──┤ │ │--\u0026gt; impl. of C2::f5 └──┘ These tables come with cost: for each class containing virtual functions we have to set aside space ofr a virtual table, and the size of the vtbl is proportional to the number of virtual functions declared for that class.\nIdeally, we need only one copy of a class\u0026rsquo;s vtbl. Usually a class\u0026rsquo;s vtbl is generated in the object file containing the definition (i.e., the body) of the first non-inline non-pure virtal function in that class 1. However, if all virtual functions are declared inline, compilers tend to generate a copy of the class\u0026rsquo;s vtbl in every object file that uses it, so we should avoid declaring virtual functions inline.\nSpeaking of inline, it is worth noting that for all practical purposes, virtual functions aren\u0026rsquo;t inlined:\n inline means replacing the call site with the body of the called function *during compilation virtual means wait until runtime to see which function is called. In practical real world situation, virtual function calls are made through pointers or reference to objects, which are not inlined; only the virtual functions invoked through objects can be inlined, which is usually pointless.  Cost of vptr Each object whose class declares virtual functions will be added by compilers a hidden member that points to the virtual table for that class, so we\u0026rsquo;ll pay for an extra pointer indise each object that is of a class containing virtual functions:\n C1 object C1 object ┌──────────────┐ ┌──────────────┐ │ Data members │ │ Data members │ ├──────────────┤ C1's vtbl ├──────────────┤ │ vptr │-----\u0026gt;┌──┐\u0026lt;--------------------------│ vptr │ └──────────────┘ │ │--\u0026gt; impl. of C1::~C1 └──────────────┘ ├──┤ │ │--\u0026gt; impl. of C1::f1 ├──┤ │ │--\u0026gt; impl. of C1::f2 ├──┤ │ │--\u0026gt; impl. of C1::f3 └──┘ Thus, for a call to the virtual function f1 below:\n1 2 3 4  void makeACall(C1 *pC1) { pC1-\u0026gt;f1(); }   will be translated by compilers like this (given compilers know the hidden member vptr and the vtbl index of function f1 is i):\n1 2  (*pC1-\u0026gt;vptr[i])(pC1); // call the function pointed to by the i-th entry in the vtbl  // pointed to by pC1-\u0026gt;vptr; pC1 is passed to the function as the \u0026#34;this\u0026#34; pointer   On most machines this is almost as efficient as a non-virtual function call, with only a few more instructions, so the cost of calling a virtual function is basically the same as that of calling a function through a function pointer.\nSummary Both the per-class and the per-object space overhead for virtual functions increases, and the runtime invocation cost grows slightly.\nMultiple Inheritance The same effect applies to multiple inheritance, except that things get more complex:\n offset claculations to find vptrs within objects become more complicated there are multiple vptrs within a single object (one per base class) special vtbls must be generated for base classes in addition to the stand-alone vtbls  Virtual Base Classes Multiple inheritance often leads to the need for virtual base classes to eliminate the duplicated copies of base class in each deriving path.\nHowever, because implementations of virtual base classes often use pointers to virtual base class parts, one or more of these pointers may be stored inside the derived class objects. Take the following \u0026ldquo;dreaded multiple inheritance diamond\u0026rdquo; for example:\n A virtual ↗ ↖ virtual B C ↖ ↗ D 1 2 3 4  class A {...}; class B: virtual public A {...}; class C: virtual public A {...}; class D: public B, public C {...};   The layout for an object of type D is likely to look like this:\n ┌───────────────────────────────┐ │ B Data Members │ ├───────────────────────────────┤ │ Pointer to virtual base class ├─┐ ├───────────────────────────────┤ │ │ C Data Members │ │ ├───────────────────────────────┤ │ ┌─┤ Pointer to virtual base class │ │ │ ├───────────────────────────────┤ │ │ │ D Data Members │ │ │ ├───────────────────────────────┤ │ └\u0026gt;│ A Data Members │\u0026lt;┘ └───────────────────────────────┘ Combining virtual base class with virtual table pointers introduced in \u0026ldquo;Cost of vptr\u0026rdquo; above, the memory layout for an object of type D could look like this:\n ┌───────────────────────────────┐ │ B Data Members │ ├───────────────────────────────┤ │ _vptr_ │ ├───────────────────────────────┤ │_Pointer to virtual base class_│ ├───────────────────────────────┤ │ C Data Members │ ├───────────────────────────────┤ │ _vptr_ │ ├───────────────────────────────┤ │_Pointer to virtual base class_│ ├───────────────────────────────┤ │ D Data Members │ ├───────────────────────────────┤ │ A Data Members │ ├───────────────────────────────┤ │ _vptr_ │ └───────────────────────────────┘ Notice that in the above diagram there are only thre vptrs while four classes are involved, this is because D can share the vptr with B. Most implementations take use of this to reduce the compiler-generated overhead.\nRTTI  RTTI (Runtime type identification) lets us discover information about objects and classes at runtime. The information is stored in an object of type type_+info, which can be accessed by using the typeid operator.\n For each class, there only needs to be a single copy of the RTTI, and the language specification states that an object\u0026rsquo;s dynamic type information is guaranteed accurate only if that type has at least one virtual funciton. This may end up with such a design that RTTI was implemented in terms of a class\u0026rsquo;s vtbl.\nFor example, index 0 of a vtbl array might contain a pointer to the type_info object for the class corresponding to that vtbl:\nC1's vtbl ┌──┐ │ │--\u0026gt; C1's type_info object ├──┤ │ │--\u0026gt; impl. of C1::~C1 ├──┤ │ │--\u0026gt; impl. of C1::f1 ├──┤ │ │--\u0026gt; impl. of C1::f2 ├──┤ │ │--\u0026gt; impl. of C1::f3 └──┘ With this implementation, the space cost of RTTI is an additional entry in each class vtbl plus the cost of the storage for the type_info object for each class, which is unlikely to be noticeable for most applications.\n For vendors who provide an integrated environment containing both compiler and linker, there is another brute-force starategy: generate a copy of the vtbl in each object file that might need it, and let linker strip out duplicate copies, leading to a single instance of each vtbl in the final executable or library.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":116,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-24 Understand the Costs of Virtual Functions, Multiple Inheritance, Virtual Base Classes, and RTTI","uri":"https://nianze.ml/en/notes/2018/04/costs-of-virtual-functions-multiple-inheritance-virtual-base-classes-and-rtti/"},{"content":"Different libraries offering similar functionality often feature different performance trade-offs, so we might be able to remove bottlenecks by replacing one library with another.\nIdeally, a library is small, fast, powerful, flexible, extensible, intuitive, universally available, well supported, free of use restriction, and bug-free.\nIn reality, libraries optimized for size and speed are typically not portable; libraries with rich functionality are rarely intuitive; bug-free libraries are limited in scope. In a word, we can\u0026rsquo;t get everything.\nDifferent designers assign different priorities to these criteria, leading to the result that two libraries offering similar functionality have different performance profiles.\nTake iostream and stdio for example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  #ifndef STDIO #include \u0026lt;stdio.h\u0026gt;#else #include \u0026lt;iostream\u0026gt;#include \u0026lt;iomanip\u0026gt;using namespace std; #endif  const int VALUES = 30000; // # of values to read/write  int main() { double d; for (int n = 1; n \u0026lt;= VALUES; ++n) { #ifdef STDIO  scanf(\u0026#34;%lf\u0026#34;, \u0026amp;d); printf(\u0026#34;%10.5f\u0026#34;, d); #else  cin \u0026gt;\u0026gt; d; cout \u0026lt;\u0026lt; setw(10) // set field width  \u0026lt;\u0026lt; setprecision(5) // set decimal places  \u0026lt;\u0026lt; setiosflags(ios::showpoint) // keep trailing  \u0026lt;\u0026lt; setiosflags(ios::fixed) \u0026lt;\u0026lt; d; #endif  if (n % 5 == 0) { #ifdef STDIO  printf(\u0026#34;\\n\u0026#34;); #else  cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } #endif  } return 0; }   Running this program on several combinations of machines, operating systems, and compilers, and we should get a brief insight into the comparative performance difference between these two libraries. It is probable that the stdio version is faster, and the size of the executable using stdio tends to be smaller. However, it is also possible that iostream implementation is faster than stdio, because iostreams determine the types of their iperands during compilation, while stdio functions typically parse a format string at runtime.\nAnyway, the main point is that, because different libraries embody different design decisions regarding efficiency, extensibility, portability, type safety, and other issues, different libraries offeringg similar functionality often feature different performance trade-offs. Thus, once we\u0026rsquo;ve identified the bottlenecks in our software (via profiling, MECpp item 16), we can sometimes significantly improve the efficiency of our software by switching to libraries whose designer gave more weight to performance consideration than to other factors.\n","description":"","id":117,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-23 Consider Alternative Libraries","uri":"https://nianze.ml/en/notes/2018/04/consider-alternative-libraries/"},{"content":"Assignment versions of operators (such as operator+=) tend to be more efficient than stand-alone versions of those operators (e.g., operator+).\nEfficiency difference between op= and stand-alone op  In general, assignment versions of operators are more effiecient than stand-alone versions, because  stand-alone versions must typically return a new object, and that costs us the construction and destruction of a temporary (MECpp item 19 and 20) assignment versions of operators write to their left-hand argument, so there is no need to generate a temporary to hold the operator\u0026rsquo;s return value   By offering assignment versions of operators as well as stand-alone versions, we allow clients of our classes to make the different trade-off between efficiency and convenience:  1 2 3  Rational a, b, c, d, result; ... result = a + b + c + d; // 3 potential temporary objects, one for each call to operator+   This version is easy to write, debug, and maintain, and it offers acceptable performance about 80% of the time (MECpp item 16).\n1 2 3 4  result = a; // no temporary result += b; // no temporary result += c; // no temporary result += d; // no temporary   This version is more efficient.\nIn summary, as a library designer, we should offer both, and as an application developer, we should consider using assignment versions of operators instead of stand-alone versions when trying to deal with the critical 20% code.\nRelationship between op= and stand-alone op To ensure the natural relationship between the assignment version of an operator (e.g., operator+=) and the stand-alone version (e.g., operator+) exists, we can implement the latter in terms of the former (MECpp item 6):\n1 2 3 4 5 6 7 8 9 10  class Rational { public: ... Rational\u0026amp; operator+=(const Rational\u0026amp; rhs); }; const Rational operator+(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { return Rational(lhs) += rhs; }   Further more, if we don\u0026rsquo;t mind putting all stand-alone operators at global scope, we can use templates to eliminate the need to write the stand-alone functions:\n1 2 3 4 5  template\u0026lt;class T\u0026gt; const T operator+(const T\u0026amp; lhs, const T\u0026amp; rhs) { return T(lhs) += rhs; }   A few points worth noting in this implementation of operator+:\n operator+= is implemented (elsewhere) from scratch, and operator+ calls it to provide its functionality, so that only the assignment versions need to be maintained. Assuming the assignment version is in the class\u0026rsquo;s public interface, there is no need for the stand-alone operators to be friends of the class. Without any named object, this implementation may take use of the return value optimization (MECpp item 20) 1.   Although it is possible that return T(lhs) += rhs; may be more complex than most compilers are willing to subject to the return value optimization.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":118,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-22 Consider Using op= Instead of Stand Alone op","uri":"https://nianze.ml/en/notes/2018/04/consider-using-op-instead-of-stand-alone-op/"},{"content":"Overloading to avoid temporaries.\nConsider following code:\n1 2 3 4 5 6 7 8  class UPInt { // unlimited precision integers public: UPInt(); UPInt(int value); ... }; const UPInt operator+(const UPInt\u0026amp; lhs, const UPInt\u0026amp; rhs);   And following statements:\n1 2 3 4  UPInt upi1, upi2; UPInt upi3 = upi1 + 10; UPInt upi4 = 10 + upi2;   These statements succeed by the creation of temporary objects to convert the integer 10 into UPInts (MECpp item 19).\nIt is convenient to have compilers perform such kinds of conversions, but the we do pay the cost of implicit type conversion. If we want to eliminate this cost, we cancel the type conversions by function overloading;\n1 2 3 4  const UPInt operator+(const UPInt\u0026amp; lhs, const UPInt\u0026amp; rhs); const UPInt operator+(const UPInt\u0026amp; lhs, int); const UPInt operator+(int, const UPInt\u0026amp; rhs); ...   Notice that const UPInt operator+(int, int); is not allowed: C++ rules that every overloaded operator must take at leas one argument of a user-defined type. int isn\u0026rsquo;t a user-defined type, so we can\u0026rsquo;t overload this operator+ in this form.\nStill, before doing such optimizations, it\u0026rsquo;s important to follow the 80-20 rule (MECpp item 16) to make sure it will make a noticeable improvement in the overall efficiency of the programs.\n","description":"","id":119,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-21 Overload to Avoid Implicit Type Conventions","uri":"https://nianze.ml/en/notes/2018/04/overload-to-avoid-implicit-type-conventions/"},{"content":"Take use of the return value optimization in compilers.\nSome functions (such as operator*) have to return objects:\n if returning pointers, the caller is responsible to delete the pointer, which usually leads to resource leaks. if returning references, then we\u0026rsquo;re returning a reference to a local object, which no longer exists when the caller has it.  Although we can\u0026rsquo;t eliminate by-value returns from functions that require them, we can still reduce the cost of returning objects: by the help of compilers, we can eliminate the cost of the temporaries by returning constructor arguments instead of objects:\n1 2 3 4 5  const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); }   Here we\u0026rsquo;re creating an anonymous temporary Rational object through a constructor expression, ant it is this temporary object the function is copying for its return value. When we use this efficient version of operator* under the use case below:\n1 2 3 4  Rational a = 10; Rational b(1, 2); Rational c = a * b; // operator* is called   The rules for C++ allow compilers to optimize such anonymous temporary objects out of existence by constructing the temporary inside the memory allotted for the object c. Thus, if compilers do this optimization, both the temporary inside operator* and the temporary returned by operator* are eliminated, and we only pay for one constructor call - the one to create c.\nFurther more, we can eliminate the overhead of the call to operator* by declaring this function inline:\n1 2 3 4 5 6  // most efficient way to write a function returning an object inline const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); }   ","description":"","id":120,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-20 Facilitate the Return Value Optimization","uri":"https://nianze.ml/en/notes/2018/04/facilitate-the-return-value-optimization/"},{"content":"Unnamed non-heap objects are invisible temporary objects in C++.\nTemporary objects arise in two situations:\n when implicit type conversions are applied to make function calls succeed when functions return objects  It\u0026rsquo;s important to understand how and why these temporary objects are created and destroyed because their construction and destruction can have noticeable impact on the performance of the program.\nImplicit conversion When the type of object passed to a function is not the same as the type of the parameter to which it is being bound, temporary objects are created during the implicit conversion to make function calls succeed.\nFor example,\n1 2 3 4 5 6 7 8 9 10 11  size_t countChar(const string\u0026amp; str, char ch); char buffer[MAX_STRING_LEN]; char c; // read in a char and a string; use setw to avoid // overflowing buffer when reading the string cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; setw(MAX_STRING_LEN) \u0026gt;\u0026gt; buffer; cout \u0026lt;\u0026lt; \u0026#34;There are \u0026#34; \u0026lt;\u0026lt; countChar(buffer, c) \u0026lt;\u0026lt; \u0026#34; occurrences of the character \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34; in \u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; endl;   Here is what will happen:\n By passing a char array into function countChar which expects a const string\u0026amp;, compilers will create a temporary object of type string constructed by calling the string constructor with buffer as its argument. The str parameter of countChar is then bound to this temporary string object. When the statement containing the call to countChar finishes executing, the temporary object is automatically destroyed.  Needless to say, such implicit conversion (with pointless construction and destruction of temporary objects) is not efficient and should be eliminated:\n by redesigning the code to forbid such implicit conversion, MECpp item 5 by modifying the code the same as described in MECpp item 21  Restrictions on implicit conversion These conversions occur only when passing objects by value or when passing to a reference-to-const parameter, so when passing an object to a reference-to-non-const parameter, there is no implicit conversion. For example,\n1 2 3  void uppercasify(string\u0026amp; str); char bookTitle[] = \u0026#34;Effective C++\u0026#34;; uppercasify(bootTitle); // error!   Here, temporary would not be created for parameter str, which is declared to be of type \u0026ldquo;non-const reference\u0026rdquo;, because it is the bookTitle that is supposed to be updated, instead of a newly created temporary.\nFunction return value 1  const Number operator+(const Number\u0026amp; lhs, const Number\u0026amp; rhs);   The return value of operator+ is a temporary, because it is just the function\u0026rsquo;s return value and has no name, and we must pay to construct and destruct this object each time we call the function. (const is added for the same reason in MECpp item 6);\nTo avoid such costs,\n switch to a similar function operator+=, MECpp item 22 if, in most cases, conceptually the construction and destruction can not be avoided, we optimize the program using the technique return value optimization instroduced in MECpp item 20 ","description":"","id":121,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-19 Understand the Origin of Temporary Objects","uri":"https://nianze.ml/en/notes/2018/04/understand-the-origin-of-temporary-objects/"},{"content":"The old Computer Science story: trade space for time1.\nIn order to improve program efficiency, we may use lazy evaluation (MECpp item 17), which is a technique for improving the efficiency of programs where results are not always needed. On the other side, when we must support operations whose results are almost always needed or whose results are often needed more than once, we may adopt \u0026ldquo;over-eager evaluation to amortize the cost of anticipated computations, such as caching and prefetching.\nCaching Say we\u0026rsquo;re writing a program to provide information about employees, and one of the pieces of information we expect to request frequently is an employee\u0026rsquo;s cubicle number, which is stored in a database, but the database is not optimized to find it. In this case, we could cache the cubicle numbers to save the subsequent database lookups.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  int findCubicleNumber(const string\u0026amp; employeeName) { typedef map\u0026lt;string, int\u0026gt; CubicleMap; static CubicleMap cubes; CubicleMap::iterator it = cubes.find(employeeName); if (it == cubes.end()) { int cubicle = // db query for the cubicle number  cubes[employeeName] = cubicle; return cubicle; } else { return it-\u0026gt;second; // or \u0026#34;(*it).second\u0026#34; if compiler does not support \u0026#34;-\u0026gt;\u0026#34; for \u0026#34;it\u0026#34; object  } }   Prefetching According to the infamous locality of reference phenomenon, if data in one place is requested, it\u0026rsquo;s quite common to want nearby data, too, which justifies disk caches, memory caches for both instructions and data, and instruction prefetches.\nAdopting similar concept, we can use similar strategy when writing a template for dynamic arrays, which will automatically extend themselves:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  template\u0026lt;class T\u0026gt; class DynArray {...}; template\u0026lt;class T\u0026gt; T\u0026amp; DynArray\u0026lt;T\u0026gt;::operator[](int index) { if (index \u0026lt; 0) { throw an exception; } if (index \u0026gt; the current maximum index value) { int diff = index - the current maximum index value; call new to allocate enough additional memory so that (index+diff) is valid; } return the indexth element of the array; }   This operator[] function allocates twice as much memory as needed each time the array must be extended, so that it saves one memory allocation when its logical size is extended twice in the following case:\n1 2 3 4  DynArray\u0026lt;double\u0026gt; a; // only a[0] is valid a[22] = 3.5; // new is called to expand a\u0026#39;s storage through index 44,  // a\u0026#39;s logical size is 23 a[32] = 0; // a\u0026#39;s logical size is now 33, without new being called    Not always. Using large objects means fewer fit on a virtual memory or cache page. In rare cases, making objects bigger reduces the performance of the software due to the increased paging activity and/or the decreased cache hit rate.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":122,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-18 Amortize the Cost of Expected Computations","uri":"https://nianze.ml/en/notes/2018/04/amortize-the-cost-of-expected-computations/"},{"content":"The best computations are those we never perform at all.\nLazy evaluation is applicable in an enormous variety of application areas.\nReference Counting 1 2 3 4 5  class String {...}; String s1 = \u0026#34;Hello\u0026#34;; String s2 = s1; // call String copy ctor   The lazy approach: instead of giving s2 a copy of s1\u0026rsquo;s value, we have s2 share s1\u0026rsquo;s value to save the cost of a call to new and the expense of copying anything, until any one is modified (i.e., s2.convertToUpperCase(); will change only s2\u0026rsquo;s value by making a private copy of shared value before modification). Refer to MECpp item 29 for implementation details.\nDistinguishing Reads from Writes 1 2  cout \u0026lt;\u0026lt; s[2]; // read s[2] = \u0026#39;x\u0026#39;; // write   For operator[], we\u0026rsquo;d like to distinguish the read call from the write so that a reference-counted string reading is cheap. In order to determine whether operator[] has been called in a read or in a write context, we use lazy evaluation and proxy classes as described in MECpp item 30.\nLazy Fetching 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class LargeObject { public: LargeObject(ObjectID id); const string\u0026amp; field1() const; int field2() const; double field3() const; const string\u0026amp; field4() const; ... private: ObjectID oid; mutable string *field1Value; mutable int *field2Value; mutable double *field3Value; mutable string *field4Value; ... }; LargeObject::LargeObject(ObjectID id) : oid(id), field1Value(0), field2Value(0), field3Value(0), field4Value(0)... {} const string\u0026amp; LargeObject::field1() const { if (field1Value == 0) { read the data for field 1 from the database and make field1Value point to it; } return *field1Value; }   Because LargeObject instances are big, getting all the data at once is a costly database operation. The lazy approach to this problem is to create only a skeleton of an object, without reading any data from disk when a LargeObject instance is created. Each field in the object is represented as a pointer to the necessary data, initialized as null pointers, which signify fields that have not yet been read from the database.\nSince null pointers may need to be initialized to point to real data from inside any member function, including const member functions like field1, we declare the pointer fields mutable to tell compilers that they can be modified inside any member function.\nAs an alternative, we can replace pointers with smart pointers (MECpp item 28), which does not need to be declared as mutable.\nLazy Expression Evaluation 1 2 3 4 5 6 7  template\u0026lt;class T\u0026gt; class Matrix { ... }; Matrix\u0026lt;int\u0026gt; m1(1000, 1000); // a 1000 by 1000 matrix Matrix\u0026lt;int\u0026gt; m2(1000, 1000); // a 1000 by 1000 matrix ... Matrix\u0026lt;int\u0026gt; m3 = m1 + m2;   Instead of compute and return the sum of m1 and m2 (which cost 1,000,000 additions and corresponding memory allocation), lazy evaluation sets up a data structure inside m3 indicating that m3\u0026rsquo;s value is the sum of m1 and m2 (which may just consisting of two pointers to each of m1 and m2 and an enum indicating the additional operation). In most scenarios, we need only part of a computation (i.e., cout \u0026lt;\u0026lt; m3[4]; instead of cout \u0026lt;\u0026lt; m3;), so laziness generally pays off.\nHowever, due to these dependencies between values, there are extra maintainence to notice: when one of the matrices on which m3 is dependent is to be modified, we have to make sure the correctness:\n1 2  m3 = m1 + m2; m1 = m4; // m3 is the sum of m2 and the old value of m1   Inside the Matrix\u0026lt;int\u0026gt; assignment opertaor, we might compute m3\u0026rsquo;s value prior to changing m1 or we may take a copy of the old value of m1 and make m3 dependent on that.\nThose extra mentainence efforts often ends up saving significant amounts of time and space during program runs, which is a payoff that justifies the lazy evaluation.\n","description":"","id":123,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-17 Consider Using Lazy Evaluation","uri":"https://nianze.ml/en/notes/2018/04/consider-using-lazy-evaluation/"},{"content":"The 80-20 rule states that 80 percent of a program\u0026rsquo;s resources are used by about 20 percent of the code.\n 80% of the runtime is spent in approximately 20% of the code 80% of the memory is used by some 20% of the code 80% of the disk accesses are performed for about 20% of the code 80% of the maintenance effort is devoted to around 20 percent of the code  To locate the critical pockets of code that are causing the problem, we should use the right way: using profilers.\n we want profilers the directly measures the resources we are interested in (how much time is being spent in different parts of the program) knowing how often statements are executed or functions are called may sometimes yield insight into what our software is doing feed the profiler with representative input data - profiler can only tell how a program behaved on a particular run ","description":"","id":124,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-16 Remember 80-20 Rule","uri":"https://nianze.ml/en/notes/2018/04/remember-80-20-rule/"},{"content":"Exception handling has costs, and we pay at least some of them even if we never use the keywords try, throw, or catch.\n  If we never use any exception-handling features:\n we pay for the space used by the data structures needed to keep track of which objects are fully constructed (MECpp item 10) we pay for the time needed to keep these data structures up to date Programs compiled with support for exceptions are typically slower and larger than their counterparts compiled without support for exceptions    If we include try-catch blocks:\n the cost varies from compiler to compiler. roughly, the overall code size increases by 5-10%, assuming no exceptions are thrown roughly, the overall runtime goes up by 5-10%, assuming no exceptions are thrown    If we include exception specifications:\n they generally incurs about the same cost as a try block    The cost of throwing an exception:\n Compared to a normal function return, returning from a function by throwing an exception may be as much as three orders of magnitude slower    Solution To minimize the exception-related costs,\n compile without support for exceptions when that is feasible; limit the use of try blocks, and exception specifications to locations where we really need them; throw exceptions only under conditions that are truly exceptional; profile the software (MECpp item 16) to determine if exception support is the bottleneck  If it is, consider switching to different compilers, ones that provide more efficient implementations of C++\u0026rsquo;s exception-handling features.   ","description":"","id":125,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-15 Understand the Costs of Exception Handling","uri":"https://nianze.ml/en/notes/2018/04/understand-the-costs-of-exception-handling/"},{"content":"Exception specifications provide a documentation aid and an enforcement mechanism for constraints on exception usage, but they are only partly checked by compilers and they are easy to violate inadvertently.\nThe good points   Explicitly state what exception a function may throw\n  Compilers are sometimes able to detect inconsistent exception specfications during compilation\n  If the inconsistency is not found during compilation but detected at runtime, the special funciton unexpected is automatically invoked to constrain exception usage.\n There is a reason for compilers to partially check exception usage for consistency with exception: the language standard prohibits compilers from rejecting a call to a function that might violate the exception specification of the function making the call in order to integrate with older code lacking such specifications:  1 2 3 4 5 6 7  extern void f1(); // might throw anything void f2() throw (int) { ... f1(); // legal even if f1 might throw sth other than an int  ... }     The unwanted points   The default behavior for unexpected is to call terminate, which by default will call abort, preventing possible high-level exception handlers from dealing with unexpected exceptions.\nSometimes the default behavior of immediate program termination is not what we want. For example, like the example code below, when an unanticipated exception propagates from inside the logDestruction (which isn\u0026rsquo;t supposed to happen due to the assertion throw() in exception specification after logDestruction, but it\u0026rsquo;s possible due to a call to some other function that throws), by default, unexpected will be called, and that will result in termination of the program, without letting the high-level destructor to catch and deal with the exception.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Session { public: ~Session(); ... private: static void logDestruction(Session *objAddr) throw(); }; Session::~Session() { try { logDestruction(this); } catch (...) {} }     The solution To avoid calls to unexpected:\n A good way to start is to avoid putting exception specifications on templates that take type argements, because there\u0026rsquo;s no way to know anything about the exceptions thrown by a template\u0026rsquo;s type parameters. A second technique is to omit exception specifications on functions making calls to functions that themselves lack exception specifications. A third technique is to handle exceptions \u0026ldquo;the system\u0026rdquo; may throw, such as bad_alloc thrown by operator new and operator new[] when a memory allocation fails (MECpp item 8).  To cope with unexpected exceptions:\n  Exploit the fact that C++ allows us to replace unexpected exceptions with exceptions of a different type (UnexpectedException), and add this type in the exception specification.\n1 2 3 4 5 6 7 8  class UnexpectexException {}; // all unexpected exception obj. will be replaces  // by obj. of this type void convertUnexpected() // function to call is an unexpected exception is thrown { throw UnexpectedException(); } set_unexpected(convertUnexpected); // replace the default `unexpected` function with `convertUnexpected`     Another way is to translate unexpected exceptions into bad_exception by rethrowing the current exception in the customized unexpected function, and include bad_exception or its base class exception in the exception specifications.\n1 2 3 4 5 6  void convertUnexpected() // function to call is an unexpected exception is thrown { throw; // just rethrow the current exception } set_unexpected(convertUnexpected); // install convertUnexpected as the unexpected replacement    ","description":"","id":126,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-14 Use Exception Specifications Judiciously","uri":"https://nianze.ml/en/notes/2018/04/use-exception-specifications-judiciously/"},{"content":"If catching by reference, we sidestep the questions about object deletion, avoid slicing exception objects, retain the ability to catch standard exceptions, and limit the number of times exception objects being copied.\nCatch by pointer In order to catch by pointer, programmers need to define exception objects in a way that guarantees the objects exist after control leaves the throw site. Global and static objects work fine, but it\u0026rsquo;s easy for programmers to forget the constraint:\n1 2 3 4 5 6 7  void someFunction() { exception ex; ... throw \u0026amp;ex; // throw a pointer to an object  ... // that\u0026#39;s about to be destroyed }   An alternative is to throw a pointer to a new heap object:\n1 2 3 4 5 6  void someFunction() { ... throw new exception; // throw a pointer to a new heap-based object  ... // hopefully the objerator new will not itself throw any exception }   This design will make a hard time for authors of catch clauses: to delete or not to delete the pointer they receive? In the catch site, we can\u0026rsquo;t tell if an exception object is allocated on the heap or defined as a global (or static) object.\nFurthermore, catch-by-pointer runs contrary to the convention of the language: the four standard exception1 - bad_alloc, bad_cast, bad_typeid, and bad_exception are all objects, rather than pointers to objefts, so we have to catch them by value or by reference.\nCatch by value Catch-by-value requires exception objects be copied twice each time they thrown (MECpp item 12), and it also has slicing problem: derived class exception objects caught as base class exceptions have their derivedness \u0026ldquo;sliced off\u0026rdquo; : they lack derived class data members, and resolve to base class virtual functions (the same behavior as when an object is passed to a function by value)\nCatch by reference Catch-by-reference suffers from none of the problems:\n Unlike catch-by-pointer, the question of object deletion fails to arise, and there\u0026rsquo;s no difficulty in catching the standard exception types Unlike catch-by-value, there is no slicing problem, and exception objects are copied only once.  Of course, if there\u0026rsquo;s no need to change the exception object in the catch site, we\u0026rsquo;d catch not just reference, but by reference to const.\n bad_alloc: thrown when operator new can\u0026rsquo;t satisfy a memory request (MECpp item 8); bad_cast: thrown when a dynamic_cast to a reference fails (MECpp item 2); bad_typeid: thrown when typeid is applied to a dereferenced null pointer; and bad_exception: available for unexpected exceptions (MECpp item 14)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":127,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-13 Catch Exceptions by Reference","uri":"https://nianze.ml/en/notes/2018/04/catch-exceptions-by-reference/"},{"content":"There are three primary ways in which passing an object to a function or using that object to invoke a virtual function differs from throwing the object as an exception.\nSimilarity There is similarity between passing an argument from a function call site to the function\u0026rsquo;s parameter and passing an exception from a throw site to a catch clause:\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Widget {...} void f1(Widget w); void f2(Widget\u0026amp; w); void f3(const Widget\u0026amp; w); void f4(Widget *pw); void f5(const Widget *pw); catch (Widget w) ... catch (Widget\u0026amp; w) ... catch (const Widget\u0026amp; w) ... catch (Widget *pw) ... catch (const Widget *pw) ...   Differences However, there are still three difference:\n exception objects are always copied (when caught by value, they are copied twice), while objects passed to function parameters need not be copied at all. objects thrown as exceptions are subject to fewer forms of type conversion than are objects passed to functions. catch clauses are examined in the order in which they appear in the source code, and the first one that can succeed is selected for execution, while a virtual funciton invoked by an object is the one that provides the best match for the type of the object, even if it\u0026rsquo;s not the first one listed in the source code.  Difference in augument passing The first difference essentially grows out of the fact that when we call a function, control eventually returns to the call site, but when we throw an exception, constrol does not return to the throw site. For example:\n1 2 3 4 5  void throwWidget() { Widget localWidget; throw localWidget; // throw localWidget as an exception }   In this typical case where localWidget will go out of scope once control leaves throwWidget, its destructor will be called, so C++ specifies that an object thrown as an exception is copied (even if the object being thrown is not in danger of being destroyed). This mandatory copying of exception objects leads to two implication:\n It is not possible for the catch block to modify localWidget; it can only modify a copy of localWidget Throwing an exception is typically much slower than parameter passing.  Copying based on static type It is worth noting that in C++ copying is always based on an object\u0026rsquo;s static type (MECpp item 25 shows a technique to copy based on dynamic type). Thus,\n1 2 3 4 5 6 7 8 9  class Widget {...}; class SpecialWidget: public Widget {...}; void throwWidget() { SpecialWidget localSpecialWidget; Widget\u0026amp; rw = localSpecialWidget // rw refers to a SpecialWidget  throw rw; // this throws an exception of type Widget }   Rethrow Another impact caused from copying exceptions objects is that there\u0026rsquo;s difference between different rethrow statements:\n1 2 3 4 5 6 7 8 9 10 11  catch (Widget\u0026amp; w) // catch Widget exceptions { ... throw; // rethrow the exception so it continues to propagate } catch (Widget\u0026amp; w) // catch Widget exceptions { ... throw w; // propagate a copy of the caught exception }   Here, the first block rethrows the current exception, while the second one throws a new copy of the current exception. Apart from performance cost of the additional copy operation in the second block, there\u0026rsquo;s another suble difference: if the exception originally thrown was of type SpecialWidget, the first block would propagate a SpecialWidget exception (even though w\u0026rsquo;s static type is Widget) and no copy is made during throw;, while the second catch block throws a new exception being the type of Widget.\nIn general, we\u0026rsquo;ll want to use the\n1  throw;   syntax to rethrow the current exception for its consistency and efficiency.\nDifferent catch syntax There are three kinds of catch clauses for exception of type Widget:\n1 2 3  catch (Widget w) ... // catch by value catch (Widget\u0026amp; w) ... // catch by reference catch (const Widget\u0026amp; w) ... // catch by reference-to-const   A few points to note:\n A thrown object (which is always a copied temporary) may be caught by simple reference, but it is not allowed in function calls (item 19) to pass a temporary object to a non-const reference parameter. The first statement (catch by value) leads to two copies of the thrown object, one to create the temporary that all exceptions generate, the other to copy that temporary into w. For the catch by reference and catch by reference-to-const, we expect to pay for one copy of the exception. In contrast, when we pass function parameters by reference (or reference-to-const), no copying takes place. Throw by pointer is equivalent to pass by pointer. Either way, a copy of the pointer is passed. Just remember not to throw a pointer to a local object.  Difference in type matching Implicit conversions (such from int to double) are not applied when matching exceptions to catch clauses:\n1 2 3 4 5 6 7 8 9 10 11 12 13  void f(int value) { try { if (someFunction()) { throw value; } ... } catch (double d) { // handle double type exceptions  ... } ... }   In this case, the int exception thrown in try block will never be caught by the catch clause taking a double.\nBasically, two kinds of conversions are applied during catch matching:\n  inheritance-based conversions\nFor example, range_error, underflow_error, and overflow_error are derived types from runtime_error:\n1 2 3 4 5 6  catch (runtime_error) ... // can catch errors of type catch (runtime_error\u0026amp;) ... // runtime_error, catch (const runtime_error\u0026amp;) ... // range_error, or overflow_error  catch (runtime_error*) ... // can catch errors of type runtime_error* catch (const runtime_error*) ... // range_error*, or overflow_error*     from a typed to an untyped pointer\n1  catch (const void*) ... // catches any exception that\u0026#39;s a pointer     Difference in fitting strategy Catch clauses are always tried in the order of their appearance (employing a \u0026ldquo;first fit\u0026rdquo; strategy). For exampel:\n1 2 3 4 5 6 7 8 9  try { ... } catch (logic_error\u0026amp; ex) { // this block will catch all logic_error exceptions  ... // including invalid_argument exception, which is derived type } catch (invalid_argument\u0026amp; ed) { ... }   on the contrary, when we call a virtual function, the function invoked is the one in the class closest to the dynamica type of the object invoking the function (employing a \u0026ldquo;best fit\u0026rdquo; algorithm).\n","description":"","id":128,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-12 Understand How Throwing an Exception Differs From Passing a Parameter or Calling a Virtual Function","uri":"https://nianze.ml/en/notes/2018/04/understand-how-throwing-an-exception-differs-from-passing-a-parameter-or-calling-a-virtual-function/"},{"content":"Keep exceptions from propagating out of destructors to prevent C++ calling terminate during the statck-unwinding part of exception propagation and ensure that every neccessary cleanup is accomplished.\nDestructor is called in two situations:\n when an object is destroyed under \u0026ldquo;normal\u0026rdquo; conditions, e.g., when it goes out of scope, or is explicitly deleted. when an object is destroyed by the exception-handling mechanism during the stackunwinding part of exception propagation.  According to C++:\n When control leaves a destructor due to an exception while another exception is active, C++ calls the termiante function immediately, and any remaining local objects may not get a chance to be destroyed.\n For example, consider a Session class that will record object creations and destructions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Session { public: Session(); ~Session(); ... private: static void logCreation(Session *objAddr); static void logDestruction(Session *objAddr); }; Session::~Session() { logDestruction(this); }   Because there\u0026rsquo;s no try...catch statement, any exception inside the destructor will be propagated to the caller of the destructor. Thus once logDestructoin throws an exception during a special case when the destructor itself is called due to some other exception, the terminate function would automatically be invoked. So we prefer this design:\n1 2 3 4 5 6 7  Session::~Session() { try { logDestruction(this); } catch (...) {} // do nothing! }   The point here is that the catch block shouldn\u0026rsquo;t hold any statement that has potential of throwing exception, and its only purpose here is to prevent exception thrown from logDestruction from propagating beyond Session\u0026rsquo;s destructor. Another good reason of catching the exception and prevent the propagation is to make sure the destructor will run to completion, so that any leftover cleanup code after the exception-thrown statement is able to run properly, without being interrupted by the excpetion propagation.\n","description":"","id":129,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-11 Prevent Exceptions From Leaving Destructors","uri":"https://nianze.ml/en/notes/2018/04/prevent-exceptions-from-leaving-destructors/"},{"content":"Replace pointer class members with their corresponding smart pointer objects to fortify the constructors against resource leaks in the presence of exceptions, to eliminate the need to manually deallocate resources in destructors, and to allow const member pointers to be handled in the smae graceful fashion as non-const pointers.\nExample Suppose we want to develop a software for a multimedia address book that might hold information of a person\u0026rsquo;s name, address, phone numbers, a picture of the person and, the sound of their voice:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class Image { // for holding image data public: Image (const string\u0026amp; imageDataFileName); ... }; class AudioClip { // for holding audio data public: AudioClip(const string\u0026amp; sudioDataFileName); ... }; class PhoneNumber {...}; // for holding phone numbers  class BookEntry { public: BookEntry(const string\u0026amp; name, // name data is mandatory for BookEntry, other fields are optional  const string\u0026amp; address = \u0026#34;\u0026#34;, const string\u0026amp; imageFileName = \u0026#34;\u0026#34;, const string\u0026amp; audioClipFileName = \u0026#34;\u0026#34;); ~BookEntry(); void addPhoneNumber(const PhoneNumber\u0026amp; number); // phone numbers are added via this function  ... private: string theName; string theAddress; list\u0026lt;PhoneNumber\u0026gt; thePhones; Image *theImage; AudioClip *theAudioClip; };   Naive implementation A straightforward implementation for constructor and destructor:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  BookEntry::BookEntry(const string\u0026amp; name, const string\u0026amp; address, const string\u0026amp; imageFileName, const string\u0026amp; audioClipFileName) : theName(name), theAddress(address), theImage(0), theAudioClip(0) { if (imageFileName != \u0026#34;\u0026#34;) { theImage = new Image(imageFileName); } if (audioClipFileName != \u0026#34;\u0026#34;) { theAudioClip = new AudioClip(audioClipFileName); } } BookEntry::~BookEntry() { delete theImage; // C++ guarantees it\u0026#39;s safe to delete null pointers  delete theAudoClip; }   Everything looks good, however, there is potential resource leak under abnormal conditions: when an exception is thrown duringg exectuion of theAudioClip = new AudioClip(audioClipFileName);:\n An exception might arise because operator new (MECpp item 8) is unable to allocate enough memory for an AudioClip object, or coming from AudioClip constructor who throws an exception itself, ending up with a exception propagated to the site where the BookEntry object is being created C++ destroys only fully constructed objects, and an object isn\u0026rsquo;t fully constructed until its construtor has run to completion. The exception propagated from new AudioClip(audioClipFileName interrupts the construction of the BookEntry object, so the BookEntry\u0026rsquo;s destructor will never be called, and nobody will delete the object that theImage already points to.  Note that adding try...catch outside of the BookEntry constructor does not help:\n1 2 3 4 5 6 7 8 9 10 11 12 13  void testBookEntryClass() { BookEntry *pb = 0; try { pb = new BookEntry(\u0026#34;Sherlock Holmes\u0026#34;, \u0026#34;221B Baker Street\u0026#34;); ... } catch (...) { // catch all exceptions  delete pb; // delete pb when an exception is thrown  throw; // propagate exception to caller  } delete pb; // delete pb normally }   If BookEntry\u0026rsquo;s constructor throws an exception, no assignment is made to pb and pb will be a null pointer, so deleting it in the catch block does nothing except make us feel better about ourselves.\nWorkable (but inelegant) implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  BookEntry::BookEntry(const string\u0026amp; name, const string\u0026amp; address, const string\u0026amp; imageFileName, const string\u0026amp; audioClipFileName) : theName(name), theAddress(address), theImage(0), theAudioClip(0) { try { if (imageFileName != \u0026#34;\u0026#34;) { theImage = new Image(imageFileName); } if (audioClipFileName != \u0026#34;\u0026#34;) { theAudioClip = new AudioClip(audioClipFileName); } } catch (...) { // catch any exception  delete theImage; // perform necessary cleanup actions  delete theAudioClip; throw; // propagate the exception  } }   For non-pointer data members such as theName, theAddress, and thePhones, they are automatically initialized before a class\u0026rsquo;s constructor is called, so if a BookEntry constructor body begins exewcuting, they have already been fully constructed. As fully constructed objects, they will also be automatically destroyed even if an exception arises in the BookEntry constructor.\nConsidering code duplication, we may move the common resource cleanup code into a private helper funciton and have both the constructor and the destructor call it:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class BookEntry { public: ... // as before private: ... void cleanup(); // common cleanup statement }; void BookEntry::cleanup() { delete theImage; delete theAudioClip; } BookEntry::BookEntry(const string\u0026amp; name, const string\u0026amp; address, const string\u0026amp; imageFileName, const string\u0026amp; audioClipFileName) : theName(name), theAddress(address), theImage(0), theAudioClip(0) { try { ... } catch (...) { // catch any exception  cleanup(); throw; // propagate the exception  } } BookEntry::~BookEntry() { cleanup(); }   For both constant and non-const pointers What if BookEntry class interface is designed differently, with theImage and theAudioClip defined as constant pointers, which must be initialized via the member initialization lists:\n1 2 3 4 5 6 7 8  class BookEntry { public: ... private: ... Image * const theImage; AudioClip * const theAudioClip; };   Naive implementation We may be tempted to initit theImage and theAudioClip like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13  // an implementation that may leak resources if an exception is thrown BookEntry::BookEntry(const string\u0026amp; name, const string\u0026amp; address, const string\u0026amp; imageFileName, const string\u0026amp; audioClipFileName) : theName(name), theAddress(address), theImage(imageFileName != \u0026#34;\u0026#34; ? new Image(imageFileName) : 0), theAudioClip(audioClipFileName != \u0026#34;\u0026#34; ? new AudioClip(audioClipFileNAme) : 0) {}   but this leads to the problem of potential resource leak: if an exception is thrown during initialization of theAudioClip, the object pointed to by theImage is never destroyed.\nWorkable design In order to add try and catch to perform cleanup tasks in a member initialization list, we may consider put them inside private member functions that return pointers:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  class BookEntry { public: ... private: ... Image * initImage(const string\u0026amp; imageFileName); AudioClip * initAudioClip(const string\u0026amp; audioClipFileName); }; BookEntry::BookEntry(const string\u0026amp; name, const string\u0026amp; address, const string\u0026amp; imageFileName, const string\u0026amp; audioClipFileName) : theName(name), theAddress(address), theImage(initImage(imageFileName)), theAudioClip(initAudioClip(audioClipFileName)) {} // theImage is init. first, so there\u0026#39;s no need to worry about a resource leak // if this initialization fails. Image * BookEntry::initImage(const string\u0026amp; imageFileName) { if (imageFileName != \u0026#34;\u0026#34;) return new Image(imageFileName); else return 0; } // theAudioClip is initialized second, so it must take care of theImage\u0026#39;s resources // if an exception is thrown during initialization of theAudioClip AudioClip * BookEntry::initAudioClip(const string\u0026amp; audioClipFileName) { try { if (audioClipFileName != \u0026#34;\u0026#34;) { return new AudioClip(audioClipFileName); } else return 0; } catch (...) { delete theImage; throw; } }   This design works, but the drawback is that code that conceptually belongs in a constructor is now dispersed across several functions, and that\u0026rsquo;s a maitenance headache.\nBetter design A better design is to adopt the advise of MECpp Item 9 (as well as item 13):\n treat the objects pointed to by theImage and theAudioClip as resources to be managed by local objects (specifically, smart pointers).  Since the resource here is of pointer types, we can use smart pointers to manage them. Take auto_ptr for example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class BookEntry { public: ... private: ... const auto_ptr\u0026lt;Image\u0026gt; theImage; const auto_ptr\u0026lt;AudioClip\u0026gt; theAudioClip; }; BookEntry::BookEntry(const string\u0026amp; name, const string\u0026amp; address, const string\u0026amp; imageFileName, const string\u0026amp; audioClipFileName) : theName(name), theAddress(address), theImage(imageFileName != \u0026#34;\u0026#34; ? new Image(imageFileName) : 0), theAudioClip(audioClipFileName != \u0026#34;\u0026#34; ? new AudioClip(audioClipFileNAme) : 0) {} BookEntry::~BookEntry() // nothing to do {}   In this design, if an exception is thrown during initialization of theAudioClip, theImage is already a fully constructed object, so it will automatically be destroyed, jsut like theName, theAddress, and thePhones. Furthermore, because theImage and theAudioClip are now objects, they\u0026rsquo;ll be destroyed automatically when the BookEntry object containing them is destroyed.\n","description":"","id":130,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-10 Prevent Resource Leaks in Constructors","uri":"https://nianze.ml/en/notes/2018/04/prevent-resource-leaks-in-constructors/"},{"content":"To avoid resource leaks in the presence of exceptions, we can encapsulate resources inside objects.\nUsing objects to manage pointer-based resource Suppose we\u0026rsquo;re writing software for a shelter names Adorable Little Animals, an organization that finds homes for puppies and kittens. Each day the shelter creates a file containing information on the adoptions it arranged that day, so we need to read these files and do the approgriate procesing for each adoption.\nA reasonable design will use polymorphism: an abstract base class ALA (\u0026ldquo;adorable little animal\u0026rdquo;), with two concrete derived classes for puppies and kittens, and a virtual function processAdoption to handle the necessary species-specific processing:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class ALA { public: virtual void processAdoption() = 0; ... }; class Puppy: public ALA { public: virtual void processAdoption(); ... }; class Kitten: public ALA { public: virtual void processAdoption(); ... };   Another thing we need is a virtual constructor (MECpp item 25), which reads information from a file and produce either a Puppy object or a Kitten object, depending on the information in the file:\n1  ALA * readALA(istream\u0026amp; s);   Finally, the key processing part of the program looks like this:\n1 2 3 4 5 6 7 8  void processAdoptions(istream\u0026amp; dataSource) { while (dataSource) { ALA *pa = readALA(dataSource); pa-\u0026gt;processAdoption(); delete pa; } }   However, there\u0026rsquo;s a potential resource leak: if pa-\u0026gt;processAdoption threw an exception, all statements in processAdoptions after this statement would be skipped, ending up with pa never getting deleted. To solve it, an ungly design would be:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  void processAdoptions(istream\u0026amp; dataSource) { while (dataSource) { ALA *pa = readALA(dataSource); try { pa-\u0026gt;processAdoption(); } catch (...) { delete pa; // avoid resource leak when encountering exception  throw; // propagate exception to caller  } delete pa; // delete pa in normal condition  } }   The duplication in cleanup code is annoying to write and difficult to maintain. Remember that\n Local objects are always destroyed when leaving a function, regardless of how that function is exited 1.\n So we can move the delete into a destructor for an object local to processAdoptions, which is exactly the functionaltity smart pointers in standard C++ library provide. For example, the essential of auto_ptr (item 13, MECpp item 28) boils down to following definition:\n1 2 3 4 5 6 7 8  template\u0026lt;class T\u0026gt; class auto_ptr { public: auto_ptr(T *p = 0): ptr(p) {} // save ptr to object  ~auto_ptr() { delete ptr; } // delete ptr to object private: T *ptr; // raw ptr to object };   New processAdoptions using an auto_ptr object instead of a raw pointer:\n1 2 3 4 5 6 7  void processAdoptions(istream\u0026amp; dataSource) { while (dataSource) { auto_ptr\u0026lt;ALA\u0026gt; pa(readALA(dataSource)); pa-\u0026gt;processAdoption(); } }   Using objects to manage other resources The idea behind auto_ptr is to use an object to store a resource that needs to be automatically released via the object\u0026rsquo;s destructor, which applis to broader ranges of resource types as well. For example, in a GUI application that needs to create a window to display some information:\n1 2 3 4 5 6  void displayInfo(const Information\u0026amp; info) { WINDOW_HANDLE w(createWindow()); display \u0026#34;info\u0026#34; in window corresponding to \u0026#34;w\u0026#34;; destroyWindw(w); }   The functions createWindow and destroyWindow for acquiring and releasing window resources should be packaged in an object to avoid resource leak in the situations where an exception is thrown during process of displaying info in w:\n1 2 3 4 5 6 7 8 9 10 11 12  // class for acquiring and releasing a window handle class WindowHandle { public: WindowHandle(WINDOW_HANDLE handle): w(handle) {} ~WindowHandle() { destroyWindow(w); } operator WINDOW_HANDLE() { return w; } // implicit convertion operator to turn a WindowHandle into a WINDOW_HANDLE private: WINDOW_HANDLE w; WindowHandle(const WindowHandle\u0026amp;); // prevent multiple copies  WindowHandle\u0026amp; operator=(const WindowHandle\u0026amp;); // prevent multiple copies };   Note that the implicit conversion operator is essential to the practical application of a WindowHandle object, becauce it means we can use a WindowHandle just about anywhere we would normally use a raw WINDOW_HANDLE (refer to MECpp item 5 for downsides of doing so).\nGiven this WindowHandle class, we can rewrite desplayInfo as follows:\n1 2 3 4 5  void displayInfo(const Information\u0026amp; info) { WindowHandle w(createWindow()); display \u0026#34;info\u0026#34; in window corresponding to \u0026#34;w\u0026#34;; } // the window handled by \u0026#34;w\u0026#34; will always be released even if an exception is thrown    The only exception to this rule is when we call longjmp, and this shortcoming of longjmp is the primary reason why C++ has support for exceptions in the first place.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":131,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-9 Use Destructors to Prevent Resource Leaks","uri":"https://nianze.ml/en/notes/2018/04/use-destructors-to-prevent-resource-leaks/"},{"content":"The behaviors of new operator and operator new is different.\nRelationship between \u0026lsquo;new operator\u0026rsquo; and \u0026lsquo;operator new\u0026rsquo; Consider the following code:\n1  string *ps = new string(\u0026#34;Memory Management\u0026#34;);   The new operator here is built into the language and always does the same two things:\n first, it calls operator new to allocate enough memory to hold an object of the type requested. second, it calls a constructor to initialize an object in the memory that was allocated.  Thus, when compiler sees the code above, they must generate code equivalent to this:\n1 2 3 4  void *memory = operator new(sizeof(string)); // get raw memory for a string object call string::string(\u0026#34;Memory Management\u0026#34;) on *memory // init. the object in the memory.  // as programmer, directly calling the ctor is prohibited string *ps = static_cast\u0026lt;stirng*\u0026gt;(memory); // make ps point to the new object   So if we want to create an object on the heap, use the new operator and it both allocates memory and calls a constructor for the object.\nHowever, if we want to do some customized behaviors, we may consider following options:\n  if we only want to allocate memory, just call operator new directly:\n1  void *rawMemory = operator new(sizeof(string));     if we want to customize the memory allocation that takes place when heap objects are created, write our own version of operator new and use the new operator, which will automatically invoke the custom version of operator new\n  if we want to construct an object in memory we\u0026rsquo;ve already got a pointer to, use placement new.\nA special version of oeprator new called placement new allows us to construct an object in the memory that\u0026rsquo;s already been allocated, which is helpful for applications using shared memory or memory-mapped I/O, where objects must be placed at specific addresses or in memory allocated by special routines:\n1 2 3 4 5 6 7 8 9 10  class Widget { public: Widget(int widgetSize); ... }; Widget * constructWidgetInBuffer(void *buffer, int widgetSize) { return new (buffer) Widget(widgetSize); }   Here, an additional argument (buffer) is being specified for the implicit call that the new operator makes to a special version of operator new known as placement new in standard C++ library1:\n1 2 3 4  void * operator new(size_t, void *location) { return location; }   All placement new has to do is return the pointer that\u0026rsquo;s passed into it, because the memory for the object is already known. The unused (but mandatory) size_t parameter has no name to keep compilers from complaining about its not being used (MECpp item 6).\n  Deletion and memory deallocation The delete operator also includes two steps: destructing the object and deallocating the memory occupied by that object. The second part of memory deallocation is performed by the operator delete function:\n1  void operator delete(void *memoryToBeDeallocated);   Hence, for a pointer to string ps, delete ps; causes compilers to generate code that approximately corresponds to this:\n1 2  ps-\u0026gt;~string(); // call the object\u0026#39;s dtor operator delete(ps); // deallocate the memory the object occupied   Some implications:\n If we want to deal with raw, uninitialized memory, we should call operator new to get memory and operator delete to return it to the system (the C++ equivalent of calling malloc and free):  1 2 3  void *buffer = operator new (50*sizeof(char)); // allocate enough memory to hold 50 chars, call no ctor ... operator delete(buffer); // deallocate the memory; call no dtor    If we use placement new to create an object in some memory, we should avoid using the delete operator on that memory:  1 2 3 4 5 6 7 8 9 10  // function to allocating and deallocating memory in shared memory void * mallocShared(size_t size); void freeShared(void *memory); void *sharedMemory = mallocShared(sizeof(Widget)); Widget *pw = constructWidgetInBuffer(sharedMemory, 10); // as above ... delete pw; // undefined! sharedMemory came from mallocShared, not operator new pw-\u0026gt;~Widget(); // fine. destructs the Widget pointed to by pw, no memory deallocation performed freeShared(pw); // fine, deallocate the memory pointed to by pw, but calls no dtor   Arrays For array allocation:\n1  string *ps = new string[10]; // allocate an array of objects   The new being used is still the new operator, but the behavior here is slightly different from the case for single-object creation:\n in the first step, memory is allocated by operator new[] instead of operator new in the second step, the constructor is called for each object in the array, so here the default constructor for string is called 10 times.  Similarly, when the delete operator is used on an array, it calls a destructor for each array element and then calls operator delete[] to deallocate the memory.\nJust as we can replace or overload operator new and operator delete, we can do the same trick to operator new [] and operator delete [] to seize the control of memrory allocation and deallocation for arrays.\n To use placement new, all we have to do is is #include \u0026lt;new\u0026gt;.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":132,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-8 Understand the Different Meanings of New and Delete","uri":"https://nianze.ml/en/notes/2018/03/understand-the-different-meanings-of-new-and-delete/"},{"content":"If we don\u0026rsquo;t have a good reason for overloading an operator, don\u0026rsquo;t overload it. In the case of \u0026amp;\u0026amp;, ||, and ,, it\u0026rsquo;s difficult to have a good reason: we can\u0026rsquo;t make them behave the way they\u0026rsquo;re supposed to.\nOverloading operator\u0026amp;\u0026amp; and operator|| C++ employs short-circuit evaluation of boolean expressions: once the truth or falsehood of an expression has been determined, evaluation of the expression ceases, even if somem parts of the expression haven\u0026rsquo;t yet been examined.\nThe operators associated with short-circuit evaluation are || and \u0026amp;\u0026amp;, which C++ allows us to customize for user-defined types. However, once we overloading the functions operator\u0026amp;\u0026amp; and operator|| (at the global scope or on a per-class basis), we are replacing short-circuit semantics with function call semantics, ending up changing the rules of the game quite radically. For example, after we overload operator\u0026amp;\u0026amp;, the following code:\n1  if (expression1 \u0026amp;\u0026amp; expression2) ...   looks to compilers like one of these:\n1 2 3  if (expression1.operator\u0026amp;\u0026amp;(expression2)) ... // when operator\u0026amp;\u0026amp; is a member function  if (operator\u0026amp;\u0026amp;(expression1, expression2)) ... // when operator\u0026amp;\u0026amp; is a global function   In two crucial ways, the funciton call semantics differ from short-circuit semantics:\n when a funciton all is made, all parameters must be evaluated. Thus there is no short circuit. the order of evaluation of parameters to a function all is undefined, so there is no way of knowing whether expression1 or expression2 will be evaluated first.  As a result, overloaded \u0026amp;\u0026amp; or || will never offer programmers the behavior they both exprect and have come to depend on. So do not overload \u0026amp;\u0026amp; or ||.\nOverloading operator, The comma operator is used for expressions, and we\u0026rsquo;re most likely to run across it in the update part of a for loop:\n1 2 3 4 5 6 7 8 9 10 11  void reverse(char s[]) { for (int i = 0, j = strlen(s)-1; i \u0026lt; j; ++i, --j) // the comma operator  { int c = s[i]; s[i] = s[j]; s[j] = c; } }   An expression containing a comma is evaluated by first evaluating the part of the expression to the left of the comma, then evaluating the expression to the right of the comma; the result of the overall comma expression is the value of the expression on the right. So the result for ++i, --j is the value returned from --j.\nUnfortunately, when writing our own comma operator, we can\u0026rsquo;t mimic this behavior for the same reason as the case in overriding || and \u0026amp;\u0026amp;:\n if we write operator, as a non-member function, then both operands around , will be passed as arguments in a function call, and there\u0026rsquo;s no way to control over the order in which a funciton\u0026rsquo;s arguments are evaluated. if we write operator, as a member function, we still can\u0026rsquo;t rely on the left-hand operand to the comma being evaluated first, because compilers are not constrained to do thing that way.  Limits on operator overloading According to C++, following operators can\u0026rsquo;t be overloaded:\n           . .* :: ?:   new delete sizeof typeid   static_cast dynamic_cast const_cast reinterpret_cast    We can overload these:\n           operator new operator delete operator new[] operator delete[]   + - * /   % ^ \u0026amp; |   ~ ! \u0026lt; \u0026gt;   += -= *= /=   %= ^= \u0026amp; `   \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026gt;\u0026gt;= \u0026lt;\u0026lt;=   == != \u0026lt;= \u0026gt;=   -\u0026gt;* -\u0026gt; ++ --   , \u0026amp;\u0026amp; ||    () []      Just because we can overload there operators is no reason to run off and do it. The purpose of operator overloading is to make programs easier to read, write, and understand. If we don\u0026rsquo;t have a good reason for overloading an operator, don\u0026rsquo;t overload it, as is the case for \u0026amp;\u0026amp;, ||, and ,.\n","description":"","id":133,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-7 Never Overload '\u0026\u0026', '||', or ','","uri":"https://nianze.ml/en/notes/2018/03/never-overload-and-or-comma-operator/"},{"content":"The prefix and postfix forms of increment and decrement operators return different types: prefix forms return a reference, while postfix forms return a const object. For efficiency, prefer prefix forms unless the behavior of postfix ones is necessary. To guarantee consistency, implement postfix operators in terms of the prefix operators.\nCase Study Overloaded functions are differentiated on the basis of the parameter types they take, but neither prefix nor postfix increment or decrement takes an argument. To surmount this linguistic pothole, it was decreed that postfix forms take in int argument, and compilers silently pass 0 as that int when those functions are called:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class UPInt { // customized \u0026#34;unlimited precisioin int\u0026#34; public: UPInt\u0026amp; operator++(); // prefiex ++  const UPInt operator++(int); // postfix ++  UPInt\u0026amp; operator--(); // prefiex --  const UPInt operator--(int); // postfix --  UPInt\u0026amp; operator+=(int); // += operator for UPInts and ints  ... }; UPInt i; ++i; // calls i.operator++(); i++; // calls i.operator++(0);  --i; // calls i.operator--(); i--; // calls i.operator--(0);   The return types difference is caused by the different behavior between prefix forms and postfix forms. For ++operator:\n Prefix form is \u0026ldquo;increment and fetch\u0026rdquo; Postfix form is \u0026ldquo;fetch and increment\u0026rdquo;  1 2 3 4 5 6 7 8 9 10 11 12 13 14  // prefix form: increment and fetch UPInt\u0026amp; UPInt::operator++() { *this += 1; // increment  return *this; // fetch } // postfix form: fetch and increment const UPInt UPInt::operator++(int) { const UPInt oldVal = *this; // fetch  ++(*this); // increment  return oldVal; // return what was fetched }   Apart from the obvious inefficiency resulting from the fact that postfix increment function creates a temporary object for its return value (MECpp item 19), as well as the explicit temporary object oldVal that has to be constructed and destructed, leading to the conclusion that prefix increment should be used whenever possible for its inherently higher efficiency, there are three points worth noting for the implementation of postfix form of operator++:\n1. Omit the parameter name Since the purpose of the parameter is only to distinguish prefix from postfix function invocation, the postfix operator makes no use of its parameter. Omitting parameter names avoids warnings from some compilers who insist that we use named parameters in the body of the function to which they apply.\n2. Return a const object There are two reasons to return a const object:\n  it\u0026rsquo;s consistent with the behavior of the built-in types, since ints most certainly do not allow double application of postfix increment:\n1 2  int i; i++++; // error!     if return value is not const, the behavior will be counterintuitive and confusing: after applying i++++, the second operator++ changes the value of the object returned from the first invocation, instead of the value of the original object. Hence, i ends up being incremented only once.\n  3. Implement postfix operators in terms of the prefix ones Both the prefix and postfix increment operators do the same thing: incrementing a value. In order to guarantee implementation won\u0026rsquo;t diverge over time, postfix increment and decrement should be implemented in terms of their prefix counterparts. Then we only need to maintain the prefix versions.\n","description":"","id":134,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-6 Distinguish Between Prefix and Postfix Forms of Increment and Decrement Operators","uri":"https://nianze.ml/en/notes/2018/03/distinguish-between-prefix-and-postfix-forms-of-increment-and-decrement-operators/"},{"content":"Implicit type conversions usually lead to more harm than good, so don\u0026rsquo;t provide conversion functions unless we\u0026rsquo;re sure we want them.\nThere are two kinds of functions allowing compilers to perform implicit type conversions:\n implicit type conversion operators non-explicit single-argument constructors  Implicit type conversion operators 1 2 3 4 5  class Rational { public: ... operator double() const; // converts Rational to double };   This implicit type conversion function will be automatically invoked in contexts like this:\n1 2 3  Rational r(1, 2); // r has a value 1/2 double d = 0.5 * r; // converts r to a double, then do multiplication count \u0026lt;\u0026lt; r; // will print a floating point number instead of 1/2 if lacking difinition of operator\u0026lt;\u0026lt;   Suppose we forget to write an operator\u0026lt;\u0026lt; for Rational objects, and expect the attempt to print r would fail due to the lack of appropriate operator\u0026lt;\u0026lt; to call. However, in the lack of operator\u0026lt;\u0026lt;, compilers are happy to find an acceptable sequence of implicit type conversions they could apply to make the call succeed. In this case, they will discover they could make the call succeed by implicitly converting r to a double by calling Rational::operator double, leading to wrong (often unexpected) function being called.\nSolution: replace the implicit type conversion operators with equivalent functions that don\u0026rsquo;t have the syntactically magic names, just like the explicit member function c_str in string type from standard C++ library (MECpp item 35):\n1 2 3 4 5  class Rational { public: ... double asDouble() const; // converts Rational to double };   1 2 3 4  Rational r(1, 2); cout \u0026lt;\u0026lt; r; // error! no operator\u0026lt;\u0026lt; for Rationals cout \u0026lt;\u0026lt; r.asDouble(); // fine, prints r as a double   Single-argument constructor 1 2 3 4 5 6 7 8 9  template\u0026lt;class T\u0026gt; class Array { public: Array(int lowBound, int highBound); // specify a range of array indices, ineligible for type-conversion  Array(int size); // specify the number of elements in the array, can be used as a type conversion function  T\u0026amp; operator[](int index); ... };   The problem of implicit type conversion occurs in following condition:\n1 2 3 4 5 6 7 8 9 10 11  bool operator==(const Array\u0026lt;int\u0026gt;\u0026amp; lhs, const Array\u0026lt;int\u0026gt;\u0026amp; rhs); Array\u0026lt;int\u0026gt; a(10); Array\u0026lt;int\u0026gt; b(10); ... for (int i = 0; i \u0026lt; 10; ++i) { // oops! \u0026#34;a\u0026#34; should be \u0026#34;a[i]\u0026#34;  if (a == b[i]) { .... } else { ... } }   Here, we mistakenly omitted the subscripting syntax when typing a. We expect this will cause compilers complaining, but they will not:\n  Compilers see a call to operator== taking type Array\u0026lt;int\u0026gt; (for a) and int (for b[i]), and fail to find the corresponding function\n  There\u0026rsquo;s a operator== taking two Array\u0026lt;int\u0026gt; type arguments, and compilers are able to convert the int into an Array\u0026lt;int\u0026gt; object by calling Array\u0026lt;int\u0026gt; constructor that taking a single int as an argument, ending up with something like this1:\n1 2 3  for (int i = 0; i \u0026lt; 10; ++i) { if (a == static_cast\u0026lt; Array\u0026lt;int\u0026gt; \u0026gt;(b[i])) ... }     Each iteration through the loop compares the contents of a with the contents of a temporary array of size b[i] (whose contents are presumably undefined and will be created and destroyed in every loop, see MECpp item 19), which is both unwanted and tremendously inefficient behavior.\nThere are two solutions: use keyword explicit or creating proxy classes.\nSolution 1: Keyword explicit 1 2 3 4 5 6 7  template\u0026lt;class T\u0026gt; class Array { public: ... explicit Array(int size); // use \u0026#34;explicit\u0026#34; to prevent implicit type conversion  ... };   Solution 2: Proxy classes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  template\u0026lt;class T\u0026gt; class Array { public: class ArraySize { public: ArraySize(int numElements): theSize(numElements) {} int size() const { return theSize; } private: int theSize; }; Array(int lowBound, int highBound); Array(ArraySize size); // new declaration  ... };   1 2 3 4 5  Array\u0026lt;int\u0026gt; a(10); // convert 10 to a temp. ArraySize object, then feed that temp. object to Array\u0026lt;int\u0026gt; ctor.  for (int i = 0; i \u0026lt; 10; ++i) { if (a == b[i]) ... // error now! }   One of the rules governing implicit type conversions is that no sequence of conversions is allowed to contain more than one user-defined conversion (i.e., a call to a single-argument constructor or an implicit type conversion operator). The above class difinition adopting a general technique called proxy classes takes advantage of this rule, ending up with ideal behavior that the object constructions we want to allow are legal, but the implicit conversions we don\u0026rsquo;t want to allow are illegal (compilers in one implicit conversion can\u0026rsquo;t call two user-defined conversions, one from int to ArraySize and one from ArraySize to Array\u0026lt;int\u0026gt;).\nProxy objects can give us control over aspects of software\u0026rsquo;s behavior that is otherswise beyond our grasp. For more detail, refer to MECpp item 30.\n The space separating the two \u0026ldquo;\u0026gt;\u0026rdquo; characters has its purpose: without it, the statement will be like static_cast\u0026lt;Array\u0026lt;int\u0026gt;\u0026gt;(b[i]), and some C++ compilers parsing \u0026ldquo;\u0026raquo;\u0026rdquo; as a single token, ending up with a syntax error.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":135,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-5 Be Wary of User Defined Conversion Functions","uri":"https://nianze.ml/en/notes/2018/03/be-wary-of-user-defined-conversion-functions/"},{"content":"Including meaningless default constructors affects the efficiency of classes, so avoiding them in classes guarantees fully-initialized objects, with the cost of some limits on how such classes can be used.\nFor many objects, there is no reasonable way to perform a complete initialization in the absence of outside information. Consider a class for company equipment in which the corporate ID number of the quipment is a mandatory constructor argument:\n1 2 3 4 5  class EquipmentPiece { public: EquipmentPiece(int IDNumber); ... };   With default constructor Some people believe all classes should include a default constructors, even if a default constructor doesn\u0026rsquo;t have enough information to fully initialize objects of the class. Adherents to this philosophy will modify EquipmentPiece as follows:\n1 2 3 4 5 6 7  class EquipmentPiece { public: EquipmentPiece(int IDNumber = UNSPECIFIED); ... private: static const int UNSPECIFIED; // magic ID num. value meaning no ID was specified };   There are two downsides after including a default constructor in a class where none was warranted:\n There\u0026rsquo;s no longer any guarantee that the fields of an EquipmentPiece object have been meaningfully initialized, so member functions must check if each object has valid IDNumber before using it. If not, clients must find a solution to deal with the situation - sometimes they simply throw an exception or terminates the program, which may degrade the overall quality of the software. The meaningless default constructors affects the efficiency of classes: member functions have to include extra code to test object\u0026rsquo;s validness and deal with the failure tests, and clients of those functions have to pay for the time those tests take as well as the space the extra code occupies.  Without default constructor If a class lacks a default constructor, there are restrictions on how you can use that class. Specifically, in three constexts:\n Creation of arrays Ineligible for some template-based container classes Virtual base classes  1. Creation of arrays There is, in general, no way to specify constructor arguments for objects in arrays:\n1 2  EquipmentPiece bestPieces[10]; // error! No way to call EquipmentPiece ctors. EquipmentPiece *bestPieces = new EquipmentPiece[10]; // error! same problem   There are three ways to get around the restriction:\n  Provide the necessary arguments when array is defined\nThis solution works only for non-heap arrays:\n1 2 3 4 5 6 7 8  int ID1, ID2, ID3, ..., ID10; // variables to hold equipment ID numbers ... EquipmentPiece bestPieces[] = { // fine, ctor arguments are provided  EquipmentPiece(ID1); EquipmentPiece(ID2); ... EquipmentPiece(ID10); }     Use an array of pointers instead of an array of objects\n1 2 3 4 5 6 7  typedef EquipmentPiece* PEP; // a PEP is a pointer to an EuipmentPiece PEP bestPieces[10]; // fine, no ctor called PEP *bestPieces = new PEP[10]; // fine, no ctor called  for (int i = 0; i \u0026lt; 10; ++i) { bestPieces[i] = new EquipmentPiece( ID Number ); }   The disadvantages to this approach is:\n We have to remember to delete all the objects pointed to by the array. Otherwise there\u0026rsquo;s resource leak. The total amount of memory increases due to the extra space for the pointers    Use \u0026ldquo;placement new\u0026rdquo; (item 8)\n1 2 3 4 5 6 7 8 9 10  // allocate enough memory for an array of 10 EuipmentPiece obj. void *rawMemory = operator new[](10*sizeof(EquipmentPiece)); // make bestPieces point to the memory so it can be treated as an EquipmentPiece array EquipmentPiece *bestPieces = static_cast\u0026lt;EquipmentPiece*\u0026gt; (rawMemory); // construct the EquipmentPiece objects in the memory using placement new for (int i = 0; i \u0026lt; 10; ++i) { new (bestPieces+i) EquipmentPiece( ID Number ); }   This design avoids the spece penalty of extra pointers, but the downside is that we must manually call destructors on the objects in the array, then manually deallocate the raw memory by calling operator delete[] (item 8), which is unfamiliar by most programmers1:\n1 2 3 4 5 6  // destruct the objects in bestPieces in the inverse order for (int i = 9; i \u0026gt;= 0; --i) { bestPieces[i].~EquipmentPiece(); } // deallocate the raw memory operator delete[](rawMemory);     2. Ineligible for some template-based container classes Some templates requires that the type used to instantiate the template proved a default constructor for purpose such as createing an array of the template parameter type inside the template:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  template\u0026lt;class T\u0026gt; class Array { public: Array(int size); ... private: T *data; }; Template\u0026lt;class T\u0026gt; Array\u0026lt;T\u0026gt;::Array(int size) { data = new T[size]; // calls T::T() for each elem. of the array  ... }   Although careful template design can eliminate the need for a default constructor (such as vector template), there are templates designed with that requirement. That being the case, classes without default constructors will be incompatible with such templates.\n3. Virtual base classes Arguments for virtual base class construcctors must be provided by the most derived class of the object being constructed. As a result, a virtual base class lacking a default constructor requires that all classes derived from that class must know about, understand the meaning of, and provide for the virtual base class\u0026rsquo;s constructors' arguments, which is neigher expected not appreciated by authors of derived classes.\n If we forget this requirement and use the normal array-deletion syntax delete[] bestPieces, the program will behave unpredictably, because deleting a pointer that didn\u0026rsquo;t come from the new operator is undefined.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":136,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-4 Avoid Gratuitous Default Constructors","uri":"https://nianze.ml/en/notes/2018/03/avoid-gratuitous-default-constructors/"},{"content":"Array operations almost always involve pointer arithmetic, so arrays and polymorphism don\u0026rsquo;t mix.\nC++ allows us to manipulate arrays of derived class objects through base class pointers and references, but it almost nerver works athe way we want it to.\nFor example, suppose following base class BST (binary search tree objects) and its derived class BalancedBST:\n1 2  class BST {...}; class BalancedBST: public BST {...};   For a function working with an array of BSTs, it works fine when we pass it an array of BST objects:\n1 2 3 4 5 6 7 8 9 10  void printBSTArray(ostream\u0026amp; s, const BST array[], int numElements) { for (int i = 0; i \u0026lt; numElements; ++i) { s \u0026lt;\u0026lt; array[i]; // assumes operator\u0026lt;\u0026lt; is defined for BST objects  } } BST BSTArray[10]; ... printBSTArray(cout, BSTArray, 10); // work fine   However, when passing an array of BalancedBST objects:\n1 2 3  BalancedBST bBSTArray[10]; ... printBSTArray(cout, bBSTArray, 10);   The compilers will accept this function call without complaint, but then for array[i]`, they will generate code involving pointer arithmetic:\n array[i] is just shorthand for expression *(array+i) the distance between the memory location pointed to by array and by array+i is calculated through i*sizeof(object in the array) the parameter array is declared to be of type array-of-BST, so each element of the array is regard as BST, and thus the distance is i*sizeof(BST) the size of an object of type BalancedBST usually is larger than their base class ones' size, because derived class usually has extra data members If it is, the ointer arithmetic generated for printBSTArray will be wrong for arrays of BalancedBST objects  Another problem will pop up if we try to delete an array of derived class objects through a base class pointer:\n1 2 3 4 5 6 7 8 9 10  void deleteArray(ostream\u0026amp; logStream, BST array[]) { logStream \u0026lt;\u0026lt; \u0026#34;Deleting array at address \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;void*\u0026gt;(array) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; delete [] array; } BalancedBST *balTreeArray = new BalancedBST[50]; // create a BalancedBST array ... deleteArray(cout, balTreeArray); // log its deletion   There\u0026rsquo;s pointer arithmetic going on here, too: when compilers see the statement delete [] array;, they will generate code that looks like this:\n1 2 3 4  for (int i = the number of elements in the array - 1; i \u0026gt;= 0; --i) { array[i].BST::~BST(); // call array[i]\u0026#39;s destructor }   Now we understand why the language specification says that the result of deleting an array of derived class objects through a base class pointers is undefined: here, again, polymorphism meets pointer arithmetic.\nIn the point of software designing, as MECpp-item 33 suggests, we\u0026rsquo;re unlikely to make the mistake of treating an array polymorphically if we avoid having a concrete class (like BalancedBST) inherit from another concrete class (such as BST).\n","description":"","id":137,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-3 Never Treat Arrays Polymorphically","uri":"https://nianze.ml/en/notes/2018/03/never-treat-arrays-polymorphically/"},{"content":"More effective C++: Use references when we already have something to refer to and never want to refer to anything else, or when implementing operators whose syntactic requires us to do so.\nBoth pointers and references refer to other objects indirectly, and we should distinguish their differences.\nNo null reference A reference must always refer to some object, which implies that references must be initialized:\n1 2 3 4  string\u0026amp; rs; // error! References must be initialized string *ps; // valid but risky uninitialized pointer string s(\u0026#34;abc\u0026#34;); string\u0026amp; rs = s; // fine   Having known this, if we have a variable whose purpose is to refer to another object, but it is possible that there might be no object to refer to, we should make the variable a pointer; on the other hand, if the design requires that the variable must always refer to a non-null object, we choose the reference.\nAs an implication, reference\u0026rsquo;s never-nullable property save us from the burden of testing the validity before using it:\n1 2 3 4 5 6 7 8 9 10 11  void printRefDouble(const double\u0026amp; rd) { cout \u0026lt;\u0026lt; rd; // no need to test rd. } void printPointDouble(const double *pd) { if (pd) { // check for null pointer  cout \u0026lt;\u0026lt; *p; } }   No reassignment for reference Another difference is that we can reassign pointers to refer to different objects, while reference always refers to the one it is initialized:\n1 2 3 4 5 6 7 8  string s1(\u0026#34;Nancy\u0026#34;); string s2(\u0026#34;Clancy\u0026#34;); string\u0026amp; rs = s1; // rs refers to s1 string *ps = s1; // ps points to s1  rs = s2; // rs still refers to s1, but s1\u0026#39;s value updates to \u0026#34;Clancy\u0026#34;, equiv. to *ps = s2 ps = \u0026amp;s2; // ps now points to s2, s1 remains unchanged   In general, use pointers when\n it\u0026rsquo;s possible that there\u0026rsquo;s nothing to refer to (set pointers to null), or it\u0026rsquo;s needed to refer to different things at different times (reassign where the pointer points)  use reference when we know there will always be an object to refer to and we will never refer to anything else other than the initial object.\nUse reference for some operators Another situation to prefer reference is when we\u0026rsquo;re implementing certain operators such as operator[], which needs to return something that can be used as the target of an assignment:\n1 2  vector\u0026lt;int\u0026gt; v(10); v[5] = 10; // the target of this assignment is the return value of operator[]   If operator[] returned a pointer, last statement would be changed to this:\n1  *v[5] = 10;   This makes v look like a vector of pointers, which it\u0026rsquo;s not. Thus we may prefer using a reference as the return type of operator[] (for an exception, see MECpp-item 30).\n","description":"","id":138,"section":"notes","tags":["technique","cpp"],"title":"[MECpp]Item-1 Distinguish Between Pointers and References","uri":"https://nianze.ml/en/notes/2018/03/distinguish-between-pointers-and-references/"},{"content":"When we write a placement version of operator new, be sure to write the corresponding placement version of operator delete to avoid subtle, intermittent memory leaks. When we do so, pay attention not to unintentionally hide the normal versions of new and delete\nPlacement version of new When an operator new function takes extra parameters (other than the mandatory size_t argument), that function is known as a placement version of new. For example:\n1  void* operator new(std::size_t, void *pMemory) throw(); // placement new   This specific version of placement new is in C++\u0026rsquo;s standard library (access through #include\u0026lt;new\u0026gt;) and is the original placement new. Later, people also use the term \u0026ldquo;placement new\u0026rdquo; to refer any version of operator new that takes extra arguments. The phrace \u0026ldquo;placement delete\u0026rdquo; also derives from this version.\nTo avoid subtle memory leak Suppose we want to write a class-specific operator new that requires specification of an ostream to which allocation information should be logged:\n1 2 3 4 5 6  class Widget { public: ... static void* operator new(std::size_t size, std::ostream\u0026amp; logStream) throw(std::bad_alloc) // non-normal form of new  static void operator delete(void *pMemory, std::size_t size) throw(); // normal class-specific form of delete };   And we call it this to log allocation informatino to cerr when dynamically creating a Wdiget:\n1  Widget *pw = new (std::cerr) Widget; // call operator new, passing cerr as the ostream; cause memory leak when Widget constructor throws   Let\u0026rsquo;s consider a special subtle situation: if memory allocation succeeds and the Widget constructor throws an exception, since pw not yet assigned and client code can\u0026rsquo;t deallocate the memory, the runtime system is responsible for undoing the allocation that operator new performed. However, we\u0026rsquo;re now using a non-normal version of operator new, unless it finds a version of operator delete that takes the same number and types of extra arguments as operator new, the runtime system choose to do nothing, so no operator delete will be called, ending up with memory leak.\nTo eliminate the memory leak in this situation, we need to match the placement new with a placement delete:\n1 2 3 4 5 6 7  class Widget { public: ... static void* operator new(std::size_t size, std::ostream\u0026amp; logStream) throw(std::bad_alloc) // non-normal form of new  static void operator delete(void *pMemory, std::size_t size) throw(); static void operator delete(void *pMemory, std::ostream\u0026amp; logStream) throw(); corresponding non-normal form of delete };   Now following code will work without leak:\n1 2  Widget *pw = new (std::cerr) Widget; // no potential leak delete pw; // invokes the normal operator delete   Do not hide normal form of new and delete By default, C++ offers the following forms of operator new (and corresponding operator delete) at global scope:\n1 2 3  void* operator new(std::size_t) throw(std::bad_alloc); // normal new void* operator new(std::size_t, void*) throw(std::bad_alloc); // placement new void* operator new(std::size_t, const std::nothrow_t\u0026amp;) throw(); // nothrow new, item 49   According to item 33, member function names hide functions with the same names in outer scopes, so we want to avoid having class-specific news hide other news that our client expect. For example, if the base class declares only a placement new, clients will find the normal version of new unavailable:\n1 2 3 4 5 6 7 8 9  class Base { public: ... static void* operator new(std::size_t size, std::ostream\u0026amp; logStream) throw(std::bad_alloc); // hide the normal global form  ... }; Base *pb = new Base; // error! the normal form is hidden Base *pb = new (std::cerr) Base; // fine, call the placement new   Similarly, redeclaring operator new in derived classes hide both global and inherited versions of operator new:\n1 2 3 4 5 6 7 8 9  class Derived: public Base { public: ... static void* operator new(std::size_t size) throw(std::bad_alloc); // redeclare the normal form  ... }; Derived *pd = new (std::clog) Derived; // error! Base\u0026#39;s placement new is hidden Derived *pd = new Derived; // fine, call Derived\u0026#39;s operator new   In order to make normal version of operator new accessible in addition to customed ones, we need to declare all forms (both standard version and placement version) in our class. If we want class-specific standard versions to behave in the usual way, just have the them call the global versions. An easy way to do this is to create a base class containing all the normal forms of new and delete:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class StandardNewDeleteForm { public: // normal new/delete  static void* operator new(std::size_t size) throw(std::bad_alloc) { return ::operator new(size); } static void operator delete(void *pMemory) throw() { ::operator delete(pMemory); } // placement new/delete  static void* operator new(std::size_t size, void *ptr) throw(std::bad_alloc) { return ::operator new(size, ptr); } static void operator delete(void *pMemory, void *ptr) throw() { ::operator delete(pMemory, ptr); } // nothrow new/delete  static void* operator new(std::size_t size, const std::nothrow_t\u0026amp; nt) throw() { return ::operator new(size, nt); } static void operator delete(void *pMemory, const std::nothrow_t\u0026amp; nt) throw() { ::operator delete(pMemory, nt); } };   Clients who want to augment the standard forms with custom forms can just use inheritance and using declarations (item 33) to get all forms accessible:\n1 2 3 4 5 6 7 8 9  class Widget: public StandardNewDeleteForms { // inherit std forms public: using StandardNewDeleteForms::operator new; // make std forms of new visible  using StandardNewDeleteForms::operator delete; // make std forms of delete visible  static void* operator new(std::size_t size, std::ostream\u0026amp; logStream) throw(std::bad_alloc); // custom placement new  static void operator delete(void *pMemory, std::ostream\u0026amp; logStream) throw(); // corresponding placement delete  ... };   ","description":"","id":139,"section":"notes","tags":["technique","cpp"],"title":"Item-52 Write placement delete if you write placement new","uri":"https://nianze.ml/en/notes/2018/03/write-placement-delete-if-you-write-placement-new/"},{"content":"operator new should contain an infinite loop trying to allocate memory, should call the new-handler if it can\u0026rsquo;t satisfy a memory request, and should handle requests for zero bytes; class-specific versions should handle requests for larger blocks than expected. operator delete should do nothing if passed a pointer that is null; class specific versions should handle blocks that are larger than expected.\nWhen write our own versions of operator new and operator delete, there are conventions we must follow.\n1. operator new Implementing a conformant operator new requires:\n having the right return value calling the new-handling function when insufficient memory is available (item 49) being prepared to cope with requests for no memory avoiding hiding the \u0026ldquo;normal\u0026rdquo; form of new (item 52)  Have the right return value If succeeding to supply the requested memory, return a pointer to it.\nCall the new-handler If failing to supply the requested memory, follow the rule in item 49 to call the new-handling function after each fauilure. It is assumed that new-handling function might be able to free up some memory. Throw an exception of type bad_alloc only when the pointer to the new-handler is null.\nCope with request for no memory C++ requires that operator new return a legitimate pointer even when zero bytes are requested (because this simplifies things else where in the language), so pseudocode for a non-member operator new looks like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  void* operator new(std::size_t size) throw(std::bad_alloc) { using namespace std; if (size == 0) { size = 1; // handle 0-byte requests by treating them as 1-byte requests  } while(true) { attempt to allocate size bytes if (succeed to allocate) return (a pointer to the memory); // allocation fails  new_handler globalHanlder = set_new_hanlder(0); // find out current  set_new_handler(globalHandler); // new handling-function  if (globalHandler) (*globaleHandler)(); else throw std::bad_alloc(); } }   Avoid hiding the \u0026ldquo;normal\u0026rdquo; form of new Class specific operator new member functions are inherited by derived classes, so it is possible that the operator new tuned for objects of size sizeof(base) might accidentally be called to allocate memory for an object of a derived class. To handle this situation, do following trick:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Base { public: static void * operator new(std::size_t size) throw(std::bad_alloc); ... }; class Derived:public Base // Derived doesn\u0026#39;t declare operator new {...}; void * Base::operator new(std::size_t size) throw(std::bad_alloc) { if (size != sizeof(Base)) return ::operator new(size); // if size is \u0026#34;wrong\u0026#34;, call standard operator new  ... // otherwise do the Base-specific operation } Derived *p = new Derived; // calls Base::operator new   Note that sizeof(Base) can never be zero - freestanding objects have non-zero size (item 39) - so the zero-size memory request will be forwarded to ::operator new to handle in a reasonable fashion.\nControl memory allocation for operator new[] To control allocation for arrays on a per-class basis, we need to implement operator new[] - all we can do is allocating a chunk of raw memory. The point here is that we can not do any assumption about the as-yet-nonexistent objects in the array:\n it is possible to allocate memory for an array of derived class objects via base class\u0026rsquo;s operator new[] through inheritance, and the size of derived class objects are usually bigger than base class objects, so the number of objects in the array is no neccessarily (bytes requested) / sizeof(Base) size_t parameter passed to operator new[] may be for more memory than will be filled with objects, because dynamically allocated arrays may include extra space to store the number of array elements (item 16).  2. operator delete C++ guarantees it\u0026rsquo;s always safe to delete the null pointer, so things are easier in terms of implementing operator delete:\n1 2 3 4 5 6  // non-member operator delete void operator delete(void *rawMemory) throw() { if (rawMemory == 0) return; // do nothing if the null pointer is being deleted  deallocate the memory pointed to by rawMemory }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // class-specific operator delete class Base { // same as before, except that operator delete is declared public: static void * operator new(std::size_t size) throw(std::bad_alloc); static void operator delete(void *rawMemory, std::size_t size) throw(); ... } void Base::opearator delete(void *rawMemory, std::size_t size) throw() { if (rawMemory == 0) return; if (size != sizeOf(Base)) { // if size is \u0026#34;wrong\u0026#34;,  ::operator delete(rawMemory); // use standard operator delete to handle the request  } deallocate the memory pointed to by rawMemory; return; }   BTW, the size_t value C++ passes to operator delete may be incorrect if object being deleted was derived from a base class lacking a virtual destructor, which is another reason to support the argument in item 7 that operator delete may not work correctly if virtual destructors is omitted in base classes.\n","description":"","id":140,"section":"notes","tags":["technique","cpp"],"title":"Item-51 Adhere to convention when writing new and delete","uri":"https://nianze.ml/en/notes/2018/03/adhere-to-convention-when-writing-new-and-delete/"},{"content":"There are many valid reasons for writing custom versions of new and delete, including improving performance, debugging heap usage errors, and collecting heap usage information.\nSome most common reasons to replace the compiler-provided versions of operator new and operator delete:\n To detect usage errors:  By having operator new keep a list of allocated addresses and operator delete remove addresses from the list, it\u0026rsquo;s easy to detect usage errors such as memory leaks (fail to delete memory conjured up by new) or over-delete(using more than one delete on newed memory) By customizing operator new to overallocate blocks so there\u0026rsquo;s room to put known byte patterns (\u0026ldquo;signatures) before and after the memory made avaiblable to clients, operator deletes can check to see if the signatures are still intact, so that the abnormal pattern resulted from overrun (writing beyond the end of an allocated block) or underrun (writing prior to the begining of an allocated block) could be logged down, along with the value of the offending pointer.   To collect usage statistics about dynamically allocated memory:  Custome versions of operator new and operator delete make it easy to collect following information:  the distribution of allocated block sizes and their lifetimes the order of allocation and deallocation (FIFO, LIFO, or random) usage patterns change over time (e.g., different allocation/deallocation patterns in different stages of execution) the maximum amount of dynamically allocated memory in use at any one time (e.g., its \u0026ldquo;high water mark\u0026rdquo;)     To improve efficiency:  The operator news and operator deletes that ship with compilers are designed for general-purpose use, which means they work reasonably well for everybody, but optimally for nobody.  To increase the speed of allocation and deallocation: custom versions of operator new and operator delete are often faster, especially for fixed-size allocators such as those offered by Boost\u0026rsquo;s Pool library. If our application is signle-threaded, but our compiler\u0026rsquo;s default memory management routines are thread-safe, we may be able to win measurable speed improvements by writing thread-unsafe allocators (be sure to profile the program before speeding up though). To reduce the space overhead of default memory management: general-purpose memory managers often use more memory to incur some overhead for each allocated block. Allocators tuned for small objects (such as those in Boost\u0026rsquo;s Pool library) essentially eliminate such overhead.     To compensate for suboptimal alignment in the default allocator:  Many architectures require that data of particular types be placed in memory at particular kinds of address (otherwise it leads to hardware exceptions at runtime), while other architectures, thought accepting misaligned data, will offer better performance if alignment preferences are satisfied. For example, it\u0026rsquo;s faster to access doubles on x86 architecture when they are eight-byte aligned.   To cluster related objects near one another:  if some particular data structures are generally used together and we\u0026rsquo;d like to minimize the frequency of page faults when working on the data, it makes sense to create a separate heap for the data structures so they are clustered together on as few pages as possible. For example, placement versions of new and delete (item 52) makes it possible to achieve such clustering.   To obtain unconventinal behavior:  For example, we might want to allocate and deallocate blocks in shared memory only through a C API to mange the memory, so we can write custome versions of new and delete (probably placement versions, item 52) to drape the C API in C++ clothing. For another example, we might write a custom operator delete that overwrites deallocated memory with zeros in order to increase the security of application data.    Writing a custom memory manager that almost works is pretty easy, but writing one that works well is a lot harder. For example, here\u0026rsquo;s a quick first pass at a global operator new that facilitates the detection of under- and overruns.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  static const int signature = 0xDEADBEEF; typedef unsigned char Byte; // this code has several flaws void* operator new(std::size_t size) throw (std::bad_alloc) { using namespace std; size_t realSize = size + 2 * sizeof(int); // increase size of request so 2 signatures will also fit inside  void *pMem = malloc(realSize); // call malloc to get the actual memory  if (!pMem) throw bad_alloc(); // write signature into first and last parts of the memory  *(static_cast\u0026lt;int*\u0026gt;(pMem)) = signature; *(reinterpret_cast\u0026lt;int*\u0026gt;(static_cast\u0026lt;Byte*\u0026gt;(pMem)+realSize-sizeof(int))) = signature; // return a pointer to the memory just past the first signature  return static_cast\u0026lt;Byte*\u0026gt;(pMem) + sizeof(int); }   One obvious shortcoming of this operator new is its failure to adhere to the C++ conventions for operator new - item 51 explains that all operator new should contain a loop calling a new-handling function, but this one above doesn\u0026rsquo;t.\nAnother subtle issue is alignment: C++ requires that all operator new and malloc return pointers that are suitably aligned for any data type. In this version of operator new, we\u0026rsquo;re returning a pointer we got from malloc offset by the size of an int. If we are running on a manchine where ints were four bytes in size but doubles were required to be eight-byte aligned, we\u0026rsquo;d probably return a pointer with improper alignment when operator new is called to get enough memory for a double.\nAs a general rule, do not attempt writing a custom memory manager unless we have to. In fact, in many cases, we don\u0026rsquo;t have to:\n some compilers have switches that enable debugging and logging functionality in their memory management functions. on many platforms, commercial products can replace the memory management functions that ship with compilers (all we need is to buy and relink).  Even if we decide to write our own news and deletes, it\u0026rsquo;s helpful to look at open source versions first to gain insights into the easy-to-overlook details that separate almost working from really working. One such open source allocator is the Pool library from Boost (item 55).\n The pool library offers allocators tuned for one of the most common situations in which custom memory management is helpful: allocation of a large number of small objects. Real libraries tend to have code that\u0026rsquo;s robust in terms of pesky details such as portability and alignment considerations, thread safety, etc.\n","description":"","id":141,"section":"notes","tags":["technique","cpp"],"title":"Item-50 Understand when it makes sense to replace new and delete","uri":"https://nianze.ml/en/notes/2018/03/understand-when-it-makes-sense-to-replace-new-and-delete/"},{"content":"set-new-handler allows you to specify a function to be called when memory allocation requests cannot be satisfied.\nThe basic If operator new can\u0026rsquo;t satisfy a memory allocation request, it will call a client-specifiable error-handling function called a new-handler before throwing a bad_alloc exception. To specify this out-of-memory-handling function, clients call set_new_handler, a standard library function declared in \u0026lt;new\u0026gt;:\n1 2 3 4  namespace std { typedef void (*new_handler)(); new_handler set_new_handler(new_handler p) throw(); }   The throw() here is an exception specification, telling us that function set_new_handler won\u0026rsquo;t throw any exceptions (though there\u0026rsquo;s more truth, refer to item 29).\nset_new_handler\u0026rsquo;s parameter is the new new_handler we want to specify, which is a pointer to the function operator new should call if it fails to allocate the requested memory, and the return value if the previous new_handler. Once operator new fails to fulfill a memory request, it calls the new_handler function repeatedly until it succeeds to find enough memory (more details in item 51), so this default behavior gives us following conclusion - a well-designed new-handler function must do one of the following:\n Make more memory available to allow the next memory allocation attempt inside operator new to succeed1. Install a different new-handler that may be capable to make more memory 2. A variation is to modify the behavior of current new-handler (via modifying static, namespace specific, or global data the affects the new-handler\u0026rsquo;s behavior) Deinstall the new-handler, i.e., pass the null pointer to set_new_handler, which leads to operator new throwing a bad_alloc exception. Throw an exception of type bad_alloc or some type derived from bad_alloc, which will firstly be caught by operator new and then propagate to the site originating the request for memory. Not return, typically by calling abort or exit.  For example, to use set-new-handler:\n1 2 3 4 5 6 7 8 9 10 11 12  // new handler to install void outOfMem() { std::cerr \u0026lt;\u0026lt; \u0026#34;Unable to satisfy request for memory\\n\u0026#34;; std::about(); } int main() { std::set_new_handler(outOfMem); int *pBigDataArray = new int[100000000L]; }   Customize the new-handler per class C++ has no support for class-specific new-handlers, so we implement this by ourselves: we have each class provide its own versions of set_new_handler (which allows clients to specify the customized new-handler) and operator new (which ensures the class-specific new-handler is used in place of the global new-handler when memory allocation request fails).\nTo make thie ensurance confirmed, this class-specific operator new should do the following stuff:\n Call the standard set_new_handler to install Widget\u0026rsquo;s own error-handling function as the global new-handler. Call the global operator new to perform the actual memory allocation. Two things may happen during this step:  if allocation ultimately fails and a bad_alloc is thrown by the global operator new, restore the original global new-handler, and then propagate the exception if allocation succeeds, return a pointer to the allocated memory, and then restore the original global new-handler prior to the call to Widget::operator new.    To ensure that the original new-handler is always reinstalled, we can treat the global new-handler as a resource and follow the advice of item 13 to use resource-managing objects to prevent resource leaks:\n1 2 3 4 5 6 7 8 9 10 11  class NewHandlerHolder { public: explicit NewHandlerHolder(std::new_handler nh) // aquire the original new-handler  :handler(nh) {} ~NewHandlerHolder() { std::set_new_handler(handler); } // release the original new-handler private: std::new_handler handler; // remember the original new-handler  NewHandlerHolder(const NewHandlerHolder\u0026amp;); // prevent copying see item 14  NewHandlerHolder\u0026amp; operator=(const NewHandlerHolder\u0026amp;); // prevent copying see item 14 };   Since the behavior of setting a class-specific new-handler is the same regardless of the class, we can reuse the setting procedure by creating a \u0026ldquo;mixin-style\u0026rdquo; base class (i.e., a base class that\u0026rsquo;s designed to allow derived classes to inherit a single specific capability), so that each derived class not only inherits the set_new_handler and operator new functions from the base class, but also gets a different class-specific new-handler from the template.\n1 2 3 4 5 6 7 8 9  template\u0026lt;typename T\u0026gt; // \u0026#34;mixin-style\u0026#34; base class class NewHandlerSupport { // for class-specific set_new_handler support public: static std::new_handler set_new_handler(std::new_handler p) throw(); static void* operator new(std::size_t size) throw(std::bad_alloc); ... // other versions of op. new - see item 52 private: static std::new_handler currentHandler; };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  template\u0026lt;typename T\u0026gt; std::new_handler NewHandlerSupport\u0026lt;T\u0026gt;::set_new_handler(std::new_handler p) throw() { std::new_handler oldHandler = currentHandler; currentHandler = p; return oldHandler; } template\u0026lt;typename T\u0026gt; void* NewHandlerSupport\u0026lt;T\u0026gt;::operator new(std::size_t size) throw(std::bad_alloc) { NewHandlerHolder h(std::set_new_handler(currentHandler)); // install new-handler  return ::operator new(size); // allocate memory or throw } // restore global new-handler  template\u0026lt;typename T\u0026gt; std::new_handler NewHanderSupport\u0026lt;T\u0026gt;::currentHandler = 0; // init. currentHandler to null   With this class template, adding set_new_handler support to Widget is easy: Widget just inherits from NewHandlerSupport\u0026lt;Widget\u0026gt;:\n1 2 3 4  class Widget: public NewHandlerSupport\u0026lt;Widget\u0026gt; { public: ... // without declaration for set_new_handler or operator new };   One interesting point for this design is that Widget inheriting from a templatized base class that takes Widget itself as a type parameter, and this technique has a straightforwart name: curiously recurring template pattern (CRTP).\nAnother point worth noting is that the NewHandlerSupport template never uses its type parameter T, because it doesn\u0026rsquo;t need to: all we need is a different copy of static data member currentHJandler for each class inheriting from NewHandlerSupport, and template parameter T just makes it possible to distinguish these derived classes - the template mechanism automatically generates a copy of currentHandler for each T with which NewHandlerSupport is instantiated.\nFinally, let\u0026rsquo;s take a look at how to use the new-handling capabilities in Widget:\n1 2 3 4 5 6  void outOfMem(); // decl. of class-specific new-handler func. Widget::set_new_handler(outOfMem); // set outOfMem as Widget\u0026#39;s new-handler Widget *pw1 = new Widget; // if mem. alloc. fails, call outOfMem std::string *ps = new std::string; // if mem. alloc. fails, call the original global new-handler (if there is one) Widget::set_new_handler(0); // set the Widget-specific new-handler to nothing (null) Widget *pw2 = new Widget; // there\u0026#39;s no new-handling func. for Widget now, so if mem. alloc. fails, throw an exception immediately   Traditional failure-yields-null alternative for operator new Althought now it is specified to throw a bad_alloc exception, until 1993, C++ required that operator new return null when it way unable to allocate the requested memory. Unwilling to abandon the traditional behavior, the C++ standardization committee provided an alternative form of operator new called \u0026ldquo;nothrow\u0026rdquo; forms, in part because the forms employ nothrow objects defined in the header \u0026lt;new\u0026gt;:\n1 2 3 4 5  class Widget {...}; Widget *pw1 = new Widget; // throws bad_alloc if allocation fails if (pw1 == 0) ... // this test must fail Widget *pw2 = new (std::nothrow) Widget; // returns 0 if allocation fails if (pw2 == 0) ... // this test may succeed   However, using new (std::nothrow) Widget only guarantees that operator new won\u0026rsquo;t throw, not the whole expression: after the nothrow versoin of operator new succeeds to allocate enough memory for a Widget object, and then the Widget constructor is called, chances are that the Widget constructor might itself new up some memory and throw, and then the exception will be propagated as usual.\nConclusion: we never have a need for nothrow new.\n One way to achieve this strategy is to allocate a large block of memory at program start-up, then release it for use in the program the first time the new-handler is invoked.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n The strategy may be implemented by calling set_new_handler inside current new-handler. The next time operator new call the new-handler function, it will get the one most recently installed.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":142,"section":"notes","tags":["technique","cpp"],"title":"Item-49 Understand the behavior of the new handler","uri":"https://nianze.ml/en/notes/2018/03/understand-the-behavior-of-the-new-handler/"},{"content":"Template metaprogramming can shift work from runtime to compile-time (thus enabling earlier error dettection and higher runtime performance), can be used to generate custom code based on combinations of policy choices, and can also be used to avoid generating code inappropriate for particular types.\nTemplate metaprogramming (TMP) is the process of writing template-based C++ programs that execute inside the C++ compiler, ending up with pieces of C++ source code instantiated from templates, which are then compiled as usual. TMP was discovered, not designed, in the early 1990s, and has later been shown to be Turing-complete, which means that it is powerful enough to compute anything (declare variables, perform loops, write and call functions, etc).\nStrength of TMP TMP has two great strengths:\n it makes some things easy that would otherwise be hard or impossiblle it shifts work from runtime to compile-time1  By making use of TMP, we can expect following good consequences:\n Some kinds of errors originally detected at runtime could be found during compilation C++ progrmas become more efficient in about every way: smaller executables, shorter runtimes, lesser memory requirements  To take a glimpse into how things work in TMP, let\u0026rsquo;s look at two examples.\nExamples   Ex1: if...else conditionals in TMP\nAs item 47 shows, if...else conditionals in TMP are expressed via templates and template specializations2. Let\u0026rsquo;s take a comparason between the \u0026ldquo;normal\u0026rdquo; C++ (using typeid) and TMP (using traits) based on implementing the pseudo part of if (iter is a random access iterator) from STL\u0026rsquo;s advance\nBelow is the \u0026ldquo;normal\u0026rdquo; C++ approach, which evaluates at runtime:\n1 2 3 4 5 6 7 8 9 10 11 12  template\u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d) { if (typeid(typename std::iterator_traits\u0026lt;IterT\u0026gt;::iterator_categoray) == typeid(std::random_access_iterator_tag)) { iter += d; // use iterator arithmetic for random access iters  } else { if (d \u0026gt;= 0) { while(d--) ++iter; } else { while(d++) --iter; } } }   Compared to the one using traits, the typeid-based approach has following issues:\n less efficient: testing occurs at runtime; executable is larger (since the code to do the testing must be present in the executable) introduce compilation problems: if iter isn\u0026rsquo;t a random access iterator, iter will not support operator +=, so iter += d will not be valid, but compilers will still check this part of code and complain about its invalidation, because they are obliged to make sure that all source code is valid, even if it\u0026rsquo;s not executed.    Ex2: loops in TMP\nTMP has no real looping construct, so the effect of loops is accomplished via recursion, or more specifically, recursive template instantiations. As an example, TMP factorial computation demonstates how it works:\n1 2 3 4 5 6 7 8 9  template\u0026lt;unsigned n\u0026gt; // general case: the value of Factorial\u0026lt;n\u0026gt; is n times the value of Factorial\u0026lt;n-1\u0026gt; struct Factorial { enum { value = n * Factorial\u0026lt;n-1\u0026gt;::value }; }; template\u0026lt;\u0026gt; struct Factorial\u0026lt;0\u0026gt; { enum { value = 1 }; };   The looping part of the code occurs where the template instantiation Factorial\u0026lt;n\u0026gt; references the tempalte instantiation Factorial\u0026lt;n-1\u0026gt;, until hitting the special case, Factorial\u0026lt;0\u0026gt;, that causes the recursion to terminate.\nEach instantiation of the Factorial template is a struct, and each struct uses the enum hack (item 2) to declare a TMP variable named value, which holds the current value of the factorial computation. After recursive template instantiation, each instantiation gets its own copy of value.\nTo use Factorial:\n1 2 3 4 5  int main() { std::cout \u0026lt;\u0026lt; Factorial\u0026lt;5\u0026gt;::value; // prints 120  std::cout \u0026lt;\u0026lt; Factorial\u0026lt;10\u0026gt;::value; // prints 3628800 }   To sum up the technique keywords: templates and specializations and recursive instantiations and enum hacks.\n  What can be accomplished in TMP 1. Ensuring dimensional unit correctness In scientific and engineering applications, it\u0026rsquo;s essential that dimensional units (e.g., mass, distance, time, etc.) be combined correctly. Using TMP, it\u0026rsquo;s possible to ensure (during compilation) that all dimensional unit combinations in a program are correct, no matter how complex the calculations - good example for early error detection.\n2. Optimizang matrix operations Consider the following code,\n1 2 3 4  typedef SqureMatrix\u0026lt;double, 10000\u0026gt; BigMatrix; BigMatrix m1, m2, m3, m4, m5; // create matrices ... // give them values BigMatrix result = m1 * m2 * m3 * m4 * m5; // compute the product   Calculating result in the \u0026ldquo;normal\u0026rdquo; way calls for the creation of four temporary matrices, one for the reuslt of each call to operator*. Furthermore, the independent multiplications generate a sequence of four loops over the matrix elements.\nUsing an advanced template technology related to TMP called expression templates, it\u0026rsquo;s possible to eliminate the temporaries and merge the loops, without changing the syntax of the client code above while enabling the program consume less memory and run dramatically fast.\n3. Generating custom design pattern implementations Design patterns like Strategy (item 35), Observer, Visitor, etc. can be implemented in many ways. Using a TMP-based technology called policy-based design, it\u0026rsquo;s possible to create templates representing independent design choices (\u0026ldquo;policies\u0026rdquo;) that can be combined in arbitrary ways to yield pattern implementations with custom behavior.\nGeneralized beyond the domain of programming artifacts like design patterns, this technology is a basis for what\u0026rsquo;s known as generative programming.\n Programs using TMP may take much longer to compile than their non-TMP counterparts.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Basic constructs, such as declaring variables, performing loops, and calling function, may look very different from their \u0026ldquo;normal\u0026rdquo; C++ counterparts, but that\u0026rsquo;s assembly-level TMP - it\u0026rsquo;s worth to know that libraries for TMP (e.g., Boost\u0026rsquo;s MPL, item 55) offer a higher-level syntax.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":143,"section":"notes","tags":["technique","cpp"],"title":"Item-48 Be aware of template metaprogramming","uri":"https://nianze.ml/en/notes/2018/03/be-aware-of-template-metaprogramming/"},{"content":"Implemented by templates and template specializations, traits classes make information about types available during compilation. Combining traints with overloading, it is possible to perform compile-time if...else tests on types.\nIn this item, let\u0026rsquo;s look at how STL supports the utility template advance, which moves a specified iterator a specified distance:\n1 2  template\u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d); // move iter d units forward; if d \u0026lt; 0, move iter backward   Before we step into the field of advance implementation, we should be familiar about STL iterator categoryies, because different iterators support different operations.\nFive iterator categories According to the operations they support, there are five categories of iterators1:\n Input iterators can move only one step forward at a time, can only read, and can read what they\u0026rsquo;re pointing to only once (e.g., istream_iterator) Output iterators can move only one step forwrad at a time, can only write, and can write what they\u0026rsquo;re pointing to only once (e.g., ostream_iterator) Forward iterators can do whatever input and output iterators can do, and they can read or write what they point to momre than once (e.g., singly linked list or iterators into TR1\u0026rsquo;s hashed containers (item 54) may be in the forward category) Bidirectional iterators add to forward iterators the ability to move backward as well as forward (e.g., iterators for list, set, multiset, map, multimap in STL) Random access iterators are the most powerful ones: they add to bidirectional iterators the ability to perform \u0026ldquo;iterator arithmetic\u0026rdquo; - to jump forward or backward an arbitrary distance in constant time, which is similar to pointer arithmetic (e.g., iterators for vector, deque, string)  For each of the five iterator categories, C++ has a \u0026ldquo;tag struct\u0026rdquo; in the standard library that serves to identify it:\n1 2 3 4 5  struct input_iterator_tag {}; struct output_iterator_tag {}; struct forward_iterator_tag: public input_iterator_tag {}; struct bidirectional_iterator_tag: public forward_iterator_tag {}; struct random_access_iterator_tag: public bidirectional_iterator_tag {};   Pseudocode for advance Knowing that different categories support different operations, advance will essentially be implemented like this:\n1 2 3 4 5 6 7 8 9 10 11  template\u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d) { if (iter is a random access iterator) { iter += d; // use iterator arithmetic for random access iters  } else { if (d \u0026gt;= 0) { while (d--) ++iter; } // use iterative calls  else { while (d++) --iter; } // to ++ or -- for other iterator categories  } }   How to determine whether iter is a random access iterator? Here comes the technique of traits, which allow us to get type information during compilation.\nTraits Traits aren\u0026rsquo;t a keyword or a predefined construct in C++, but simply a technique and a convention followed by C++ programmers. It has some requirements, one of which asks that it has to work as well for built-in types as it does for user-defined types. This demand leads to the conclusion that the traits information for a type must be external to the type2.\nFor user-defined types The standard technique is to put the information into a template and one or more specializations of that template. For iterators, the template in the standard library is named iterator_traits3:\n1 2 3 4 5 6 7  // the iterator_category for type IterT is whatever IterT says it is // see item 42 for info on the use of \u0026#34;typedef typename\u0026#34; template\u0026lt;typename IterT\u0026gt; struct iterator_traits { typedef typename IterT::iterator_category iterator_category; ... };   How does iterator_traits work? Since iterator_traits just parrots back a typedef called iterator_category inside the iterator class, it requires that any user-defined iterator type must contain this nested typedef named iterator_category, which identifies the appropriate tag struct. For example, deque iterators belong to random access category, and list\u0026rsquo;s iterators are bidirectional:\n1 2 3 4 5 6 7 8 9 10  template\u0026lt;...\u0026gt; class deque { public: class iterator { public: typedef random_access_iterator_tag iterator_category; ... }; ... };   1 2 3 4 5 6 7 8 9 10  template\u0026lt;...\u0026gt; class list { public: class iterator { public: typedef bidirectional_iterator_tag iterator_category; ... }; ... };   For pointer types The code above works well for user-defined types, but it doasn\u0026rsquo;t work for iterators that are pointers, since there\u0026rsquo;s no such thing as a nested typedef inside a built-in pointer. To make it work, iterator_traits need to offer a partial template specialization for pointer types:\n1 2 3 4 5 6  template\u0026lt;typename IterT\u0026gt; // partial template specialization struct iterator_traits\u0026lt;IterT*\u0026gt; // for built-in pointer types { typedef random_access_iterator_tag iterator_category; // pointers act as random access iterators  ... }   Workflow for designing and implementing a traits class  Identify some information about types we\u0026rsquo;d like to make available (e.g., iterator category for iterator types) Choose a name to identify that information (e.g., iterator_category) Provide a template and set of specializations (e.g., iterator_traits) that contain the information for the types we want to support  Implementing advance Given std::iterator_traits, we can refine our pseudocode for advance:\n1 2 3 4 5 6 7  template\u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d) { if (typeid(typename std::iterator_traits\u0026lt;IterT\u0026gt;::iterator_category) == typeid(std::random_access_iterator_tag)) ... }   Sadly, this is not what we want: for one thing, it will lead to compilation problems (refer to item 48); anther issue, which is more fundamental, is that if statement is evaluated at runtime but iterator_traits\u0026lt;IterT\u0026gt;::iterator_category can be determined during compilation already. There\u0026rsquo;s no point to move the evaluation from compile-time to runtime to waste time and bloat the executable.\nTemplate metaprogramming What we want is a conditional construct for types that is evaluated during compilation. Actually this demand brings us to the realm of template metaprogramming (item 48), but the technique we\u0026rsquo;ll use turns out to be quit familiar: overloading:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  template\u0026lt;typename IterT, typename DistT\u0026gt; // use this impl for random access iterators void doAdvance(IterT\u0026amp; iter, DistT d, std::random_access_iterator_tag) { iter += d; } template\u0026lt;typename IterT, typename DistT\u0026gt; // use this impl for bidirectional iterators void doAdvance(IterT\u0026amp; iter, DistT d, std::bidirectional_iterator_tag) { if (d \u0026gt;= 0) { while(d--) ++iter; } else { while(d++) --iter; } } template\u0026lt;typename IterT, typename DistT\u0026gt; // use this impl for input iterators, also applies to inherited forward_iterator_tag void doAdvance(IterT\u0026amp; iter, DistT d, std::input_iterator_tag) { if (d \u0026lt; 0) { throw std::out_of_range(\u0026#34;Negative distance\u0026#34;); } while(d--) ++iter; } template\u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d) { doAdvance(iter, d, typename std::iterator_traits\u0026lt;IterT\u0026gt;::iterator_category()); };   Summary How to use a traits class:\n Create a set of overloaded \u0026ldquo;worker\u0026rdquo; functions or function templates (e.g., doAdvance) that differ in a traits parameter. Implement each function in accrod with the traits information passed. Create a \u0026ldquo;master\u0026rdquo; function or function template (e.g., advance) that calls the workers, passing information provided by a traits class.   Input and output iterators, as two least powerful iterator categories, are modeled on the read (into an input file) and write (into an output file) pointer, suitable only for one-pass algorithm. Forward (and higher level iterators) can do multi-pass algoritms. The most powerful random access iterators are modeled on built-in pointers.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n For example, if advance is called with a pointer const char* and an int, since traits technique must apply to built-in types like const char*, and there\u0026rsquo;s no way to nesting information inside pointers, thus the traits information for a type must be external to the type.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n By convention, traits are always implemented as structs, but that structs are called \u0026ldquo;traits classes\u0026rdquo; - not joking.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":144,"section":"notes","tags":["technique","cpp"],"title":"Item-47 Use traits classes for information about types","uri":"https://nianze.ml/en/notes/2018/03/use-traits-classes-for-information-about-types/"},{"content":"When writing a class template that offers functions related to the template that support implicit type conversions on all parameters, define those functions as friends inside the class template.\nIf we want to do implicit type conversion on all arguments, we should use non-member functions (item 24). Now we want a templatized version of Rational class to support the same mixed-mode arithmetic as shown in item 24, and the code could start like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13  template\u0026lt;typename T\u0026gt; class Rational { public: Rational(const T\u0026amp; numerator = 0, // see item 20 for why params are passed by ref  const T\u0026amp; denominator = 1); const T numerator() const; // see item 28 for why return values are passed by value  const T denominator() const; // see item 3 for why return values are const }; template\u0026lt;typename T\u0026gt; const Rational\u0026lt;T\u0026gt; operator*(const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) {...}   However, this simple update to templatized version will not compile for following code:\n1 2  Rational\u0026lt;int\u0026gt; oneHalf(1, 2); Rational\u0026lt;int\u0026gt; result = oneHalf * 2; // error! won\u0026#39;t compile   The problem here is that implicit type conversion functions are never considered during template argument deduction. This means it is impossible for the compilers to convert the second parameter 2 into a Rational\u0026lt;int\u0026gt; using non-explicit constructor, so compilers can\u0026rsquo;t figure out what T is for this function template named operator* taking two parameters of type Rational\u0026lt;T\u0026gt;, can\u0026rsquo;t deduce parameter types for this function templates, and thus can\u0026rsquo;t instantiate the appropriate functions. In the end, the function we want to call fails to be declared, before we could apply implicit type conversions during a later function call.\nSolve the compiling issue How to declare the operator* properly? Notice that class templates don\u0026rsquo;t depend on template argument deduction (this process only applies to function templates), so T is always known at the time the class Rational\u0026lt;T\u0026gt; is instantiated. Combine this knowledge with another fact that a friend declaration in a template class refers to a specific function (not a function template), so as part of the class instantiation process, the friend function will be automatically declared. Taking advantage of these 2 points, we could update the code to a new version1:\n1 2 3 4 5 6 7 8  template\u0026lt;typename T\u0026gt; class Rational { public: ... friend // declare operator* function  const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs); };   1 2 3 4  template\u0026lt;typename T\u0026gt; // define operator* function const Rational\u0026lt;T\u0026gt; operator*(const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) {...}   When the oneHalf is declared to be of type Rational\u0026lt;int\u0026gt;, the class Rational\u0026lt;int\u0026gt; is instantiated, and the friend function operator* that takes Rational\u0026lt;int\u0026gt; parameters is then declared automatically. As a declared function, compilers can use implicit conversion functions (such as Rational\u0026rsquo;s non-explicit constructor) when calling it, making the mixed-mode call compile.\nSolve the linking issue Yes, the code compiles. Yet it won\u0026rsquo;t link.\nThis time, the problem is that the target function operator* is only declared inside Rational, not defined there. Indeed, the operator* template outside the class is intended to provide that definition, but things don\u0026rsquo;t work this way, and linkers can\u0026rsquo;t find the definition.\nTo solve it, the simplest thing is to put the function body into its declaration:\n1 2 3 4 5 6 7 8 9 10 11 12 13  template\u0026lt;typename T\u0026gt; class Rational { public: ... friend const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); // same impl as item 24  } };   This works as intended: mixed-mode calls to operator* now compiles, link, and run.\nThis design is, in some sense, kind of unconventional, because the use of friendship has nothing to do with a need to access non-public parts of the class. We declared it as friend because it is the only choise we have:\n to make type conversions possible on all arguments, we need a non-member function (item 24) to have the proper function automatically instantiated, we need to declare the function inside the class the only way to declare a non-member function inside a class is to make it a friend  Have the friend call a helper Such functions as operator* defined inside a class are implicitly declared inline (item 30), so we may minimize the impact of such inline declarations by having operator* do nothing but call a helper function defined outside of the class, especially when the function body is complex.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  template\u0026lt;typename T\u0026gt; class Raional; // declare Rational template  template\u0026lt;typename T\u0026gt; // helper template const Rational\u0026lt;T\u0026gt; doMultiply(const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs); template\u0026lt;typename T\u0026gt; class Rational { public: ... friend // have friend call helper  const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { return doMultiply(lhs, rhs); } ... };   Many compilers force us to put all template definitions in header files, so we may need to define doMultiply in the header as well:\n1 2 3 4 5 6 7  template\u0026lt;typename T\u0026gt; const Rational\u0026lt;T\u0026gt; doMultiply(const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) { return Rational\u0026lt;T\u0026gt;(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); }   Here, doMultiply is a template, so it won\u0026rsquo;t support mixed-mode multiplication. The workflow is like this:\n The friend function operator* supports mixed-mode operations and is in charge of necessary type conversions, ending with two Rational objects passed to doMultiply These two objects are feed to an appropriate instantiation of the doMultiply helper template, which then do the actual multiplication   It is worth to know the syntax used to decalre operator* inside Rational. Inside a class template, the name of the template can be used as shorthand for the template and its parameters, so inside Rational\u0026lt;T\u0026gt;, we can write Rational instead of Rational\u0026lt;T\u0026gt;. It will be the same effect if we declare operator* inside Rational\u0026lt;T\u0026gt; like this: friend const Rational\u0026lt;T\u0026gt; operator*(const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":145,"section":"notes","tags":["technique","cpp"],"title":"Item-46 Define non-member function inside templates when type conversions are desired","uri":"https://nianze.ml/en/notes/2018/03/define-non-member-function-inside-templates-when-type-conversions-are-desired/"},{"content":"In order to implicitly convert all compatible types for a template class, we neet not a constructor function but a constructor template - member functoin templates that generate member functions of a class.\nImplicit conversion is a big convenient advantage offered by pointers: derived class pointers convert into base class pointers implicitly, pointers to non-const objects convert into pointers to const implicitly, etc. For a three-level hierarchy, following code makes perfect sense:\n1 2 3 4 5 6  class Top {...}; class Middle: public Top {...}; class Bottom: public Middle {...}; Top *pt1 = new Middle; // convert Middle* -\u0026gt; Top* Top *pt2 = new Bottom; // convert Bottom* -\u0026gt; Top* const Top *pct = pt1; // convert Top* -\u0026gt; const Top*   In the world of template, we\u0026rsquo;d really like to emulate such conversions for our user-defined smart pointer classes:\n1 2 3 4 5 6 7 8 9 10  template\u0026lt;typename T\u0026gt; class SmartPtr { public: explicit SmartPtr(T *realPtr) // initialized by built-in pointers  ... }; SmartPtr\u0026lt;Top\u0026gt; pt1 = SmartPtr\u0026lt;Middle\u0026gt;(new Middle); // convert SmartPtr\u0026lt;Middle\u0026gt; -\u0026gt; SmartPtr\u0026lt;Top\u0026gt; SmartPtr\u0026lt;Top\u0026gt; pt2 = SmartPtr\u0026lt;Bottom\u0026gt;(new Bottom); // convert SmartPtr\u0026lt;Bottom\u0026gt; -\u0026gt; SmartPtr\u0026lt;Top\u0026gt; SmartPtr\u0026lt;const Top\u0026gt; pct = pt1; // convert SmartPtr\u0026lt;Top\u0026gt; -\u0026gt; SmartPtr\u0026lt;const Top\u0026gt;   However, there\u0026rsquo;s no inherent relationship among different instantiations of the same template, so compilers view SmartPtr\u0026lt;Middle\u0026gt; and SmartPtr\u0026lt;Top\u0026gt; as completely different classes. We need to write smart pointer constructors that is not only able to construct SmartPtr\u0026lt;Top\u0026gt; from SmartPtr\u0026lt;Middle\u0026gt;, but also capable to convert any compatible types in the hierarchy (we may extend the hierarchy in the future and add class BelowBottom: public Bottom). In principle, such constructors are countless.\nConsidering the fact that a template can be instantiated to generate an unlimited number of functions, what we need here is not a constructor function, but a constructor template, the member function templates (also known as member templates) that generate member functions of a class:\n1 2 3 4 5 6 7  template\u0026lt;typename T\u0026gt; class SmartPtr { public: template\u0026lt;typename U\u0026gt; // member template for a \u0026#34;generalized copy constructor\u0026#34;  SmartPtr(const SmartPtr\u0026lt;U\u0026gt;\u0026amp; other); // not declared as \u0026#34;explicit\u0026#34; for implicit conversion  ... };   Constructors like this - ones that create one object from anothe object whose type is a different instantiation of the same template (e.g., create a SmartPtr\u0026lt;T\u0026gt; from a SmartPtr\u0026lt;U\u0026gt;) - are known as generalized copy constructors.\nHowever, this member template will generate more member functions than we need: as declared, it is possible to create a SmartPtr\u0026lt;Bottom\u0026gt; from a SmartPtr\u0026lt;Top\u0026gt;, which is contrary to the meaning of public inheritance (item 32). We need to restrict the conversions to those we want:\n1 2 3 4 5 6 7 8 9 10 11  template\u0026lt;typename T\u0026gt; class SmartPtr { public: template\u0026lt;typename U\u0026gt; SmartPtr(const SmartPtr\u0026lt;U\u0026gt;\u0026amp; other) // initialize this held ptr with other\u0026#39;s held ptr  : heldPtr(other.get()) {...} T* get() const { return heldPtr; } ... private: T *heldPtr; // built-in ptr held by the smartPtr };   Since we initialize SmartPtr\u0026lt;T\u0026gt;\u0026rsquo;s data member of type T* with the pointer of type U* held by SmartPtr\u0026lt;U\u0026gt;, the code above will compile only if there is an implicit conversion from a U* pointer to a T* pointer, and this is exactly what we want.\nApart from constructors, we can also apply member function tmeplates to assignment. A good example is from TR1\u0026rsquo;s shared_ptr (item 13):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  template\u0026lt;class T\u0026gt; class shared_ptr { public: shared_ptr(shared_ptr const\u0026amp; r); // \u0026#34;normal\u0026#34; copy constructor  template\u0026lt;class Y\u0026gt; explicit shared_ptr(Y * p); // generalized copy constructor from any compatible built-in pointer  template\u0026lt;class Y\u0026gt; shared_ptr(shared_ptr\u0026lt;Y\u0026gt; const\u0026amp; r); // from compatible shared_ptr  template\u0026lt;class Y\u0026gt; explicit shared_ptr(weak_ptr\u0026lt;Y\u0026gt; const\u0026amp; r); // from compatible weak_ptr  template\u0026lt;class Y\u0026gt; explicit shared_ptr(auto_ptr\u0026lt;Y\u0026gt;\u0026amp; r); // from compatible auto_ptr  shared_ptr\u0026amp; operator=(shared_ptr const\u0026amp; r); // \u0026#34;normal\u0026#34; copy assignment  template\u0026lt;class Y\u0026gt; shared_ptr\u0026amp; operator=(shared_ptr\u0026lt;Y\u0026gt; const\u0026amp; r); // generalized copy assign from any compatible shared_ptr  template\u0026lt;class Y\u0026gt; shared_ptr\u0026amp; operator=(auto_ptr\u0026lt;Y\u0026gt;\u0026amp; r); // assign from any compatible auto_ptr  ... };   Note that\n the generalized copy constructor is not declared explicit in order to support implicit conversion from one type of shared_ptr to another. All other constructors are explicit, so implicit conversion from a built-in pointer or other smart pointer type is not permitted (explicit conversion via a cast is okey). auto_ptr passed to tr1::shared_ptr constructors and assignment operators are not declared const, because auto_ptr will be modifies when they\u0026rsquo;re copyed (item 13). both a generalized copy constructor (and assignment) as well as the \u0026ldquo;normal\u0026rdquo; copy constructor (and copy assignment) are declared, because declaring a generalized copy constructor (a member template) in a class doesn\u0026rsquo;t keep compilers from generating their own copy constructor (a non-template version), so if we want to control all aspect of copy construction, we declare both. ","description":"","id":146,"section":"notes","tags":["technique","cpp"],"title":"Item-45 Use member function templates to accept all compatible types","uri":"https://nianze.ml/en/notes/2018/03/use-member-function-templates-to-accept-all-compatible-types/"},{"content":"Templates generate multiple classes and multiple functions, so any template code not dependent on a template parameter (either non-type template parameters or type parameters) causes bloat: eliminate bloat due to non-type template parameters by replacing template parameters with function parameters or class data members; reduce bloat caused from type parameters by sharing implementations for instantiation types with identical binary representations.\nWhen writing templates, since there\u0026rsquo;s only one copy of the template source code, we have to analyze it carefully to avoid the implicit replication that may take place when a template is instantiated multiple times.\nBloat due to non-type template parameters For example, suppose we\u0026rsquo;d like to write a template for fixed-size square matrices that support matrix inversion:\n1 2 3 4 5 6  template\u0026lt;typename T, std::size_t n\u0026gt; // template for n*n matrices of obejcts of type T class SquareMatrix{ pubic: void invert(); // invert the matrix in place  ... };   This template takes a type parameter T as well as a non-type parameter n of type size_t. This example is actually a classic way for template-induced code bloat:\n1 2 3 4  SquareMatrix\u0026lt;double, 5\u0026gt; sm1; sm1.invert(); // call SquareMatrix\u0026lt;double, 5\u0026gt;::invert SquareMatrix\u0026lt;double, 10\u0026gt; sm2; sm2.invert(); // call SquareMatrix\u0026lt;double, 10\u0026gt;::invert   In the statements above, two copies of invert will be instantiated, and these two version of invert are character-for-character identical except for the use of 5 in one version and 10 in the other. To reduce the code bloat, we could redesign and call a parameterized function instead.\nReplace with function parameters 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  template\u0026lt;typename T\u0026gt; // size-independent base class for square matrices class SquareMatrixBase{ // all matrices holding a givin type of object will share a single base class with a single copy of this base class\u0026#39;s version of invert protected: // intend only to be a way for derived classes to avoid code replication, so declared as protected instaend of public  void invert(std::size_t matrixSize); // invert matrix of the given size  ... }; template\u0026lt;typename T, std::size_t n\u0026gt; class SqureMatrix: private SquareMatrixBase\u0026lt;T\u0026gt; { // not a is-a relationship, using private inheritance only for base class implementation, item 39 private: using SquareMatrixBase\u0026lt;T\u0026gt;::invert; // avoid hiding base version of invert, item 33 public: ... // make inline call to base class version of invert:  void invert() { this-\u0026gt;invert(n); } // 1. it\u0026#39;s implicit inline, so there\u0026#39;s no addictional cost of calling it, item 30  ... // 2. use \u0026#34;this-\u0026gt;\u0026#34; so that function names in templatized base classes are revealed in derived classes, item 43 };   This design addressed the issue of code bloat, but it also introduces a problem: SquareMatrixBase::invert only knows the size of the data, but it does not know where the data for a particular matrix is, because only the derived class knows that. We could add another parameter to SquareMatrixBase::invert, such as a pointer to the beginning of a chunk of memory that stores the matrix\u0026rsquo;s data.\nHowever, an alternative and possibly better solution will be to have SquareMatrixBase store both a pointer to the memory for the matrix values, as well as the matrix size, so that any other functions asking for the matrix memory address or matrix size can be written in a address-independent-and-size-independent manner, and moved into SquareMatrixBase.\nReplace with class data members 1 2 3 4 5 6 7 8 9 10 11  template\u0026lt;typename T\u0026gt; class SquareMatrixBase { protected: SquareMatrixBase(std::size_t n, T *pMem) // store matrix size and a ptr to matrix values  : size(n), pData(pMem) {} void setDataPtr(T *ptr) { pData = ptr; } // reassign pData  ... private: std::size_t size; // size of matrix  T *pData; // pointer to matrix values };   1 2 3 4 5 6 7 8 9  template\u0026lt;typename T, std::size_t n\u0026gt; class SquareMatrix: private SqureMatrixBase\u0026lt;T\u0026gt; { public: SquareMatrix() // send matrix size and data ptr to base class  : SquareMatrixBase\u0026lt;T\u0026gt;(n, data) {} ... private: T data[n*n]; };   Objects of such type have no need for dynamic memory allocation, but the objects could be very large. An alternative would be to put the data for each matrix on the heap:\n1 2 3 4 5 6 7 8 9 10 11  template\u0026lt;typename T, std::size_t n\u0026gt; class SquareMatrix: private SqureMatrixBase\u0026lt;T\u0026gt; { public: SquareMatrix() : SquareMatrixBase\u0026lt;T\u0026gt;(n, 0), // set base class ptr to null  pData(new T[n*n]) // allocate memory for matrix values and save a ptr to the memory  { this-\u0026gt;setDataPtr(pData.get()); } // give a copy of the ptr to the base class  ... private: boost::scoped_array\u0026lt;T\u0026gt; pData; // see item 13 for info on boost::scoped_array };   No matter where the matrix value data is stored, the result from a bloat point of view is that many SquareMatrix\u0026rsquo;s member functions can be simple inline calls to base class versions that are shared with all other matrices holding the same type of data, regardless of their size.\nEfficiency concerns In terms of efficiency, it is possible that the version of invert with the matrix sizes hardwired into them generates better code than the shared version whose size is passed as a function parameter or is stored in the object: in the size-specific versions, the sizes would be compile-time constants, hence eligible for optimizations such as constant propagation (they\u0026rsquo;ll be folded into the generated instructions as imeediate operands), which can\u0026rsquo;t be done in the size-independent version.\nOn the other side, the size-independent version decreases the size of executable by having only one version of invert for multiple matrix sizes, and this could reduce the program\u0026rsquo;s working set size and improve locality of reference in the instruction cache, which may in term compensating for any lost optimizations in size-specific versions of invert. The only way to tell which version is better one is to try them both and observe the behavior on the particular platform and on representative data sets.\nOther trade-offs Speaking of size of objects, we should observe that there\u0026rsquo;s an extra size of a pointer in each SquareMatrix object, because, as the derived class, SquareMatrix could get to the data by alternative designs such as having the base class store a protected pointer to the matrix data. However, this new design also has some disadvantages:\n it may lead to the loss of encapsulation described in item 22 it may also lead to resource management complications: since derived class may either dynamically alloacate the matrix data, or physically store the data inside the derived class object, if we only let the base class store a pointer to that data, it is hard for base class to determine whether the pointer should be deleted or not.  At some point, a little code replication seems like a mercy to keep away from complication.\nBloat due to type parameters On many platforms, int and long have the same binary representation, so the member functions for vector\u0026lt;int\u0026gt; and vector\u0026lt;long\u0026gt; would likely be identical. Some linkers will merge identical function implementations, but some will not, and that means that some templates instantiated on both int and long could cause code bloat in some environments.\nSimilarly, on most platforms, all pointer types have the same binary representation, so templates holding pointer types (e.g., list\u0026lt;int*\u0026gt;, list\u0026lt;const int*\u0026gt;, list\u0026lt;SquareMatrix\u0026lt;long, 3\u0026gt;*\u0026gt;, etc.) should be able to use a single underlying implementation for each member function. Typically, this is achieved by implementing member functions that work with strongly typed pointers (i.e., T* pointers) by having them call functions that work with untyped pointers (i.e., void* pointers), which is how some of standart C++ library do for templates like vector, deque, and list.\n","description":"","id":147,"section":"notes","tags":["technique","cpp"],"title":"Item-44 Factor parameter-independent code out of templates","uri":"https://nianze.ml/en/notes/2018/03/factor-parameter-independent-code-out-of-templates/"},{"content":"In derived class templates, refer to names in base class templates via a this-\u0026gt; prefix, via using declarations, or via an explicit base class qualification.\nCase Study Sometimes when we cross from Object-oriented C++ to Template C++ (item 1), inheritance seem to stop working. For example, we\u0026rsquo;d like to log some information for the sendMsg function in base class MsgSender, so we make following derived class LoggingMsgSender:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  class CompanyA { public: ... void sendClearText(const std::string\u0026amp; msg); ... }; class CompanyB { public: ... void sendClearText(const std::string\u0026amp; msg); ... } class MsgInfo {...}; // class for holding information used to create msg  template\u0026lt;typename Company\u0026gt; class MsgSender { public: ... // ctor, dtor, etc.  void sendClear(const MsgInfo\u0026amp; info) { std::string msg; // create msg from info;  Company c; c.sendClearText(msg); } ... }; template\u0026lt;typename Company\u0026gt; class LoggingMsgSender: public MsgSender\u0026lt;Company\u0026gt; { public: ... // ctor, dtor, etc.  void sendClearMsg(const MsgInfo\u0026amp; info) { // write \u0026#34;before sending\u0026#34; info to the log  sendClear(info); // call base class function -\u0026gt; not compile  // write \u0026#34;after sending\u0026#34; info to the log  } ... };   Note that the message-sending function in the derived class has a different name sendClearMsg from its counterpart sendClear in the base class: this is good design for two reasongs:\n it avoids the issue of hiding inherited names (item 33) it side-steps the problems inherent in redefining an inherited non-virtual function (item 36)  However, the code above will not compile, because, by default, compilers will not look for the function sendClear in the base class. The behavior seems to break our expected inheritance concept from Object-oriented world, but compilers do this for a good reason: they will not know what the base class MsgSender\u0026lt;Company\u0026gt; really looks like until when LoggingMsgSender is instantiated, so it is possible that there\u0026rsquo;s a special template parameter class CompanyC that, instead of providing function sendClearText, only supports sendEncrypted:\n1 2 3 4 5 6  class CompanyZ { // this class offers no sendClearText Fucntion public: ... void sendEncrypted(const std::string\u0026amp; msg); ... };   In this case, sendClear function in MsgSender base class will make no sense. To rectify the problem, we can create a specialized version of MsgSender for CompanyZ:\n1 2 3 4 5  template\u0026lt;\u0026gt; // signifies this is neither a template nor a standalone class class MsgSender\u0026lt;CompanyZ\u0026gt; { // but a total specialization of MsgSender public: ... // the same as the general template, except sendCleartext is omitted };   This syntax is known as a total template specialization: the template MsgSender is specialized for the type CompanyZ, and the specialization is total - once the type parameter has been defined to be CompanyZ, no other aspect of the template\u0026rsquo;s parameters can vary.\nSince base class templates may be specialized and that such specializations may not offer the same interface as the general template, C++ generally refuses to look in templatized base classes for inherited names. That\u0026rsquo;s why we say inheritance stops working in Template C++ wolrd.\nTo force C++ to look in templatized base classes, there are three ways:\n1. Call with \u0026ldquo;this-\u0026gt;\u0026rdquo; 1 2 3 4 5 6 7 8 9 10 11 12  template\u0026lt;typename Company\u0026gt; class LoggingMsgSender: public MsgSender\u0026lt;Company\u0026gt; { public: ... // ctor, dtor, etc.  void sendClearMsg(const MsgInfo\u0026amp; info) { // write \u0026#34;before sending\u0026#34; info to the log  this-\u0026gt;sendClear(info); // assumes that sendClear will be inherited  // write \u0026#34;after sending\u0026#34; info to the log  } ... };   2. Employ a \u0026ldquo;using\u0026rdquo; declaration This is the same trick we use in item 33, which explains how using declaration brings hidden base class names into a derived class\u0026rsquo;s scope1:\n1 2 3 4 5 6 7 8 9 10 11 12 13  template\u0026lt;typename Company\u0026gt; class LoggingMsgSender: public MsgSender\u0026lt;Company\u0026gt; { public: using MsgSender\u0026lt;Company\u0026gt;::sendClear; // tell compilers to assume that sendClear is in the base class  ... // ctor, dtor, etc.  void sendClearMsg(const MsgInfo\u0026amp; info) { // write \u0026#34;before sending\u0026#34; info to the log  sendClear(info); // assumes that sendClear will be inherited  // write \u0026#34;after sending\u0026#34; info to the log  } ... };   3. Explicitly specify the base class qualification 1 2 3 4 5 6 7 8 9 10 11 12  template\u0026lt;typename Company\u0026gt; class LoggingMsgSender: public MsgSender\u0026lt;Company\u0026gt; { public: ... // ctor, dtor, etc.  void sendClearMsg(const MsgInfo\u0026amp; info) { // write \u0026#34;before sending\u0026#34; info to the log  MsgSender\u0026lt;Company\u0026gt;::sendClear(info); // assumes that sendClear will be inherited  // write \u0026#34;after sending\u0026#34; info to the log  } ... };   This approach is less desirable, because if the function being called is virtual, explicit qualification turns off the virtual binding behavior.\nSummary From a name visibility point of view, each of these approaches does the same thing: it promises compilers that any subsequent specializations of the base class template will support the interface offered by the general template. However, if the promise turns out to be unfounded, the subsequent compilation will still diagnose invalid references to base class members and reveal the truth:\n1 2 3 4 5 6  LoggingMsgSender\u0026lt;CompanyZ\u0026gt; zMsgSender; MsgInfo msgData; ... // put info in msgData zMsgSender.sendClearMsg(msgData); // error! won\u0026#39;t compile. Compilers know the base class MsgSender\u0026lt;CompanyZ\u0026gt;  // doesn\u0026#39;t offer the sendClear function for this template specilization    Fundamentally, compilers will diagnose invalid references to base class members sooner (when derived class template definitions are parsed) or later (when templates are instantiated with specific template arguments). C++\u0026rsquo;s policy is to prefer early diagnoses, and that\u0026rsquo;s why it assumes it knows nothing about the contents of base classes when those classes are instantiated from templates.\n  Note that there\u0026rsquo;s difference between the problem solved in this item from that in item 33: here, the problem is that compilers don\u0026rsquo;t search base class scopes unless we explicitly specify it; in item 33, it is due to the derived class names that hide base class names.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":148,"section":"notes","tags":["technique","cpp"],"title":"Item-43 Know how to access names in templatized base classes","uri":"https://nianze.ml/en/notes/2018/03/know-how-to-access-names-in-templatized-base-classes/"},{"content":"When declaring template parameters, both class and typename are interchangeable. When identifying nested dependent type names, use typename, except in base class lists or as a base class identifier in a member initialization list.\nIn template parameter declaration In the template declarations such as below:\n1 2  template\u0026lt;class T\u0026gt; class Widget; // uses \u0026#34;class\u0026#34; template\u0026lt;typename T\u0026gt; class Widget; // uses \u0026#34;typename\u0026#34;   There\u0026rsquo;s no difference between these two declarations, though using typename may be helpful to imply that the parameter need not be a class type. From C++\u0026rsquo;s point of view, class and typename means exactly the same in this case.\nNested dependent type Names in a template that are dependent on a template parameter are called dependent names. When a dependent name is nested inside a class, we can call it a nested dependent name. For example, considering following code, which actually won\u0026rsquo;t compile due to the lack of typename:\n1 2 3 4 5 6 7 8 9 10  template\u0026lt;typename C\u0026gt; // print 2nd element in container void print2nd(const C\u0026amp; container) { if (container.size() \u0026gt;= 2){ C::const_iterator iter(container.begin()); // get iterator to 1st element  ++iter; // move iter to 2nd element  int value = *iter; // copy the 2nd element to an int  std::cout \u0026lt;\u0026lt; value; // print the int  } }   In this example, C::const_iterator is not only a dependent name on the template parameter C, but also a nested dependent name, or more specifically, a nested dependent type name (a nested dependent name that refers to a type). As a comparason, local variable value is of type int, independent of any template parameter, which is known as non-dependent name.\nThe reason why the code above doesn\u0026rsquo;t compile is that, without typename, it is difficult to parse those nested dependent names. For example, if we make following declaration:\n1 2 3 4 5 6  template\u0026lt;typename C\u0026gt; void print2nd(const C\u0026amp; container) { C::const_iterator * x; ... }   There are multiple possible ways to interprete this statement:\n We assume C::const_iterator is a type, thus we\u0026rsquo;re declaring x as a local variable that\u0026rsquo;s a pointer to a C::const_iterator We assume C has a static member that happens to be named const_iterator, and x happens to be the name of a global variable, so this statement is a multiplication of C::const_iterator by x  To resolve this ambiguity, C++ rules that the parser should not assume a nested dependent name in a template as a type, unless we explicitly specify it through typename keyword. Thus, the valid code for the above example should be like this:\n1 2 3 4 5 6 7 8  template\u0026lt;typename C\u0026gt; // print 2nd element in container void print2nd(const C\u0026amp; container) { if (container.size() \u0026gt;= 2){ typename C::const_iterator iter(container.begin()); // get iterator to 1st element  ... } }   Real world usecase In real code, it\u0026rsquo;s representative that sometimes typename shows with another keyword typedef to save some typing time:\n1 2 3 4 5 6  template\u0026lt;typename IterT\u0026gt; void workWithIterator(IterT iter) { typedef typename std::iterator_traits\u0026lt;IterT\u0026gt;::value_type value_type; value_type temp(*iter); }   Basically, this statement is to declare a local variable temp of the same type as what IterT objects point to, and it initializes temp with the object that iter points to. Here, the standard traits class (item 47) is to represent the type of thing pointed to by objects of type IterT. For example, if IterT is list\u0026lt;string\u0026gt;::iterator, then temp is of type string. Since value_type is nested inside iterator_traits\u0026lt;IterT\u0026gt;, and IterT is a template parameter, we must precede it by typename.\nIt is also worth noting that typename should be used to identify only nested dependent type names; other names shouldn\u0026rsquo;t have it:\n1 2 3  template\u0026lt;typename C\u0026gt; // typename allowed (class also allowed): template parameter declaration void f(const C\u0026amp; container, // typename not allowed: C is not a nested dependent type name  typename C::iterator iter); // typename required: iter is a nested dependent type name   In summary, the general rule is: anytime we refer to a nested dependent type name in a template, we must immediately precede it by the word typename, except for the following two cases:\nException There are two exception cases where typename must not precede nested dependent type names:\n in a list of base classes as a base class idenfifier in a member initialization list  For example:\n1 2 3 4 5 6 7 8 9 10 11  template\u0026lt;typename T\u0026gt; class Derived: public Base\u0026lt;T\u0026gt;::Nested{ // case 1 - base class list: typename not allowd public: explicit Derived(int x) : Base\u0026lt;T\u0026gt;::Nested(x) // case 2 - base class identifier in mem init. list: typename not allowd  { typename Base\u0026lt;T\u0026gt;::Nested temp; // typename required: nested dependent type not in the two exception cases  ... } ... };    P.S.: Actually, enforcement of the rules surrounding typename vary from compiler to compiler. Some compilers accept code where typename is required but missing; some accept code where typename is present but not allowd. This means the interaction of typename and nested dependent type names can lead to some portability headaches.\n","description":"","id":149,"section":"notes","tags":["technique","cpp"],"title":"Item-42 Understand the two meanings of typename","uri":"https://nianze.ml/en/notes/2018/03/understand-the-two-meanings-of-typename/"},{"content":"Classes support explicit interfaces based on function signatures, as well as runtime polymorphism through virtual functions; templates support implicit interfaces based on valid expressions, as well as compile-time polymorphism through template instantiation and function overloading resolution.\nInterface and Polymorphism in OOP The world of object-oriented programming revolves around explicit interfaces and runtime polymorphism. For example:\n1 2 3 4 5 6 7 8 9 10  class Widget { public: Widget(); virtual ~Widget(); virtual std::size_t size() const; virtual void normalize(); void swap(Widget\u0026amp; other); // see item 25  ... };   1 2 3 4 5 6 7 8  void doProcessing(Widget\u0026amp; w) { if (w.size() \u0026gt; 10 \u0026amp;\u0026amp; w != someNastyWidget){ Widget temp(w); temp.normalize(); temp.swap(w); } }   Regarding the w in doProcessing, we could conclude:\n explicit interface: w is of type Widget, so it must support the Widget interface, which is an explicit interface, because it is explicitly visible in the source code (e.g., the .h file for Widget) runtime polymorphism: w\u0026rsquo;s call to some of its virtual member functions exhibits runtime polymorphism, because the specific function to call will be determined at runtime based on w\u0026rsquo;s dynamic type (item 37)  Specifically, the explicit interface of Widget consists of its function signatures: a constructor, a destructor, and the functions size, normalize, and swap, along with the parameter types, return types, and constnesses of these functions, as well as compilter-generated copy constructor and copy assignment operator (item 5). Potentially, it could also include typedefs, and data members.\nInterface and Polymorphism in templates and generic programming In the world of templates and generic programming, the explicit interfaces and runtime polymorphism continue to exist, but we also have to consider implicit interfaces and compile-time polymorphism. As a comparison, let\u0026rsquo;s take a look at the template version of doProcessing:\n1 2 3 4 5 6 7 8 9  template\u0026lt;typename T\u0026gt; void doProcessing(T\u0026amp; w) { if (w.size() \u0026gt; 10 \u0026amp;\u0026amp; w != someNasyWidget) { T temp(w); temp.normalize(); temp.swap(w); } }   For w in the template doProcessing:\n implicit interface: w must support all the operations performed on it, but there is no explicit function signatures to follow. Rather, there\u0026rsquo;s an implicit interface consists of valid expressions that set constraints on w. compile-time polymorphism: w is one of the parameters in operator\u0026gt; and operator!=, which may involve instantiating function templates with different template parameters, leading to different functions being called during compilation. This is similar to the process to determine which of a set of overloaded functions should be called during compilation.  Specifically, let\u0026rsquo;s take a look those constrains on w\u0026rsquo;s type T in the implicit interface:\n whatever w.size() \u0026gt; 10 \u0026amp;\u0026amp; w != someNasyWidget yields, the expression as a whole must be compatible with bool calls to the copy constructor, to normalize, and to swap must be valid for objects of type T  However, inside the expression w.size() \u0026gt; 10 \u0026amp;\u0026amp; w != someNasyWidget, constraints on compatibal type regarding the functions size, operator\u0026gt;, operator\u0026amp;\u0026amp;, or operator!= are pretty flexible, thanks to the possibility of operator overloading and implicit conversion:\n there\u0026rsquo;s no requirement that size returns an integral value - it may simply return an object of some type X such that there is an operator\u0026gt; that can be called with an object of type X and an int (10 is of type int) there\u0026rsquo;s no requirement that operator\u0026gt; take a parameter of type X - it may take a parameter of type Y, as long as there were an implicit conversion from objects of type X to objects of type Y there\u0026rsquo;s no requirement that T support operator!= - it would be just as acceptable for operator!= to take one object of type X and one object of type Y, as long as T can be converted to X and someNastyWidget\u0026rsquo;s type can be converted to Y potentially, even operator\u0026amp;\u0026amp; could be overloaded, changing the meaning of the above expression from a conjunction to something quite different  Anyway, the implicit interfaces imposed on a template\u0026rsquo;s parameters are just as real as the explicit interfaces imposed on a class\u0026rsquo;s objects, and both are checked during compilation.\n","description":"","id":150,"section":"notes","tags":["technique","cpp"],"title":"Item-41 Understand inplicit interfaces and compile time polymorphism","uri":"https://nianze.ml/en/notes/2018/03/understand-inplicit-interfaces-and-compile-time-polymorphism/"},{"content":"Being more complex than single inheritance, Multiple inheritance (MI) can lead to ambiguity issues and to the need for virtual inheritance, the latter of which imposes costs in size, speed, and complexity of initialization and assignment, so it\u0026rsquo;s more practical to make \u0026ldquo;empty\u0026rdquo; virtual base classes.\nAmbiguity In the realm of MI, one thing worth noting is that it becomes possible to inherit the same name (e.g., function, typedef, etc.) from more than one base class:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class BorrowableItem { // something a library lets you borrow public: void checkOut(); // check the item out from the library  ... }; class ElectronicGadget { private: bool checkOut() const; // perfom self-test, return whether test succeeds  ... }; class MP3Player: // Multiple inheritance  public BorrowableItem, public ElectronicGadget {...};   1 2  MP3Player mp; mp.checkOut(); // ambiguous!   In the example above, even though only the public one in BorrowableItem of the two checkOut functions is accessible, the call to checkOut is ambiguous, because before seeing whether a function is accessible, C++ first identifies the function that\u0026rsquo;s the best match for the call, and in this case both checkOuts are equally good matches, so there\u0026rsquo;s no best match. The accessibility of ElectronicGadget::checkOut is never examined.\nTo resolve the ambiguity, specify which base class\u0026rsquo;s function to call:\n1  mp.BorrowableItem::checkOut();   Virtual inheritance It is not uncommon in the world of MI to encounter the classical case of \u0026ldquo;deadly MI diamond\u0026rdquo;, where there are more than one path between a base class and a derived class:\n1 2 3 4 5 6  class File {...}; class InputFile: public File{...}; class OutputFile: public File{...}; class IOFile: public InputFile, public OutputFile {...};    File ↗ ↖ InputFile OutputFile ↖ ↗ IOFile Here, between File and IOFile, we\u0026rsquo;ve found two paths either through InputFile or OutputFile, and we come to the following question:\n Do we want the data members in the base class to be replicated for each of the paths?\n By default, C++ performs the replication, so if there\u0026rsquo;s a data member named fileName in the File, IOFile will inherits a copy from each of its base classes InputFile and OutputFile, resulting in two fielName data members in IOFile.\nIf this is not what we want, we must make the File a virtual base class:\n1 2 3 4 5 6  class File {...}; class InputFile: virtual public File{...}; class OutputFile: virtual public File{...}; class IOFile: public InputFile, public OutputFile {...};    File (virtual)↗ ↖(virtual) InputFile OutputFile ↖ ↗ IOFile From the viewpoint of correct behavior, public inheritance should always be virtual. However, inheritance costs both in terms of memory and runtime: compared to their counterparts without virtual inheritance, objects created from clases using virtual inheritance are generally larger, and access to data members in virtual base classes is also slower.\nTo make things more complicated, it is required that the responsibility for initializing a virtual base is borne by the most derived class in the hierarchy, which implies:\n classes derived from virtual bases that requires initialization must be awared of their virtual bases when a new derived class is added to the hierarchy, it must assume initialization responsibilities for its virtual bases (both direct and indirect).  To make things easier to handle, we could adopt following strategy:\n Use non-virtual by default, and don\u0026rsquo;t use virtual bases unless we need to If we must use a virtual base classes, avoid putting data in them1  Example of legitimate MI usecase Multiple inheritance does have legitimate uses. One scenario involves combining public inheritance from an Interface class with private inheritance from a class that provides help of implementation.\nFor example, we want to implement the following C++ Interface class (from item 31) to model persons:\n1 2 3 4 5 6 7  class IPerson { public: virtual: ~IPerson(); virtual std::string name() const = 0; virtual std::string birthDate() const = 0; };   We want to create a concrete class CPerson, and luckily, we find following old database-specific class PersonInfo offering the essense of what CPerson needs:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  class PersonInfo { public: explicit PersonInfo(DatabaseID pid); virtual ~PersonInfo(); virtual const char * theName() const; virtual const char * theBirthDate() const; ... private: virtual const char * valueDelimOpen() const; virtual const char * valueDelimClose() const; ... }; const char * PersonInfo::valueDilimOpen() const { return \u0026#34;[\u0026#34;; // default opening delimiter } const char * PersonInfo::valueDilimClose() const { return \u0026#34;]\u0026#34;; // default closing delimiter } const char * PersonInfo::theName() const { // reserve buffer for return value,  // it\u0026#39;s automatically init. to all zeros due to static  static char value[Max_Formatted_Field_Value_Length]; // write opening delimiter  std::strcpy(value, valueDelimOpen()); append this obj.\u0026#39;s name fields to the string in value // write closing delimiter  std::strcat(value, valueDelimClose()); return value; }   This design of PersonInfo::theName is antiquated indeed: it use a fix-size static buffer, which is rife for both overrun and threading problems (item 21). Let\u0026rsquo;s set such imperfection aside, and focus on theName, which calls virtual function valueDelimOpen and valueDelimClose, so the result returnd by theName is dependent not only on PersonInfo but also on the classes derived from PersonInfo.\nApparently, the relationship between CPerson and PersonInfo is is-implemented-in-terms-of (we just want to re-use some of the code. That\u0026rsquo;s all). Also, suppose that we want our target class CPerson to return unadorned values (return \u0026ldquo;Name\u0026rdquo; instead of \u0026ldquo;[Name]\u0026quot;), which requires redefining of the virtual functions in PersonInfo. Thus between the composition (item 38) and private inheritance (item 39) we prefer private inheritance, because simple composition will not let us redefine the virtual functions in PersonInfo2.\nThus, we could make following reasonable multiple inheritance:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class IPerson {...}; // the interface. same as above  class DatabaseID {...}; // used below  class PersonInfo {...}; // used for implementing the IPerson interface  class CPerson: public IPerson, private PersonInfo { public: explicit CPerson(DatabaseID pid()): PersonInfo(pid) {} virtual std::string name() const { return PersonInfo::theName(); } // implementing the IPerson member function  virtual std::string birthDate() const { return PersonInfo::theBirthDate(); } // implementing the IPerson member function private: const char * valueDelimOpen() const { return \u0026#34;\u0026#34;; } // inherited virtual delimiter functions  const char * valueDelimClose() const { return \u0026#34;\u0026#34;; } // inherited virtual delimiter functions };   In UML, the design looks like this:\n IPerson PersonInfo ↖ ↗(private) IOFile Summary Compared to single inheritance (SI), multiple inheritance (MI) is typically more complicated to use and more complicated to understand, so if SI design is more or less equivalent to an MI design, we prefer the SI design. Sometimes, though, MI is the clearest, most maintainable, most reasonable way to get the job done. When that\u0026rsquo;s the case, just use it, with judiciousness.\n Without any standalone data, we don\u0026rsquo;t worry about oddities in the initialization and assignment rules for the virtual bases. This is exactly why the Interfaces in Java and .NET, which are in many ways comparable to virtual base classes in C++, are not allowed to contain any data.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Complex composition that is combined with public inheritance, as showed in item 39, may also meed our needs, but here we just use private inheritance because it\u0026rsquo;s easy to understand.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":151,"section":"notes","tags":["technique","cpp"],"title":"Item-40 Use multiple inheritance judiciously","uri":"https://nianze.ml/en/notes/2018/03/use-multiple-inheritance-judiciously/"},{"content":"Private inheritance means is-implemented-in-terms-of. It is usually inferior to composition, but it makes sense when a derived class needs access to protected base members or needs to redefine inherited virtual functions. For library developers who strive to minimize object sizes, it also offers the ability of empty base optimization.\nThe behavior of private inheritance is that\n Compilers will generally not convert a derived class object into a base class object members inherited from a private base class (protected or public ones) become private members of the derived class  With such behaviors, private inheritance means is-implemented-in-terms-of. Thus, private-inherited derived class D has no conceptual relationship with the base class B - private inheritance is purely an implementation technique in the implementation domain. Using the terms introduced in item 34:\n private inheritance means to ignore interface, and only inherit implementation.\n Compared to the composition, which also has the meaning of \u0026ldquo;is-implemented-in-terms-of\u0026rdquo;, the preference is simple:\n use composition whenever we can, and use private inheritance whenever we must.\n When must we?\n Primarily when we need to inherit protected members and/or virtual functions Sometimes when we want to take advance of empty base optimization (which is the edge case)  Typical usage Let\u0026rsquo;s see a typical usecase for private inheritance. Suppose we want to periodically examine the the internal status of class Widget, and we\u0026rsquo;d like to reuse the following utility class:\n1 2 3 4 5 6  class Timer { public: explicit Timer(int tickFrequency); virtual void onTick() const; // automatically called for each tick  ... };   A Timer object can be configured to tick with whatever frequency we need, and on each tick, it calls a virtual function, which we can redefine so that it examines the current state of the Widget object. In order to redefine a virtual function, Widget must inherit from Timer. But public inheritance is inappropriate in this case: it\u0026rsquo;s not true that a Widget is-a Timer, because Widget clients should not be able to call onTick on a Widget1.\nPublic inheritance is not a valid option here. Instead, we inherit privately:\n1 2 3 4  class Widget: private Timer { private: virtual void onTick() const; // look at Widget usage data, etc. };   After private inheritance, Timer\u0026rsquo;s public onTick function becomes private in Widget, so keep it as private when we redeclare it2.\nAlternatives This is a nice design, but it\u0026rsquo;s worth noting that private inheritance isn\u0026rsquo;t strictly necessary - we could use composition instead:\n1 2 3 4 5 6 7 8 9 10  class Widget { private: class WidgetTimer: public Timer { public: virtual void onTick() const; ... }; WidgetTimer timer; ... };   This design is more complicated involving both (public) inheritance and composition, but we do get two more advantages from its complixity:\n Because Widget\u0026rsquo;s derived classes have no access to the private WidgetTimer data member, we prevent derived classes from redefining onTick3. We\u0026rsquo;ve minimized Widget\u0026rsquo;s compilation dependencies: if Widget inherits from Timer, Timer\u0026rsquo;s definition must be available when Widget is compiled, so we probably has to #include Timer.h. If WidgetTimer is moved out of Widget and Widget only contains a pointer to a WidgetTimer, we only need to simply forward decalare the WidgetTimer class without #include anything. Such decouplings can be important for large systems (details in item 31).  Edge case The edge case, as the name suggests, is edgy indeed: it applies only when we\u0026rsquo;re dealing with a class that has no data in it: no non-static data members; no virtual functions (which introduces vptr to each object, item 7); and no virual base classes (which also incurs a size overhead, item 40). Conceptually, such an empty class should use no space, but C++ requires that freestanding objects must have non-zero size for some technical reasons. That being said,\n1 2 3 4 5 6 7  class Empty {}; // has no data, so obj. should use no memory  class HoldsAnInt { private: int x; Empty e; // should use no memory };   We\u0026rsquo;ll find that sizeof(HoldsAnInt) \u0026gt; sizeof(int), so Empty data member does require extra memory. With most compilers, sizeof(Empty) is 1, which is a silently inserted char inside the Empty objects to satisfy C++\u0026rsquo;s requirements. However, alignment requirements (see item 50) may casue compilers to add padding to HoldsAnInt classes, so the objects of HoldsAnInt may gain more than just the size of a char - they would actually enlarge enough to hold a second int.\nNow comes the point of using private inheritance: rather than containing \u0026ldquo;freestanding\u0026rdquo; objects that can not have zero size, we could inherit from Empty type:\n1 2 3 4  class HoldsAnInt: private Empty { private: int x; };   Now sizeof(HoldsAnInt) == sizeof(int), thanks to empty base optimization (EBO), which is typically supported by most compilersp4.\nIn practice, \u0026ldquo;empty\u0026rdquo; base classes often contain typedefs, enums, static data members, or non-virtual functions, such as those in the STL that contains useful members (usually typedefs), and thus classes for user-defined function objects may inherit from them without worrying about size increase thanks to EBO.\nIn summary Private inheritance is most likely to be a legitimate design strategy when we\u0026rsquo;re dealing with two classes not related by is-a where one either needs access to the protected members of another or needs to redefine one or more of its virtual functions. Even in this case, however, a mixture of public inheritance and composition can often yield the expected behavior, albeit with more design complexity.\nMost classes aren\u0026rsquo;t empty, so the EBO is rarely a legitimate justification for private inheritance.\nUsing private inheritance judiciously means employing it when, having considered all the alternatives, it\u0026rsquo;s the best way to express the relationship between two classes.\n Allowing adding onTick into the conceptual Widget interface would make it easy for clients to use the Widget interface incorrectly, a clear violation of item 18\u0026rsquo;s advice to make interfaces easy to use correctly and hard to use incorrectly.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Putting onTick in the public side will not change its accessibility, only to mislead clients into thinking they could call it, and this, again, violates item 18\u0026rsquo;s advice.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n If Widget inherits directly from Timer, Widget\u0026rsquo;s derived classes may redefine onTick even if onTick is private (recall item 35 that derived classes may redefine virtual functions even if they are not permitted to call them). By the way, Java or C# would not have such trouble due to their keyword final or sealed.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n It is worth knowing that the EBO is generally viable only under insgle inheritance, and can\u0026rsquo;t be applied to derived classes taht have more than one base.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":152,"section":"notes","tags":["technique","cpp"],"title":"Item-39 Use private inheritance judiciously","uri":"https://nianze.ml/en/notes/2018/03/use-private-inheritance-judiciously/"},{"content":"In the application domain, composition means has-a. In the implementation domain, it means is-implemented-in-terms-of.\nComposition is the relationship where objects of one type contain objects of another type. It\u0026rsquo;s also known as layering, containment, aggregation, and embedding. As public inheritance means \u0026ldquo;is-a\u0026rdquo;, there\u0026rsquo;re are two meanings for composition:\n \u0026ldquo;has-a\u0026rdquo; in the application domain (where we model things in the world with objects, such as people, vehicles, video frames, etc.) \u0026ldquo;is-implemented-in-terms-of\u0026rdquo; in the implementation domain (where the objects are purely implementation artifacts, e.g., buffers, mutexes, search trees, etc)  While the has-a relationship is easy enough to understand, the distinction between is-a and is-implemented-in-terms-of is sometimes troublesome. For example, suppose we\u0026rsquo;d like to (re)use the list template in the standard C++ library to represent fairly small sets of objeccts, i.e., collections without duplicates.\nIn the first glimpse, we may consider the following implementation:\n1 2  template\u0026lt;typename T\u0026gt; // the wrong way to use list for Set class Set: public std::list\u0026lt;T\u0026gt; {...};   As item 32 explains, if D is-a B, everything true of B is also true of D. However, a list object may contains duplicates, but a Set may not contain duplicates. It is thus untrue that a Set is-a list, and public inheritance is the wrong way to model this relationship.\nThe right relationship between the Set and the list should be is-implemented-in-terms-of:\n1 2 3 4 5 6 7 8 9 10  template\u0026lt;typename T\u0026gt; class Set { public: bool member(const T\u0026amp; item) const; void insert(const T\u0026amp; item); void remove(const T\u0026amp; item); std::size_t size() const; private: std::list\u0026lt;T\u0026gt; rep; / representation for Set data };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  template\u0026lt;typename T\u0026gt; bool Set\u0026lt;T\u0026gt;::member(const T\u0026amp; item) const { return std:find(rep.begin(), rep.end(), item) != rep.end(); } template\u0026lt;typename T\u0026gt; void Set\u0026lt;T\u0026gt;::insert(const T\u0026amp; item) { if (!member(item)) rep.push_back(item); } template\u0026lt;typename T\u0026gt; void Set\u0026lt;T\u0026gt;::remove(const T\u0026amp; item) { typename std::list\u0026lt;T\u0026gt;::iterator it = // see item 42 for info on typename  std::find(rep.begin(), rep.end(), item); if (it != rep.end()) rep.erase(it); } template\u0026lt;typename T\u0026gt; std::size_t Set\u0026lt;T\u0026gt;::size() const { return rep.size(); }   As above shows, Set\u0026rsquo;s member functions can lean heavily on functionality already offered by list and other parts of the standard library. Since they are so simple, they make reasonable candidates for inlining (refer to item 30 before confirming doing so).\n","description":"","id":153,"section":"notes","tags":["technique","cpp"],"title":"Item-38 Model 'has-a' or 'is-implemented-in-terms-of' through composition","uri":"https://nianze.ml/en/notes/2018/03/model-has-a-or-is-implemented-in-terms-of-through-composition/"},{"content":"Defaul parameter values are statically bound, while virtual function - the only functions we should be overriding - are dynamically bound.\nAs item 36 suggests, we should never redefine an inherited non-virtual function, so we only need to focus on the case where we inherit a virtual function with a default parameter value.\nTo make things clear, first we need to understand the difference between static and dynamic binding:\n an object\u0026rsquo;s static type is the type we declare it to have in the program text an object\u0026rsquo;s dynamic type is determined by the type of the object to which it currently refers.  For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // a class for geometric shapes class Shape { public: enum ShapeColor {Red, Green, Blue}; // all shapes must offer a function to draw themselves  virtual void draw(ShapeColor color = Red) const = 0; ... }; class Rectangle: public Shape { public: // different default parameter value -\u0026gt; bad  virtual void draw(ShapeColor color = Green) const; ... }; class Circle: public Shape { public: virtual void draw(ShapeColor color) const; ... };   1 2 3  Shape *ps; // static type = Shape*, no dynamic type (no object referred to) Shape *pr = new Rectangle // static type = Shape*, dynamic type = Rectangle* Shape *pc = new Circle; // static type = Shape*, dynamic type = Circle*   Notice that the static type of ps, pr, and pr are all \u0026ldquo;pointer-to-Shape\u0026rdquo;, and that it makes no difference what they\u0026rsquo;re really pointing to.\nDynamic types , as their name suggests, can change as a program runs, typically through assignments:\n1 2  ps = pr; // ps\u0026#39;s dynamic type is now Rectangle* ps = pc; // ps\u0026#39;s dynamic type is now Circle*   Virtual functions are dynamically bound, meaning that the particular function called is determined by the dynamic type of the object through which it\u0026rsquo;s invoked:\n1 2  pc-\u0026gt;draw(Shape::Red); // calls Circle::draw(Shape::Red) pr-\u0026gt;draw(Shape::Red); // calls Rectangle::draw(Shape::Red)   However, since default parameters are statically bound, when calling a virtual function defined in a derived class, it is possible that the default parameter value we are using is from a base class:\n1  pr-\u0026gt;draw(); // calls Rectangle::draw(Shape::Red)   In this case, even though the virtual function is called according to dynamic type Rectangle*, the default parameter value is taken from the Shape class (Shape::Red) rather than the derived Rectangle class (Shape::Green is expected). This result is almost certainly unanticipated.\nThe problem here is that the default parameter value of virtual function draw is redefined in a derived class. This inconsistency between the function call\u0026rsquo;s dynamic binding and the default parameter value\u0026rsquo;s statical binding is mainly due to C++\u0026rsquo;s insistence on runtime efficiency.\nWhen we\u0026rsquo;re having trouble making a virtual function behave the way we\u0026rsquo;d like, it\u0026rsquo;s wise to consider alternative designs, which item 35 happens to offer. One of the alternatives is the non-virtual-interface idiom:\nin order to make clear that the default value for draw\u0026rsquo;s color parameter should always be Red, we could declare a public non-virtual function in the base class calling a private virtual function that derived classes may redefine. According to item 36, such an non-virtual function should never be overridden by derived classes. Thus, simply specify the default parameter in the non-virtual function, and we\u0026rsquo;re done:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Shape { public: enum ShapeColor {Red, Green, Blue}; void draw(ShapeColor color = Red) const // now non-virtual  { doDraw(color); // calls the private virtual  } ... private: virtual void doDraw(ShapeColor color) const = 0; // the actual work is done in this func }; class Rectangle: public Shape { public: ... private: virtual void doDraw(ShapeColor color) const; // note lack of a default param value };   ","description":"","id":154,"section":"notes","tags":["technique","cpp"],"title":"Item-37 Never redefine a function's inherited default parameter value","uri":"https://nianze.ml/en/notes/2018/03/never-redefine-a-functions-inherited-default-parameter-value/"},{"content":"A generalized basic rule from item 7.\nSuppose we have an inheritance hierarchy defined like this:\n1 2 3 4 5 6 7 8 9 10 11  class B { public: void mf(); ... }; class D: public B { public: void mf(); // hide B::mf  ... };   According to item 33, this will lead to following behavior:\n1 2 3 4 5 6  D x; // x is an object of type D B *pB = \u0026amp;x; // get pointer to x D *pD = \u0026amp;x; // get pointer to x  pB-\u0026gt;mf(); // calls B::mf pD-\u0026gt;mf(); // calls D::mf   The reason for this two-faced behavior if that non-virtual functions like B::mf and D::mf are statically bound (item 37), which means that non-virtual functions invoked through pB will always be those defined for class B, even if pB points to an object of a class derived from B. This mismatched behavior exhibits inconsistent behavior, since any given D object may act like either a B or a D (depending on the pointer type) when mf is called.\nOn the other hand, virtual functions are dynamically bound (item 37), so if mf were a virtual function, a call to mf through either pB or pD would result in an invocation of D::mf, because pB and pD really point to is an object of type D.\nWorse than the inconsistent behavior problem in the real world, the example above basically shows a contradiction in class design, theoretically:\n public inheritance means is-a (item 32), so everything that applies to B object also applies to D object a non-virtual function in the base class establishes an invariant over specialization that classes derived from B must inherit both the interface and the implementation (item 34), and mf is such an non-virtual function in B  As long as we redefine the mf, an inherited non-virtual function, one of the conditions above will break, leading to two solutions: either make the mf virtual, or change the class relationship from \u0026lsquo;is-a\u0026rsquo; to something else.\nIn fact, this is exactly the same argument in item 7, which exlains why destructors in polymophic base classes should be virtual. In essence, item 7 is nothing more than a special case of this item.\n","description":"","id":155,"section":"notes","tags":["technique","cpp"],"title":"Item-36 Never redefine an inherited non-virtaul function","uri":"https://nianze.ml/en/notes/2018/03/never-redefine-an-inherited-non-virtaul-function/"},{"content":"Alternatives to virtual functions include the NVI idiom (as an example of the Template Method design pattern) and various forms of the Strategy design pattern.\nSuppose we want to implement a member function named healthValue, which will calculate the health value for different characters in differen ways in a video game. Declaring healthValue virtual seems the obvious way to design things:\n1 2 3 4 5 6 7  class GameCharacter { public: // return character\u0026#39;s health value rating; derived classes may redefine this  // impure virtual suggests there\u0026#39;s a default impl. (item 34)  virtual int healthValue() const; ... };   Actually, except from this obvious design, there exists some alternatives. To name a few:\n Use the non-virtual interface idiom (NVI idiom), a form of the Template Method design pattern that wraps public non-virtual member functions around less accessible virtual functoins Use the Strategy design pattern, specifically:  Replace virtual function with function pointer data members - a stripped-down manifestation of Strategy design pattern Replace virtual function with tr1::function data members, which allows use of any callable entity with a signature compatible with what we need - a more general form of the stripped-down representation of Strategy design pattern Replace virtual functions in one hierarchy with virtual functions in another hierarchy - the conventional implementation of the Strategy design pattern    Let\u0026rsquo;s take a look at the pros and cons of these alternatives.\nThe template method pattern via the non-virtual interface idiom The non-virtual interface (NVI) idiom argues that clients should call private virtual functions indirectly through public non-virtual member functions, which act like a wrapper around the virtual functions. This is a particular manifestation of the more general design pattern known as Template Method1.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class GameCharacter { public: int healthValue() const // derived classes do not redefine  { ... // do \u0026#34;before\u0026#34; stuff  int retVal = doHealthValue(); // do the real work  ... // do \u0026#34;after stuff  return retVal; } ... private: virtual int doHealthValue() const // derived classes may redefine this  { ... // default algorithm for calculating character\u0026#39;s health  } };   The NVI idiom involves derived classes redefining private virtual functions that they can\u0026rsquo;t call - this seemingly contradictory rule is allowed by C++ and actually makes perfect sense: redefining a virtual function specifies how something is to be done, while calling a virtual function specifies when it will be done, and these two concerns are independent.\nHowever, it\u0026rsquo;s not strictly necessary to declare the virtual functions private: in the cases where the derived class implementations of a virtual function are expected to invoke their base class counterparts, we have to declare the virtuals protected. Sometimes a virtual function even has to be public (e.g., destructors in polymorphic base classes, item 7), but then the NVI idiom can\u0026rsquo;t really be applied.\nThe advantage of the NVI idiom is in the \u0026ldquo;\u0026ldquo;do \u0026lsquo;before\u0026rsquo; stuff\u0026rdquo; and \u0026ldquo;do \u0026lsquo;after\u0026rsquo; stuff\u0026rdquo; part in the code above, which enable the wrapper abilities to ensure that before a virtual function is called, the proper context is set up (e.g., locking a mutex, making a log entry, verifying the class invariants and function pereconditions, etc), and after the call is over, the context is cleaned up (e.g., unlocking a mutex, verifying function postconditions, etc). If letting clients call virtual functions directly, there\u0026rsquo;s no good way to do these stuff.\nThe strategy pattern The NVI idiom is still using virtual functions to calculate a character\u0026rsquo;s health. A more dramatic design assertion, such as the strategy pattern, says that calculating a character\u0026rsquo;s health is independent of the character\u0026rsquo;s type - the calculation need not to be part of the character.\nIt is worth noting that, due to its being outside the GameCharacter hierarchy, the calculation has no special access to the internal parts of the object whose health it\u0026rsquo;s calculating, so this design pattern works only if a character\u0026rsquo;s health can be calculated based purely on information available through the character\u0026rsquo;s public interface. Thus it may require the class\u0026rsquo;s encapsulation to be weakened (e.g., make the non-member functions to be friend, or offer public accessor functions for class implementation that is previously hidden).\nThe strategy pattern via function pointers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class GameCharacter; // forward declaration  // function for default health calculation algorithm int defaultHealthCalc(const GameCharacter\u0026amp;); class GameCharacter { public: typedef int(*HealthCalcFunc)(const GameCharacter\u0026amp;); explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc) : healthFunc(hcf) {} int healthValue() const { return healthFunc(*this); } ... private: HealthCalcFunc healthFunc; };   The advantage of this approach is some interesting flexibility:\n different instances of the same character type can have different health calculation functions installed health calculation functions for a particular character may be changed at runtime. For example, GameCharacter might offer a member function setHealthCalculator that allowed replacement of the current health calculation function.  The strategy pattern via TR1::function To generalized the approach above, we could replace the function pointer healthFunc with an object of type tr1::function. As item 54 explains, such objects may hold any callable entity (e.g., function pointer, function object, member function pointer) whose signature is compatible2 with the given target signature:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class GameCharacter; // forward declaration  // function for default health calculation algorithm int defaultHealthCalc(const GameCharacter\u0026amp;); class GameCharacter { public: // HealthCalcFunc is any callable entity that can be called with anything  // compatible with a GameCharracter and that returns anything  // compatible with an int  typedef std::tr1::function\u0026lt;int (const GameCharacter\u0026amp;)\u0026gt; HealthCalcFunc; explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc) : healthFunc(hcf) {} int healthValue() const { return healthFunc(*this); } ... private: HealthCalcFunc healthFunc; };   The advantage of this approach is that clients may have more flexibility in specifying health calculation functions with various compatible callable entities:\n1 2 3 4 5 6 7 8 9  short calcHealth(const GameCharacter\u0026amp;); // function; non-int return type struct HealthCalculator { // class for health calculation function objects  ... }; class GameLevel { public: float health(const GameCharacter\u0026amp;) const; // member function; non-int return type  ... };   To use these callable entities:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class EvilBadGuy: public GameCharacter { public: explicit EvilBadGuy(HealthCalcFunc hcf = defaultHealthCalc) : GameCharacter(hcf) {...} ... }; class EyeCandyCharacter: public GameCharacter { ... // similar constructor as EvilBadGuy }; EvilBadGuy ebg1(calcHealth); // character using a health calculation function EyeCandyCharacter ecc1(HealthCalculator()); // character using a health calculation function object GameLevel currentLevel; ... EvilBadGuy ebg2( // character using a health calculation member function  std::tr1::bind(\u0026amp;GameLevel::health, currentLevel, _1) );   Here, the purpose of calling tr1::bind is that:\n it adapts the GameLevel::health member function (which takes two parameters: an implicit GameLevel parameter that this points to, as well as another reference to a GameCharacter parameter) into the expected function signature (which should only take a single paramter: the GameCharacter) by passing _1, it specifies that when calling GameLevel::health for ebg2, always use currentLevel as the first parameter of GameLevel object  The \u0026ldquo;Classic\u0026rdquo; strategy pattern The conventional approach to Strategy design pattern would be to make the health-calculation function a virtual member function of a separate health-calculation hierarchy with root being HealthCalcFunc, so that different health calculation algorithm could be implemented in the derived classes in this inheritance hierarchy. Each object of type GameCharacter just contains a pointer to an object from the HealthCalcFunc hierarchy:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class GameCharacter; // forward declaration  class HealthCalcFunc { public: ... virtual int calc(const GameCharacter\u0026amp;) const {...} ... }; HealthCalcFunc defaultHealthCalc; class GameCharacter { public: explicit GameCharacter(HealthCalcFunc *phcf = \u0026amp;defaultHealthCalc) : pHealthCalc(phcf) {} ... private: HealthCalcFunc *pHealthCalc; };    Template Method design pattern has nothing to do with C++ template.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Here, the \u0026ldquo;target signature\u0026rdquo; is \u0026ldquo;function taking a reference to a const GameCharacter and returning an int\u0026rdquo;, so any callable entity whose parameter can be implicitly converted to a const GameCharacter\u0026amp; and whose return type can be implicitly converted to an int is compatible with an object of the declared tr1::function type.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":156,"section":"notes","tags":["technique","cpp"],"title":"Item-35 Consider Alternatives to Virtual Functions","uri":"https://nianze.ml/en/notes/2018/02/consider-alternatives-to-virtual-functions/"},{"content":"Inheritance of interface is different from inheritance of implementatino.\nUnder public inheritance, derived classes always inherit base class interfaces, but may act differently in terms of base class implementation inheritance:\n Pure virtual functions specify inheritance of interface only Simple (impure) virtual functions specify inheritance of interface plus inheritance of a default implementation Non-virtual functions specify inheritance of interface plus inheritance of a mandatory implementation  To show the implementation differences above, we can define following classes for an example:\n1 2 3 4 5 6 7 8 9  class Shape { // abstract class public: virtual void draw() const = 0; // pure virtual function, draws the current obj.  virtual void error(const std::string\u0026amp; msg); // impure virtual function, called by member functions if they need to report an error  int objectID() const; // non-virtual function, returns a unique integer identifier for the current obj. }; class Rectangle: public Shape {...}; class Ellipse: public Shape {...};   Since derived classes Rectangle and Ellipse are both public inherited, according to item 32, this means is-a, so anything that is true of the base class must also apply to derived classes. Thus, the member function interfaces are always inherited.\nPure virtual functions For pure virtual functions, there are two features we have to note:\n they must be redeclared by any concrete class that inherits them they typically have no definition in abstract classes  From these feature, we can conclude that:\n The purpose of declaring a pure virtual function is to have derived classes inherit a function interface only.\n Here, the declaration of Shape::draw says to the client of the Shape that, \u0026ldquo;you have to provide a draw function, but I don\u0026rsquo;t know how you\u0026rsquo;re going to implement it.\u0026rdquo;\nIncidentally, C++ allows us to provide an implementation for Shape::draw (example: pure virtual destructor in item 7). However, the only way to call it would be to qualify the call with the class name:\n1 2 3 4  Shape *ps = new Shape; // error! Shape is abstract Shape *ps1 = new Rectangle; // fine ps1-\u0026gt;draw(); // call Rectangle::draw ps1-\u0026gt;Shape::draw(); // call Shape::draw   This feature is generally of limited utility, except that it can be employed as a mechanism for providing a safer-than-usual default implementation for simple virtual functions as we\u0026rsquo;ll see below.\nSimple (impure) virtual functions Simple virtual functions provide an implementation that derived classes may override, which means that\n The purpose of declaring a simple virtual function is to have derived classes inherit a function interface as well as default implementation.\n For example, the declaration of error function tells us that \u0026ldquo;You have to supoort an error function, but if you don\u0026rsquo;t want to write your own, you can fall back on the default version in the Shape class.\u0026rdquo;\nPotential danger However, in the perspective of class design, there\u0026rsquo;s a potential danger to allow simple virtual functions to specify both a function interface and a default implementation. That is: a derived class is allowed to inherit the default implementation without explicitly saying that it wanted to. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Airport {...}; // represents airports  class Airplane { public: virtual void fly(const Airport\u0026amp; destination); ... }; void Airplane::fly(const Airport\u0026amp; destination) { default code for flying an airplane to the given destination } class ModelA: public Airplane{...}; class ModelB: public Airplane{...};   Suppose both ModelA and ModelB inherit the base class Airplane without re-implementing the simple virtual function fly. Chances are that ModelB is actually a new type of model, yet its programmer simply forgets to redefine the fly function.\nSeparate interface from default implementation To make our design more foolproof, we may separate functions for providing interface and default implementation, such as below:\n1 2 3 4 5 6 7 8 9 10  class Airplane { public: virtual void fly(const Airport\u0026amp; destination) = 0; ... protected: void defaultFly(const Airport\u0026amp; destination) { default code for flying an airplane to the given destination } };   1 2 3 4 5 6  class ModelA: public Airplane { public: virtual void fly(const Airport\u0026amp; destination) { defaultFly(destination); } ... };   1 2 3 4 5 6 7 8 9 10  class ModelB: public Airplane { public; virtual void fly(Airport\u0026amp; destination); ... }; void ModelB::fly(const Airport\u0026amp; destination) { special code for flying a ModelB airplane to the given destination }   Take use of pure virtual function Some people may feel this design is redundant, arguing that this will polllute the class namespace with a proliferation of closely related function names. Then we may take advantage of the fact that pure virtual functions, which insists on redeclaring in concrete derived classes, may also have implementations of their own:\n1 2 3 4 5 6 7 8 9 10  class Airplane { public: virtual void fly(const Airport\u0026amp; destination) = 0; ... }; void Airplane::fly(const Airport\u0026amp; desination) // an implementation of a pure virtual function { default code for flying an airplane to the given destination }   1 2 3 4 5 6  class ModelA: public Airplane { public: virtual void fly(const Airport\u0026amp; destination) { Airplane::fly(destination); } ... }   1 2 3 4 5 6 7 8 9 10  class ModelB: public Airplane { public; virtual void fly(Airport\u0026amp; destination); ... }; void ModelB::fly(const Airport\u0026amp; destination) { special code for flying a ModelB airplane to the given destination }   In essence, this design breaks fly into two fundamental components:\n fly\u0026rsquo;s declaration specifies its interface, which derived classes must use fly\u0026rsquo;s definition specifies its default behavior, which derived classes may use by explicitly request it  However, in merging fly and defaultFly, we have lost the ability to give the two functions different protection levels: previously protected code in defaultFly is now public in fly.\nNon-virtual function A non-virtual member function specifies an invariant over specialization (a point discussed in item 36), identifying behavior that is not supposed to change, no matter how specialized a derived class becomes. Thus:\n The purpose of declaring a non-virtual function is to have derived classes inherit a function interface as well as a mandatory implementation.\n The declaration for Shape::objectId is basically say, \u0026ldquo;Every Shape object has a function that yields an object identifier, and that identifier is always conputed the same way. That way is determined by the definition of Shape::objectID, and no derived class should try to chagne how it\u0026rsquo;s done.\u0026rdquo;\nSummary The differences in declarations for pure virtual, simple virtual and non-virtual functions allow us to specify with precision what we want derived classes to inherit: interface only, interface and a default implementation, or interface and a mandatory implementation, respectively.\n","description":"","id":157,"section":"notes","tags":["technique","cpp"],"title":"Item-34 Differentiate between inheritance of interface and inheritance of implementation","uri":"https://nianze.ml/en/notes/2018/02/differentiate-inheritance-of-interface-from-inheritance-of-implementation/"},{"content":"Names in derived classes hide names in base classes, which is not desirable in public inheritance. To fix it, employ using declarations or forwarding functions to make hidden names visible again.\nAs we all know, names in inner scopes hide (\u0026ldquo;shadow\u0026rdquo;) names in outer scopes. Specifically, whether the names correspond to the same or different types is immaterial. In the world of inheritance, the scope of a derived class is nested inside its base class\u0026rsquo;s scope, so if we define following classes:\n1 2 3 4 5 6 7 8  class Base { private: int x; public: virtual void mf1() = 0; virtual void mf2(); void mf3(); };   1 2 3 4 5 6 7 8 9 10 11 12  class Derived: public Base { public: virtual void mf1(); void mf4(); }; void Derived::mf4() { ... mf2(); ... }   When compilers see the use of the name mf2 here, they figure out what it refers to by searching scopes for a declaration of something named mf2 by following order:\n first they look in the local scope of mf4 then they search the containing scope, that of the class Derived they move on to the next containing scope, that of the base class (there they found something named mf2, so the search stops) if there were no mf2 in Base, the search will continue, first to the namespace(s) containing Base, and finally to the global scope  Consider again what will happen if the two classes are defined in the following way, with mf1 and mf3 overloaded in Base and a new mf3 added in Derived:\n1 2 3 4 5 6 7 8 9 10  class Base { private: int x; public: virtual void mf1() = 0; virtual void mf1(int); virtual void mf2(); void mf3(); void mf3(double); };   1 2 3 4 5 6  class Derived: public Base { public: virtual void mf1(); void mf3(); void mf4(); };   From the perspective of name lookup, Base::mf1 and Base::mf3 are no longer inherited by Derived, because all functions names mf1 and mf3 in the base class are hidden by the functions names mf1 and mf3 in the derived class. This leads to following behavior:\n1 2 3 4 5 6 7 8  Derived d; int x; ... d.mf1(); // fine, calls Derived::mf1 d.mf1(x); // error! Derived::mf1 hides Base::mf1 d.mf2(); // fine, calls Base::mf2 d.mf3(); // fine, calls Derived::mf3 d.mf3(x); // error! Derived::mf3 hides Base::mf3   Even though the functions in the base and derived classes take different parameter types, and no matter those functions are virtual or non-virtual, the name lookup rule applies regardlessly. The rationale behind this behavior is to prevent us from accidentally inheriting overloads from distant base classes when we create a new derived class in a library or application framework. However, sometimes we want to inherit the overloads1.\nTo access the hidden names, we have two ways to go: using declarations and forwarding function.\nusing declarations 1 2 3 4 5 6 7 8 9 10 11  class Base{...}; // the same  class Derived: public Base { public: using Base::mf1; // make all things in Base named mf1 and mf3  using Base::mf3; // visible (and public) in Derived\u0026#39;s scope  virtual void mf1(); void mf3(); void mf4(); };   And now inheritance will work as expected:\n1 2 3 4 5 6 7 8  Derived d; int x; ... d.mf1(); // fine, calls Derived::mf1 d.mf1(x); // now ok, call Base::mf1 d.mf2(); // fine, calls Base::mf2 d.mf3(); // fine, calls Derived::mf3 d.mf3(x); // now ok, call Base::mf3   This tells us that\n if we inherit from a base class with overloaded functions and we want to redefine or override only some of them, we need to include a using declaration for each name we\u0026rsquo;d otherwise be hiding. If we don\u0026rsquo;t, some of the names we\u0026rsquo;d like to inherit will be hidden.\n Unser public inheritance, we always want to inherit all the functions from the base classes to follow public inheritance\u0026rsquo;s is-a relationship between base and derived classes, which is why the using declarations above are in the public part of the derived class (names that are public in a base class should also be public in a publicly derived class).\nHowever, under private inherits (item 39), it can make sense to inherit only part of the functions from the base classes. A the using declaration won\u0026rsquo;t do the trick here, for it makes all inherited functions with a given name visible in the derived class. We use a different technique: forwarding function.\nForwarding function 1 2 3 4 5 6 7 8  class Base{...}; // the same  class Derived: public Base { public: virtual void mf1() // forwarding function; implicitly inline, see item 30  { Base::mf1(); } ... };   1 2 3 4 5  Derived d; int x; d.mf1(); // fine, calls Derived::mf1 d.mf1(x); // error! Base::mf1() is hidden   For ancient compilers that don\u0026rsquo;t support using declarations, we also have to use forwarding function technique to import inherited names into the scope of derived classes.\nWhen inheritance is combined with templates, an entirely different form of the \u0026ldquo;inherited names are hidden\u0026rdquo; issue arises. See item 43 for all the angle-bracket-demarcated details.\n In fact, in public inheritance, if we don\u0026rsquo;t inherit the overloads, we\u0026rsquo;re violating the is-a relationship between base and derived classes, which, as explained in item 32, is fundamental to public inheritance.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":158,"section":"notes","tags":["technique","cpp"],"title":"Item-33 Avoid hiding inherited names","uri":"https://nianze.ml/en/notes/2018/02/avoid-hiding-inherited-names/"},{"content":"Everything that applies to base classes must also apply to derived classes in public inheritance, for every derived class object is a base class object.\nThere are multiple relationships that can exist between classes:\n \u0026ldquo;is-a\u0026rdquo; is talked about in this item. \u0026ldquo;has-a\u0026rdquo; is discussed about in item 38. \u0026ldquo;is-implemented-in-terms-of\u0026rdquo; is introduced in item 39.  We should understand the differencea among these relationships.\nFor \u0026ldquo;is-a\u0026rdquo;, we should understand it in this way: if the class D (\u0026ldquo;derived\u0026rdquo;) publicly inherits from class B (\u0026ldquo;base), C++ compilers will assume that every object of type D is also an object of type B, but not vice versa. That is, every D is-a B, but not vice versa 1.\nThe concept of is-a sounds simple, but sometimes our intuition may mislead us. Say we want to create class Square and class Rectangle. I hear you say:\n Everybody knows that a square is a rectangle, but generally not vice versa\n Then consider this code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Rectangle { public: virtual void setHeight(int newHeight); virtual void setWidth(int newWidth); virtual int height() const; // return current values  virtual int width() const; ... }; void makeBigger(Rectangle\u0026amp; r) // function to increase r\u0026#39;s area { int oldHeight = r.height(); r.setWidth(r.width() + 10); // add 10 to r\u0026#39;s width  assert(r.height() == oldHeight); // assert that r\u0026#39;s height is unchanged }   1 2 3 4 5 6 7  class Square: public Rectangle {...}; Square s; ... assert(s.width() == s.height()); // must be true for all squares makeBigger(s); // by inheritance, s is-a Rectangle, so we can increase its area assert(s.width() == s.height()); // must be true for all squares   Now we face a big problem: how can we reconcile the following assertion:\n before calling makeBigger, s\u0026rsquo;s height is the same as its width; inside makeBigger, s\u0026rsquo;s width is changed, but its height is not; after returning from makeBigger, s\u0026rsquo;s height is again the same as its width  Here, the instincts we\u0026rsquo;ve develped in mathematics does not serve well. In this case, something applies to a rectangle is not applicable to a square, but public inheritance asserts that everthing that applies to base class object also applies to derived class objects. Thus using public inheritance to model the relationship between Rectangle and Square is incorrect.\nWith the knowledge of inheritance added into our arsenal of design, we\u0026rsquo;ll have to augment our intuition with new insights to guide us in inheritance\u0026rsquo;s proper application.\n This is true only for public inheritance. Private inheritance means somethign entirely different (item 39), and protected inheritance is something beyond understanding.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":159,"section":"notes","tags":["technique","cpp"],"title":"Item-32 Make sure public inheritance models \"Is-A\"","uri":"https://nianze.ml/en/notes/2018/02/make-sure-public-inheritance-models-is-a/"},{"content":"To minimize compilation dependencies, depend on declarations instead of definitions via techniques such as Handle classes and Interface classes.\nC++ doesn\u0026rsquo;t do a very good job of separating interfaces from implementations. A class definition specifies not only a class interface but also a fair number of implementation details. For example:\n1 2 3 4 5 6 7 8 9 10 11 12  class Person { public: Person(const std::string\u0026amp; name, cnost Data\u0026amp; birthday, const Address\u0026amp; addr); std::string name() const; std::string birthDate() const; std::string address() const; ... private: std::string theName; // implementation detail  Date theBirthdate; // implementation detail  Address theAddress; // implementation detail };   Here, to compile Person, definitions for the data members string, Date, and Address that Person uses must be provided, typically through #include directives:\n1 2 3  #include \u0026lt;string\u0026gt;#include \u0026#34;date.h\u0026#34;#include \u0026#34;address.h\u0026#34;  Unfortunately, this inclusion sets up a compilation dependency between the file defining Person and these header files. If any of these header files or the header files' dependent header files is changed, the file containing the Person class must be recompiled, as must any files that use Person. Such cascading compilation dependencies are annoying, but C++ insists on putting the implementation details of a class in the class definition - we can\u0026rsquo;t separate the implementation details of the class definition simply by forward-declaring everything like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  namespace std { class string; // incorrect way of forward declaration } class Date; // forward declaration class Address; // forward declaration  class Person { public: Person(const std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr); std::string name() const; std::string birthDate() const; std::string address() const; ... };   There\u0026rsquo;re two problems with this idea:\n  The minor one: string is not a class but a typedef for basic_string\u0026lt;char\u0026gt;. Thus the forward declaration for string is incorrect1.\n  The more significant one: compilers need to know the size of objects to allocate enough space (typically on the stack) when they see a difinition for object p, so the implementation details can not be omited:\n1 2 3 4 5 6  int main() { ... Person p(params); // define a Person  ... }     The essence of minimizing compilation dependencies it to truly separate interface from implementation, which means we have to replace dependencies on definitions with dependencies on declarations.\nHandle classes One way to hide the object implementation is through a pointer, in which case compilers allocate only enough space for a pointer when an object is defined:\n1 2 3 4 5 6  int main() { ... Person *p; // define a pointer to a Person  ... }   This is how languages like Smaltalk and Java deal with the object difinition, which is also totally legal in C++: we simply separate Person into two classes, one offering only an interface, the other implementing that interface:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;string\u0026gt; // standard library components#include \u0026lt;memory\u0026gt; // for tr1::shared_ptrclass PersonImpl; // forward decl of Person impl. class class Date; // forward decls of classes used in Person interface class Address; class Person{ public: Perosn(const std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr); std::string name() const; std::string birthDate() const; std::string address() const; ... private: // ptr to implementation  std::tr1::shared_ptr\u0026lt;PersonImpl\u0026gt; pImpl; // see item 13 for shared_ptr };   This design is often said to be using the pimpl idiom (\u0026ldquo;pointer to implementation\u0026rdquo;). With such a design, clients of Person are divorced from the details of dates, address, and persons. Now, even if the implementations of those classes have been modified, Person\u0026rsquo;s clients need not recompile.\nIn summary:\n  Avoid using objects when object references and poinnters will do (defining objects of a type necessitates the presence of the type\u0026rsquo;s definition).\n  Depend on class declarations instead of class definitions whenever we can:\n1 2 3  class Date: // class declaration Date today(); // fine without class definition void clearAppointments(Date d); // fine. No definition of Date is needed   Of course, if anybody calls function today or clearAppointments, Date\u0026rsquo;s definition must have been seen prior to the call. But the point here is:\nBy moving the onus of providing class definitions from our library header file of function declarations to clients' files containing function calls, the client dependiencies on type definitions they don\u0026rsquo;t really need could be eliminated (especially when we have a library containing dozens of function declarations that not everybody calls all of them).\n  Provide separate header files for declarations and definitions.\nInstead of forward-declaring something, library clients should always #include a declaration file, so library authors should provide two header files: one for declarations, the other for definitions. For example,\n1 2 3  #include \u0026#34;detefwd.h\u0026#34; // header file declaring (but not defining) class DateDate today(); // as before void clearAppointments(Date d);   Here, the name of the declaration-only header file \u0026ldquo;datefwd.h\u0026rdquo; is based on the header 2 from the standard C++ library (item 54).\n  To employ the pimpl idiom, we just let forward all the function calls in the handle class Person to the corresponding implementation class PersonImpl, which will do the real work. Below is the implementation of Person\u0026rsquo;s member functions:\n1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026#34;Person.h\u0026#34; // #inclue Person\u0026#39;s class definition#include \u0026#34;PersonImpl.h\u0026#34; // #include PersonImpl\u0026#39;s class definition to call its member functions; // note that interfaces of PersonImpl and Person are identical Person::Person(const std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr) :pImpl(new PersonImpl(name, birthday, addr)) {} std::string Person::name() const { return pImpl-\u0026gt;name(); } ...   Interface classes An alternative approach is to make Person a special kind of abstract base class called an Interface class, which typically has no data members, no constructors, a virtual destructor (item 7), and a set of pure virtual funcitons that specify the interface. The similar concept could be found in Java and .NET, except that C++ doesn\u0026rsquo;t impose the restrictions on Interface classes as Java and .NET do3.\nAn interface class for Person looks like this:\n1 2 3 4 5 6 7 8 9  class Person { public: virtual ~Person(); virtual std::string name() const = 0; virtual std::string birthDate() const = 0; virtual std::string address() const = 0; ... };   Like clients of Handle classes, clients of Interface classes need not recompile unless the Interface class\u0026rsquo;s interface is modified.\nIn order to use Interface classes:\n  clients need to program in terms of Person pointers and references, for Person, which contains pure virtual functions, can not be instantiated\n  typically, clients create new Person objects by calling factory functions (item 13) or virtual constructors, which return pointers (preferably smart pointers, item 18) to dynamically allocated objects of derived classes that support the interface. Such functions are often declared static inside the Interface class:\n1 2 3 4 5 6 7 8 9  class Person { public: ... static std::tr1::shared_ptr\u0026lt;Person\u0026gt; // return a tr1::shared_ptr to a new  create(const std::string\u0026amp; name, // Person initialized with the  const Date\u0026amp; birthday, // gien params  const Address\u0026amp; addr); ... };   1 2 3 4 5 6 7  std::string name; Date dateOfBirth; Address address; ... // create an object supporting the Person interface std::tr1::shared_ptr\u0026lt;Person\u0026gt; pp(Person::create(name, dateOfBirth, address)); ...     one way to implement the Interface class Person is to define a concrete derived class that inherits interface specification from Person, and then implement the functions in the interface:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class RealPerson: public Person { public: RealPerson(const std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr) : theName(name), theBirthDate(birthday), theAddress(addr) {} virtual ~RealPerson(){} std::string name() const; std::string birthDate() const; std::string address() const; private: std::string theName; std::string theBirthDate; Address theAddress; };   Then it is trivial to write Person::create:\n1 2 3 4 5  std::tr1::shared_ptr\u0026lt;Person\u0026gt; Person::create(const std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr) { return std::tr1::shared_ptr\u0026lt;Person\u0026gt;(new RealPerson(name, birthday, addr)); }   Of course, a more realistic implementation of Person::create would create different types of derived class objects, depending on the values of additional parameters.\n  another way to implement an Interface class involves multiple inheritance, a topic explored in item 40.\n  Cost of decoupling interfaces from implementations The cost of Handle classes and Interface classes is the usual one in computer science: it costs us some speed at runtime, plus some additional memory per object. In addition, neither of them can get much use out of inline functions (item 30), since inline functions typically exists in header files while this item talks about how to hide implementation details like function bodies in header file.\nFor Handle classes:\n impact on runtime speed:  member functions have to go through the implementation pointer to get to the object\u0026rsquo;s data, which adds one level of indirection per access; the implementation object is dynamically allocated during the initialization of implementation pointer, which incurs the overhead of dynamic memory allocation and subsequent deallocation, as well as possible bad_alloc (out-of-memory) exception.   impact on memory:  we have to add the size of the implementation pointer to the amount of memory required by each object.    For Interface classes:\n impact on runtime speed:  every function call is virtual, so we pay the cost of an indirect jump for each function call (item 7).   impact on memory:  object derived from the Interface class must contain a virtual table pointer (item 7), which may increase the amount of memory needed to store an object (if the Interface class is the exclusive source of virtual functions for the object)    Despite all the costs, consider using these techniques in an evolutionary manner:\n use Handle classes and Interface classes during development to minimize the impact on clients when implementations change replace Handle classes and Interface classes with concrete classes for production use when the difference in speed and/or size is significant enough to justify the increased coupling between classes.   The proper forward declaration of string is substantiallly complex, because it involves additional templates. Anyway, we shouldn\u0026rsquo;t manually decalre parts of the standard library. Instead, user the proper #includes and be done with it.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  contains declarations of iostream components whose corresponding definitions are in several different headers, including , , , and . Note that it still makes sense to provide declaration-only headers for templates: although in many build environments, template definitions are typically found in header files (item 30), some build environments still allow template definitons to be in non-headre files; and C++ also offers the export keyword to allow the separation of template declarations from template definitions (unfortunately compiler support for export is scanty).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Neither Java nor .NET allow data members or function implementations in Interfaces, but C++ allows so, which could be useful in flexibility. For example, as item 36 explains, the implementation of non-virtual functions should be the same for all classes in a hierarchy, so it makes sense to implement such functions as part of the Interface class.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":160,"section":"notes","tags":["technique","cpp"],"title":"Item-31 Minimize compilation dependencies between files","uri":"https://nianze.ml/en/notes/2018/02/minimize-compilation-dependencies-between-files/"},{"content":"Limit most inlining to small, frequently called functions to facilitate debugging and binary upgradability, minimize potential code bloat, and maximize the chances of greater program speed.\nPerformance benifits Inline functions have some wonderful advantages:\n They act like functions. Yet we call them without having to incur the overhead of a function call. Compilers might perfom context-specific optimizations (such as stretches of the code) on the body of the inline function thanks to the lack \u0026ldquo;outlined\u0026rdquo; function call If an inline function body is very short, the code generated for the function body may be smaller than the code generated for a function call, leading to smaller object code and a higher instruction cache hit rate.  However, on the other hand, it is also likely to increase the size of our object code. Overzealous inlining can give rise to programs too big for the available space on machines with limited memory. Even with virtual memory, inline-induced code bloat can lead to additional paging, a reduced instruction cache hit rate, and the performance penalties that accompany these things.\nDetails on inline functions There are two ways to give such a request: implicitly or explicitly:\n  Implicitly inline request\n1 2 3 4 5 6 7 8  class Person { public: ... int age() const { return theAge; } // an implicit inline request  ... private: int theAge; };   Apart from the member functions, we can also define friend functions inside classes (item 46), resulting to implicitly inline declaration.\n  Explicitly inline request (and its relationship with template)\nWe can explicitly daclare an inline function with the inline keyword, such as how the standard max template from \u0026lt;algorithm\u0026gt; is implemeted:\n1 2 3  template\u0026lt;typename T\u0026gt; // an explicit inline inline const T\u0026amp; std::max(const T\u0026amp; a, const T\u0026amp; b) // request:: std::max is preceded by \u0026#34;inline\u0026#34; { return a \u0026lt; b ? b : a;}   It\u0026rsquo;s true that both template and inline functions are typically defined in header files, but this doesn\u0026rsquo;t mean that function templates must be inline. In fact, template instantiation is independent of inlining:\n inline functions must typically be in header files, because most build environments do inlining during compilation. In order to replace a function call with the body of the called function, compilers must know waht the function looks like 1. templates are typically in header file, because compilers need to know what a template looks like in order to instantiate it when it\u0026rsquo;s used 2.  Thus, when we\u0026rsquo;re writing a template:\n if we belive that all the functions instantiated from the template should be inlined, declare the template inline just like what\u0026rsquo;s done with the std::max implamentation above; if we have no reason to want inlined after considering its cost and potential code bloat (which is particularly important for template authors - see item 44), avoid declaring the template inline (either explicitly or implicitly)    Causes of un-inlined inline function Bear in mind that inline is a request to compilers, rather than a command, so compilers may ignore it. Whether a given inline function is actually inlined depends on the build environment we\u0026rsquo;re using - primarily on the compiler, and most compilers have a diagnostic level that will result in a warning (item 53) if they fail to inline a function we\u0026rsquo;ve asked them to. When they refuse to inline a function, the typical reasons may be:\n compilers deem the function too complicated (e.g., those containing loogs or are recursive) the function is virtual (virtual means runtime, while inline usually happens before execution) when the program will take the address of an inline function:  1 2 3 4 5  inline void f(){...} // assume compilers are willing to inline calls to f void (*pf)() = f; // pf points to f ... f(); // this call will be inlined, for it\u0026#39;s a \u0026#34;normal\u0026#34; call pf(); // this call probably won\u0026#39;t be, for it\u0026#39;s through a function pointer   Inline constructors and destructors? Note that even if we never use function pointers, sometimes compilers will generate those pointers: compilers may generate out-of-line copies of constructors and destructors so that they can get pointers to those functions for use during construction and destruction of objects in arrays. Let alone that constructors and destructors are often worse candidates of inlining than a casual examination would indicate:\n1 2 3 4 5 6  class Base { public: ... private: std::string bm1, bm2; // base members 1 and 2 };   1 2 3 4 5 6 7  class Derived: public Base { public: Derived(){} // Derived\u0026#39;s ctor is empty, or is it?  ... private: std::string dm1, dm2, dm3; // derived members 1,2,3 }   The constructor of Derived seems empty, so it may seem a good candidate for inlining. But looks can be deceiving:\n C++ makes various guarantees about object construction and corresponding destruction. To name a few: when we create an object, each base class of and each data member in that object is automatically constructed; if an exception is thrown during construction, any parts of the object that have already been fully constructed are automatically destroyed. Similar but reverse process will occur when an object is destroyed.\n Therefore, in the example above, extra code will be generated by compilers and added into the empty Derived constructor in order to offer those guarantees, ending up with some code equivalent to the following conceptual implementation (the real one will certainly be more sophisticated):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  Derived::Derived() // conceptual impl. of \u0026#34;empty\u0026#34; Derived ctor { Base::Base(); // init. Base part  try { dm1.std::string::string(); } // try to construct dm1  catch (...) { // if it throws  Base::~Base(); // destroy base class part and  throw; // propagate the exception  } try { dm2.std::string::string();} // try to construct dm2  catch(...) { // if it throws  dm1.std::string::~string(); // destroy dm1,  Base::~Base(); // destroy base class part  throw; // and propagate the exception  } try { dm3.std::string::string();} // try to construct dm3  catch(...) { // if it throws  dm1.std::string::~string(); // destroy dm1,  dm1.std::string::~string(); // destroy dm2,  Base::~Base(); // destroy base class part  throw; // and propagate the exception  } }   The same reasoning applies to the Base constructor, so if Base\u0026rsquo;s constructor is inlined, and string constructor also happens to be inlined, the Derived constructor will gain five copies of string\u0026rsquo;s constructor, one for each of the five strings in a Derived object - that is a big code bloat. Similar considerations apply to Derived\u0026rsquo;s destructor.\nOther costs of inlining Apart from the cost of possible code bloat, there are other impact of declaring functions inline:\n on binary upgradability: for library designers, it\u0026rsquo;s impossible to provide binary upgrades to the client visible inline functions in a library, after clients of the library compile the body of inline function f into their application. Once the imlementation of f changes, all clients who\u0026rsquo;ve used f must recompile. on debugging: most debuggers have trouble with inline functions: after all, it is hard to set a breakpoint in a function that isn\u0026rsquo;t there3.  To inline or not to inline? In summary, the logical strategy of determining which functions should be declared inline and which should not:\n initially don\u0026rsquo;t inline anything detect those functions that must be inline (item 46) or are truly trivial (such as Person::age in this item), inline them cautiously as a hand-applied optimization as the empirically determined rule of 80-20 suggests: identify the 20% of your code that can increase your program\u0026rsquo;s overall performance, and try to tweak those critical functions with inline or other techniques   There are exceptions: some build environments can inline during linking, and a few can actually inline at runtime (e.g., managed environments based on the .NET Common Language Infrastructure - CLI). Of course, such exceptions are not the rule, and inlining in most C++ programs is a compile-time activity.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Again, some build environments perform template instantiation during linking. However, compile-time instantiation is more common.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Some build environments manage to support debugging of inlined functions, but many environments simply disable inlining for debug builds.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":161,"section":"notes","tags":["technique","cpp"],"title":"Item-30 Understand ins and outs of inlining","uri":"https://nianze.ml/en/notes/2018/02/ins-and-outs-of-inlining/"},{"content":"Exception-safe functions leak no resources and allow no data structures to become corrupted, even when exceptions are thrown. Such functions offer the basic, strong, and nothrow guarantees.\nFor exception-safe functions, there are two requirements when an exception is thrown:\n Leak no resources Don\u0026rsquo;t allow data structures to become corrupted  Specifically, from the perspective of data structure corruption, exception-safe functions must offer one of three guarantees below from the weakest to the strongest:\n The basic guarantee promises that if an exception is thrown, everything in the program remains in a valid state - all class invariants are satisfied, but the exact state of the program may not be predictable. The strong guarantee promises that if an exception is thrown, the state of the program is unchanged - calls to such functions are atomic in the sense that if they succeed, they successd completely, and if they fail, the program state is as if they\u0026rsquo;d never been called. The nothrow guarantee promises never to throw exceptions - all operators on built-in types (e.g., ints, pointers, etc.) are nothrow. This is a critical building block of exception-safe code.  Example With all these terminologies bear in mind, let\u0026rsquo;s see an example representing exception-unsafe style. Suppose there\u0026rsquo;s a class for GUI menus with background images, and it will be used in a threaded environment, so it has a mutex for concurrency control:\n1 2 3 4 5 6 7 8 9  class PrettyMenu { public: ... void changeBackGround(std::istream\u0026amp; imgSrc); // change background image private: Mutex mutex; // mutex for this obejct  Image *bgImage; // current background image  int imageChanges; // # of times image has been changed };   1 2 3 4 5 6 7 8  void PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { lock(\u0026amp;mutex); // acquire mutex (item 14)  delete bgImage; // get rid of old background  ++imageChanges; // update image change count  bgImage = new Image(imgSrc); // install new background  unlock(\u0026amp;mutex); // release mutex }   Firstly, the code above is likely to encounter resource leak, because if the new Image(imgSrc) expression yields an exception, the call to unlock never gets executed, and the mutex is held forever.\nSecondly, this function guarantees none of the 3 promises in terms of data structure corruption above: when new Image(Src) throws, bgImage is left pointing to a deleted object, and imageChanges has been increamented before the new image has been installed, resulting to invalid object state.\nResource leak To address the resource leak issue, we can use objects to manage resources (item 13), and take advantage of Lock class to ensure that mutexes are released in a timely fashion (item 14):\n1 2 3 4 5 6 7  void PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { Lock ml(\u0026amp;mutex); // item 14: acquire mutex and ensure its later release  delete bgImage; ++imageChanges; // update image change count  bgImage = new Image(imgSrc); // install new background }   Data structure corruption To address the issue of data structure corruption, we may need to determine which guarantee to offer. As a general rule,\n we want to offer the strongest guarantee that\u0026rsquo;s practical.\n Note the word practical. We definitely want to offer nothrow guarantee for every functions we write, but it\u0026rsquo;s hard to keep such a promise - to name a common exception: anything using dynamically allocated memory (e.g., all STL containers) runs the risk of a bad_alloc exception if it can\u0026rsquo;t find enough memory to satisfy a request (item 49). For most functions, the choice for us is between the basic and strong guarantees.\nIn the case of changeBackground, almost offering the strong guarantee is not difficult:\n firstly, we change the type of bgImage data member in PrettyMunu from a built-in Image* pointer to smart pointer such as tr1::shraed_ptr (item 13), which benefits us with  preventing resource leaks offering strong exception safety guarantee   secondly, we reorder the statements so that we don\u0026rsquo;t increment imageChanges until the image has been changed.  1 2 3 4 5  class PrettyMenu { ... std::tr1::shared_ptr\u0026lt;Imgae\u0026gt; bgImage; ... };   1 2 3 4 5 6 7  void PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { Lock ml(\u0026amp;mutex); bgImage.reset(new Image(imgSrc)); // replace bgImage\u0026#39;s internal pointer with the  // result of the \u0026#34;new Image\u0026#34; expression  ++imageChanges; }   Note how the use of resource magangement object (i.e., the smart pointer here) helps:\n The tr1::shared_ptr::reset function will be called only if its parameter (the result of new Image(imgSrc)) is successfully created The delete operation for the old image is inside the reset, so if the reset function is never entered (the program somehow fails to create new image), the deletion of the old image will never take place As a result, the deletion takes place only if the new image is successfully created We don\u0026rsquo;t need to manually delete the old image, and the length of changeBackground reduces  After these two changes, changeBackground almost offer the strong exception safety guarantee. The only weakness now is the parameter imgSrc: if the Image constructor throws an exception, it\u0026rsquo;s possible that the read marker for the input stream has been moved, which is a change in state visible to the rest of the program, leading to offering only the basic exception safety guarantee.\nCopy-and-swap strategy There actually is a general design strategy for offering the strong guarantee:\n copy and swap strategy:\nMake a copy of the object we want to modify, then make all needed changes to the copy;\n  If all the changes have been successfully completed, swap the modified object with the original in a non-throwing operation (item 25); If any of the modifying operations throws an exception, the original object remains unchanged.  The strategy is usually implemented by putting all the per-object data from the \u0026ldquo;real\u0026rdquo; object into a separate implementation object, then giving the real object a pointer to its implementation object (know as the \u0026ldquo;pimpl idiom\u0026rdquo;, item 31). For PrettyMenu, it would look something like this:\n1 2 3 4 5 6 7 8 9 10 11  struct PMImpl { // PMIpml = \u0026#34;PrettyMenu Impl.\u0026#34;  std::tr1::shared_ptr\u0026lt;Image\u0026gt; bgImage; int imageChanges; }; class PrettyMenu { ... private: Mutex mutex; std::tr1::shared_ptr\u0026lt;PMImpl\u0026gt; pImpl; };   1 2 3 4 5 6 7 8 9 10  void PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { using std::swap; // item 25  Lock ml(\u0026amp;mutex); // acquire the mutex  std::tr1::shared_ptr\u0026lt;PMImpl\u0026gt; pNew(new PMImpl(*pImpl)); // copy obj. data  pNew-\u0026gt;bgImage.reset(new Image(imgSrc)); // modify the copy  ++pNew-\u0026gt;imageChanges; swap(pImpl, pNew); // swap the new data into place } // release the mutex   We don\u0026rsquo;t have to make the struct PMImpl as a class, because the encapsulation of PrettyMenu data is assured by pImpl being private, and it is more convenient to use struct. If desired, PMImpl could be nested inside PrettyMenu when considering packaging issues.\nSide effects and efficiency Even with the help of copy-and-swap strategy, there are two possible reasons that downgrade the overall exception safety level from strong to basic: side effects and efficiency.\n1. Side effects Suppose someFunc uses copy-and-swap and includes calls to two other functions, f1 and f2:\n1 2 3 4 5 6 7  void someFunc() { ... // make copy of local state  f1(); f2(); ... // swap modified state into place }   Apparently, if f1 or f2 is less than strongly exception-safe, it will be hard for someFunc to be strong exception-safe. For example, suppose f1 offers only the basic guarantee, in order to offer the strong guarantee for someFunc, we have to write code to determine the state of the entire program before calling f1, catch all exceptions from f1, and then store the original state. It\u0026rsquo;s complicated, but it\u0026rsquo;s doable. However, even if f1 and f2 are both strongly exception safe, as long as there are side effects on non-local data, it\u0026rsquo;s much harder to offer the strong guarantee.\nFor example, if a side effect of calling f1 is that a database is modified, and there is, in general, no way to undo a database modification that has already been committed; so after successfully calling f1, if f2 then throws an exception, the state of the program is not the same as it was when calling someFunc, even though f2 didn\u0026rsquo;t change anything.\n2. Efficiency Copy and swap strategy requires making a copy of each object to be modified, which takes time and space we may be unable or unwilling to make available. It\u0026rsquo;s just not practical 100% of the time when we want to offer the strong guarantee.\nWhen it\u0026rsquo;s not, we\u0026rsquo;ll have to offer the basic guarantee. In practice, we can usually offer the strong guarantee for some functions, but the const in efficiency or complexity will make it untenable for many others. For those functions, the basic guarantee is a perfectly resonable choice, as long as we\u0026rsquo;ve made a reasonable effort to offer the strong guarantee whenever it\u0026rsquo;s practical.\nIn practice A software system is either exception-safe or it\u0026rsquo;s not. There\u0026rsquo;s no such thing as a partially exception-safe system. If a system has even a single function that\u0026rsquo;s not exception-safe, the system as a whole is not exception-safe. Unfortunately, much C++ legacy code was written without exception safety in mind, so many system incorporating legacy code today are not exception-safe.\nThere\u0026rsquo;s no reason to perpetuate this state of affairs. When writing new code or modifying existing code, think carefully about how to make it exception-safe:\n begin by using objects to manage resources to prevent resource leaks follow by determining which of the three exception safety guarantees is the strongest we cound practically offer for each function, settling for no guarantee only if calls to legacy code leave us no choice. Document our decisions, both for clients of our functions and for future maintainers - a function\u0026rsquo;s exception-safety guaranteee is a visible part of its interface, so we should choose it as deliberately as we choose all other aspects of a function\u0026rsquo;s interface. ","description":"","id":162,"section":"notes","tags":["technique","cpp"],"title":"Item-29 Strive for exception-safe code","uri":"https://nianze.ml/en/notes/2018/02/strive-for-exception-safe-code/"},{"content":"Avoid returning handles to object internals to increase encapsulation, help const member functions act const, and minimize the creation of dangling handles.\nReferences, pointers, and iterators are all handlers (ways to get at other objects), and returning a handle to an object\u0026rsquo;s internals always runs the risk of\n compromising an object\u0026rsquo;s encapsulation making const member functions act like non-const ones, allowing an object\u0026rsquo;s state to be modified leading to dangling handles  To see how handlers result in these resks, let\u0026rsquo;s see an example.\nSuppose we\u0026rsquo;re working with a rectangle class, represented by its upper left corner and lower right corner. To keep a Rectangle object small, we decide that the corner points should be stored in an auxiliary struct that the Rectangle points to:\n1 2 3 4 5 6 7 8  class Point { // class representing points public: Point(int x, int y); ... void setX(int newVal); void setY(int newVal); ... };   1 2 3 4  struct RectData { // Rectangle corner point data  Point ulhc; // \u0026#34;upper left-hand corner\u0026#34;  Point lrhc; // \u0026#34;lower right-hand corner\u0026#34; }   1 2 3 4 5 6 7 8 9  class Rectangle { public: Point\u0026amp; upperLeft() const { return pData-\u0026gt;ulhc; } Point\u0026amp; lowerRight() const { return pData-\u0026gt;lrhc; } ... private: std::tr1::shared_ptr\u0026lt;RectData\u0026gt; pData; // see item 13 for tr1::shared_ptr  ... };   As item 20 suggests that passing user-defined types by reference is typically more efficient than passing them by value, the two public member functions return references to the underlying Point ojects. Yet this design is wrong, for it\u0026rsquo;s self-contradictory:\n  on the one side, the two member functions are declared const, indicating read-only access level of the point they return\n  on the other side, returning handles to private internal data lets callers be able to modify that internal data:\n1 2 3 4  Point coord1(0, 0); Point coord3(100, 100); const Rectangle rec(coord1, coord2); // rec is a const rectangle from (0,0) to (100,100) rec.upperLeft().setX(50); // now (50,0) to (100,100)     Apparently, by returning handles to the private ulhc and lrhc through the public member functions upperLeft and lowerRight, the overall access level of data member goes to public, and the encapsulation decreases. This makes the risk 1 above.\nThe second risk comes from the fact that if a const member function returns a reference (or any other handles) to data associated with an object that is stored outside the object itself, the caller of the function can modify that data due to its fallout of the limitation of bitwise constness (item 3).\nYou may think the two risks above may be eliminated by applying const to the return types:\n1 2 3 4 5 6 7  class Rectangle { public: ... const Point\u0026amp; upperLeft() const { return pData-\u0026gt;ulhc; } const Point\u0026amp; lowerRight() const { return pData-\u0026gt;lrhc; } ... };   With this altered design, the 2 problems above are indeed solved. Even so, the dangling handles in risk 3 are still possible.\n Dangling handles: handles that refer to parts of objects that don\u0026rsquo;t exist any longer.\n In fact, function return values are the most common source of dangling handles. Consider a function that returns the bounding box for a GUI object in the form of a rectangle:\n1 2  class GUIObject {...}; const Rectangle boundingBox(const GUIObject\u0026amp; obj); // returns a rectangle by value; see item 3 for why return type is const   If client use this function like this:\n1 2 3  GUIObject *pgo; // make pgo point to some GUIObject ... const Point *pUpperLeft = \u0026amp;(boundingBox(*pgo).upperLeft()); // get a ptr to the upper left point of its bounding box   This is a good example for dangling handle. The call to boundingBox will return a new, temporary Rectangle object. Let\u0026rsquo;s call it temp. upperLeft will then be called on temp, and that call will return a reference to an internal part of temp (i.e., the upperLeft corner point), to which pUpperLeft will then point. The tragedy comes at the end of the statement, when boundongBox\u0026rsquo;s return value temp is destroyed, and then it indirectly leads to the destruction of temp\u0026rsquo;s upperLeft corner point, leaving pUpperLeft pointing to an object that no longer exists.\nAs long as a handle is being returned, we run the risk that the handle will outlive the object it refers to. But this doesn\u0026rsquo;t mean we should never have a member function that returns a handle. Sometimes we have to - an exception is operator[] in string and vector, which works by returning references to the data in the containers (item 3), and that data will be destroyed when the containers themselves are.\n P.S.: by the way, we generally think of an object\u0026rsquo;s \u0026ldquo;internals\u0026rdquo; as its data members, but member functions not accessible to the general public (private and protected ones) are part of an object\u0026rsquo;s internals, too. Thus it\u0026rsquo;s important not to return handles to them (i.e., never have a member function return a pointer to a less accessible member function), otherwise the access level will be that of the more accessible function, just like how the risk 1 shows us.\n","description":"","id":163,"section":"notes","tags":["technique","cpp"],"title":"Item-28 Avoid returning handles to object internals","uri":"https://nianze.ml/en/notes/2018/02/avoid-return-handles-to-obejct-internals/"},{"content":"Avoid casts and develop a cast-free alternative whenever practical, especially dynamic_cast in performance-sensitive code.\nCasts subvert the C++ type system, so it is a feature we want to approach with great respect.\nCast style There are three different ways to write the same cast:\n  C-style casts:\n1  (T) expression // cast expression to be of type T     Function-style casts\n1 2  T(expression) // There\u0026#39;s no difference in meaning between C-style and function-style casts.  // Both of them are old-style casts     C++-style casts (new-style casts)\n1 2 3 4  const_cast\u0026lt;T\u0026gt;(expression) dynamic_cast\u0026lt;T\u0026gt;(expression) reinterpret_cast\u0026lt;T\u0026gt;(expression) static_cast\u0026lt;T\u0026gt;(expression)   Each serves a distinct purpose:\n const_cast is used to cast away the constness of objects, which is the only C++-style cast that can do this. dynamic_cast is primarily used to perform \u0026ldquo;safe downcasting,\u0026rdquo; i.e., to determine whether an object is of a particular type in an inheritance hierarchy. This is the only cast that cannot be performed using the old-style syntax. It is also the only cast that may have a significant runtime cost. reinterpret_cast in intended for low-level casts that yield implementation-dependent (i.e., unportable) results, e.g., casting a pointer to an int. Item 50 shows once its usage. static_cast is used to force implicit conversions (e.g., non-const object to const object (item3), int to double, etc.) as well as some reverse of such conversions (e.g., void* pointers to typed pointers, pointer-to-base to pointer-to-derived), but it cannot cast from const to non-const objects.    The good points of using new style casts are:\n new styles are much easier to identify in code for both humans and for tools like grep, thus simplifying the process of locating the code during debugging. The more narrowly specified purpose of each cast makes it possible for compilers to diagnose usage errors.  Sometimes an old-style cast may \u0026ldquo;feel\u0026rdquo; better: suppose we want to call an explicit constructor to pass an object to a function:\n1 2 3 4 5 6 7 8 9  class Widget { public: explicit Widget(int size); ... }; void doSomeWork(const Widget\u0026amp; w); doSomeWork(Widget(15)); // create Widget from in with function-style cast doSomeWork(static_cast\u0026lt;Widget\u0026gt;(15)); // cast with C++-style   However, feeling is just feeling. Code that leads to a core dump also feels pretty reasonable when we write it - we\u0026rsquo;d better ignore feelings and use new-style casts all the time.\nBehind cast Type conversions often lead to code that is executed at runtime, more than simply telling compilters to treat one type as another:\n1 2 3  int x, y; ... double d = static_cast\u0026lt;double\u0026gt;(x) / y; // divide x by y using floating point division   the cast from the int x to a double almost certainly generates code, because on most architectures, the underlying representation for an int is different from that for a double.\nLet\u0026rsquo;s see another example:\n1 2 3 4 5  class Base {...}; class Derived: public Base {...}; Derived d; Base *pb = \u0026amp;d; // implicitly convert Derived* to Base*   When creating the base class pointer to a derived class object, sometimes, depending on the various compilers, an offset may be applied at runtime to the Derived* pointer to get the correct Base* pointer value, and now a single object of type Derived now have more than one address! This can\u0026rsquo;t happen in Java, or C#, or C, but it does happen in C++, virtually all the time in the case of multiple inheritance, and some of the times under single inheritance.\nThe lesson we learn:\n we should generally avoid making assumptions about how things are laid out in C++, and certainly not perform casts based on such assumptions.\n For example: casting object addresses to char* pointers and then using pointer arithmetic on them almost always yields undefined behavior.\nAnother lesson we may learn from: many application frameworks requires that virtual member function implementations in derived classes call their base class conterparts first, and below is a wrong version to make the SpecialWindow::onResize() (derived class virtual function) to invoke its base class Window\u0026rsquo;s conterparts:\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Window { // baes class public: virtual void onResize(); // base on Resize impl  ... }; class SpecialWindow: public Window { // derived class public: virtual void onResize() { // derived onResize impl  static_cast\u0026lt;Window\u0026gt;(*this).onResize(); // cast *this to Window, then call its onResize  ... // do SpecialWindow-specific stuff  } ... };   The code casts *this to a Windnow, so the call to onResize will invoke Window::onResize. However, surprisingly, the cast will secretly create a new, temporary copy of the base class part of *this, then invoke onResize on the copy - the Window::onResize does not apply on the current object, while the SpecialWindow-specific actions apply on that object, leading to the prospect that the code will leave the current object in an invalid state, if the base class virtual function is supposed to do some modifications on current object but fails to do so.\nThe solution is to eliminate the cast, and call the base class version of onResize on the current object:\n1 2 3 4 5 6 7 8  class SpecialWindow: public Window { public: virtual void onResize() { Window::onResize(); // call Window::onResize on *this  ... } ... }   Cost of dynamic_cast One common implementatino of dynamic_cast is based in part on string comparisons of class names, so if we\u0026rsquo;re performing a dynamic_cast on an object in a single-inheritance hierarchy four levels deep, each dynamic_cast could cost us up to four calls to strcmp. A deeper hierarchy or one using multiple inheritance would be more expensive. So for performance-sensitive code, we should be especially leery of dynamic_cast.\nWhen we need dynamic_cast? Generally, the need arises because we want to perform derived class operations on a derived class object via a base pointer or base reference. Say in our Window/SpecialWindow hierarchy, only SpecialWindow supports blinking, so we may use dynamic_cast this way:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Window {...}; class SpecialWindow: public Window { public: void blink(); ... }; typedef std::vector\u0026lt;std::tr1::shared_ptr\u0026lt;Window\u0026gt;\u0026gt; VPW; // item 13 on tr1::shared_ptr  VPW winPtrs; ... for (VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter) { if (SpecialWindow *psw = dynamic_cast\u0026lt;SpecialWindow*\u0026gt;(iter-\u0026gt;get())) { psw-\u0026gt;blink(); } }   In order to eliminate the dynamic_cast, there are two approaches:\n  Use specific containers\nWe could use containers that store pointers to derived class objects directly, so that there\u0026rsquo;s no need to manipulate derived class through base class interfaces:\n1 2 3 4 5 6 7 8 9  typedef std::vector\u0026lt;std::tr1::shared_ptr\u0026lt;SpecialWindow\u0026gt;\u0026gt; VPSW; VPSW winPtrs; ... for (VPSW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter) { (*iter)-\u0026gt;blink(); }   Of course, we cannot store all possible Window derivatives in the same container under this approach, instead, we may work with multiple type-safe containers.\n  Use virtual functions\nIf we insist on manipulating all possible Window derivatives through a base class interface, we could declare a useless blink as a virtual functions in base class (if it makes sense):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Window { public: virtual void blink() {} // default impl is no-op; see item 34 for why a default impl may be a bad idea  ... }; class SpecialWindow: public Window { public: virtual void blink() {...}; // do something in blink  ... }; typedef std::vector\u0026lt;std::tr1::shared_ptr\u0026lt;Window\u0026gt;\u0026gt; VPW; VPW winPtrs; // container holds ptrs to all possible Window types ... for (VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter) { (*iter)-\u0026gt;blink(); // no dynamic_cast  }     Neigther of two approaches above are universally applicable, but they do provide a viable alternative to dynamic_cast. As long as they work, we should embrace them.\nAnother thing we want to avoid about dynamic_casts is designs that involve cascading dynamic_casts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Window {...}; ... // derived clases typedef std::vector\u0026lt;std::tr1::shard_ptr\u0026lt;Window\u0026gt;\u0026gt; VPW; VPW winPtrs; ... for (VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter) { if (SpecialWindow1 *psw1 = dynamic_cast\u0026lt;SpecialWindow1*\u0026gt;(iter-\u0026gt;get())) {...} else if (SpecialWindow2 *psw2 = dynamic_cast\u0026lt;SpecialWindow2*\u0026gt;(iter-\u0026gt;get())) {...} else if (SpecialWindow3 *psw3 = dynamic_cast\u0026lt;SpecialWindow3*\u0026gt;(iter-\u0026gt;get())) {...} ... }   This design generates code that is big and slow, and is hard to maintain, for we have to update the condition branch every time we update the base class Window. Code like this should almost always be replaced with something based on virtual funciton calls.\nIn summary, although it\u0026rsquo;s generally not practical to get rid of casts, we should use as few as possible. If we have to use them, like most suspicious constructs, we should isolate casts as much as possible, typically hide them inside functions whose interfaces shiled callers from the work inside.\n","description":"","id":164,"section":"notes","tags":["technique","cpp"],"title":"Item-27 Minimize_casting","uri":"https://nianze.ml/en/notes/2018/02/minimize-casting/"},{"content":"Postponing variable definitions as long as possible increases program clarity and improves progranm efficiency.\nAfter defining a variable of a type with a constructor or destructor, there\u0026rsquo;s a cost of construction when control reaches a variable\u0026rsquo;s definition, and a cost of destruction when the variable goes out of scope. If the variable is unused, the cost is wasted, which is the case we want to avoid.\nNobody declares unused variables on purpose, but chances are we may still encounter them unexpectedly: suppose there\u0026rsquo;s a function that returns an encrypted version of a password as long as the password is long enough and may throw an exception of type logic_error (defined in standard C++ library, item 54) if the passwod is too short:\n1 2 3 4 5 6 7 8 9 10  std::string encryptPassword(const std::string\u0026amp; password) { using namespace std; string encrypted; // definition is too soon  if (password.length() \u0026lt; MinimumPasswordLength) { throw logic_error(\u0026#34;Password is too short\u0026#34;); } ... // do whatever is necessary to place an encrypted version of password in encrypted  return encrypted; }   Apparently, the object encrypted is unused if an exception is thrown, and we still have to pay the cost of construction and destruction of encrypted.\nA better solution is to postpone encrypted\u0026rsquo;s definition until we know we\u0026rsquo;ll need it:\n1 2 3 4 5 6 7 8 9 10 11 12  std::string encryptPassword(const std::string\u0026amp; password) { using namespace std; if (password.length() \u0026lt; MinimumPasswordLength) { throw logic_error(\u0026#34;Password is too short\u0026#34;); } string encrypted; // postpones encrypted\u0026#39;s definition until it\u0026#39;s truly necessary  ... // do whatever is necessary to place an encrypted version of password in encrypted  return encrypted; }   This code still isn\u0026rsquo;t as tight as it might be, because encrypted is defined without any initialization arguments, leading to its default constructor getting called and an extra aassignment operation being used later. As item 4 suggests,\n default-constructing an object and then assigning to it is less efficient than initializing it with the value we really want it to have.\n Suppose the hard part of encryptPassword is performed in this function:\n1  void encrypt(std::string\u0026amp; s); // encrypts s in place   Then we\u0026rsquo;d better skip the pointless and potentially expensive default construction, directly initializing encrypted with password until right before we have to use the variable:\n1 2 3 4 5 6 7 8 9 10 11 12  std::string encryptPassword(const std::string\u0026amp; password) { using namespace std; if (password.length() \u0026lt; MinimumPasswordLength) { throw logic_error(\u0026#34;Password is too short\u0026#34;); } string encrypted(password); // define and initialize via copy constructor right before we have to use it  encrypt(encrypted); return encrypted; }   This gives us certain benifits:\n we avoid constructing and destructing unneeded obejcts we avoid unnecessary default constructions we help document the purpose of variables by initializing them in contexts in which their meaning is clear  Loop If a variable is used only inside a loop, should we define it outside the loop and make an assignment to it on each loop iteration, or to define the variable inside the loop？\n1 2 3 4 5 6 7  // Approach A: define outside loop Widget w; for (int i = 0; i \u0026lt; n; ++i) { w = some value dependent on i; ... }   1 2 3 4 5 6  // Approach B: define inside loop for (int i = 0; i \u0026lt; n; ++i) { Widget w(some value dependent on i); ... }   Let\u0026rsquo;s see the costs of the two approaches above:\n Approach A: 1 constructor + 1 destructor + n assignments Approach B: n constructor + n destructors  Since Approach A makes the name w visible in a larger scope than Approach B, which is contrary to program comprehensibility and maintainability, generally we choose Approach B as default, unless we know that\n assignment is less expensive than a constructor-destructor pair we\u0026rsquo;re dealing with a performance-sensitive part of our code ","description":"","id":165,"section":"notes","tags":["technique","cpp"],"title":"Item-26 Postpone variable definitions as long as possible","uri":"https://nianze.ml/en/notes/2018/02/postpone-variable-definitions/"},{"content":"When std::swap would be inefficient for your type,provide a non-throwing swap member function, a non-member swap calling the member, and possibly a specialized std::swap for the case of classes (not templates).\nswap, since its introduction into STL, is useful for exception-safe programming (item 29) and a common mechanism for coping with the possibility of assignment to self (item 11). Due to its importance, it should be implemented properly, which is exactly what this item explores about.\nCustomization By default, swapping is accomplished via the standard swap algorithm:\n1 2 3 4 5 6 7 8 9  namesapce std { template\u0026lt;typename T\u0026gt; // typical implementation of std::swap  void swap(T\u0026amp; a, T\u0026amp; b) // swaps a\u0026#39;s and b\u0026#39;s values  { T temp(a); a = b; b = temp; } }   As long as our types support copying (via copy constructor and copy assignment operator), the default swap implementation will work. However, for some types, none of these copies are really necessary. For example: there\u0026rsquo;s a common design manifestation called \u0026ldquo;pimpl idiom\u0026rdquo; (\u0026ldquo;pointer to implementation\u0026rdquo;, item 31) that consisting primarily of a pointer to another type that contains the real data:\n1 2 3 4 5 6 7 8  class WidgetImpl { // class for Widget data public: ... private: int a, b, c; std::vector\u0026lt;double\u0026gt; v; // possibly lots of data:  ... // expensive to copy };   1 2 3 4 5 6 7 8 9 10 11 12 13  class Widget { // class using the pimpl idiom public: Widget(const Widgtet\u0026amp; rhs); Widget\u0026amp; operator=(const Widget\u0026amp; rhs) //to copy a Widget,  { // copy its WidgetImpl object.  ... // for details on operator=, see item 10, 11, 12  *pImpl = *(rhs.pImpl); ... } ... private: WidgetImpl *pImpl; // ptr to object with real data };   To swap the value of two Widget objects, all we need to do is swap their pImpl pointers instead of copying three Widgets as well as three underlying WidgetImpl objects. In order to let default swap know this information, we need to specialize std::swap for Widget:\nnamespace std {\ntemplate\u0026lt;\u0026gt; // a specialized version of std::swap\nvoid swap(Widget\u0026amp; a, Widget\u0026amp; b) // for when T is Widget\n{\nswap(a.pImpl, b.pImpl); // won\u0026rsquo;t compile here\n}\n}\nThe template\u0026lt;\u0026gt; at the begining says that this is a total template specialization for std::swap, and the \u0026lt;Widget\u0026gt; after the name of the function says that the specialization is for when T is Widget, so compilter knows that when the general swap template is applied to Widgets, this is the implementation to use - although we are not allowed to alter the contents of the std namespace, it is totally fine to specialize standard templates (like swap) for our own types (such as Widget).\nHowever, this implementation won\u0026rsquo;t compile, because we can\u0026rsquo;t access the private pImpl pointers inside a and b. To solve the problem, we declare a public member function called swap that does the actual swapping, then specialize std::swap to call the member function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Widget { // same as above except for the addition of the swap mem func public: ... void swap(Widget\u0026amp; other) { using std::swap; // use the std::swap  swap(pImple, other.pImpl); // to swap Widgets, swap their pImpl pointers  } ... }; namespace std { template\u0026lt;\u0026gt; // revised version of std::swap void swap\u0026lt;Widget\u0026gt;(Widget\u0026amp; a, Widget\u0026amp; b) { a.swap(b); // to swap Wiidgets, call their swap mem func } }   This implementation will compile and be consistent with the STL container. However, if the Widget and WidgetImpl were class template instead of classes (so that we could parameterize the type of the data stored in WidgetImpl), things get more complicated:\n1 2 3 4 5  template\u0026lt;typename T\u0026gt; class WidgetImpl {...}; template\u0026lt;typename T\u0026gt; class Widget {...};   It is still easy to put a swap member function inside Widget the same way as before, but there\u0026rsquo;s a trouble with the specialization for std::swap:\n1 2 3 4 5 6 7  namespace std { template\u0026lt;typename T\u0026gt; void swap\u0026lt;Widget\u0026lt;T\u0026gt;\u0026gt;(Widget\u0026lt;T\u0026gt;\u0026amp; a, Widget\u0026lt;T\u0026gt;\u0026amp; b) // illegal code! { a.swap(b); } }   Apparently we\u0026rsquo;re partially specializing a function template std::swap here, and the problem is that, although C++ allows partial specialization of class templates, it doesn\u0026rsquo;t allow it for function templates (though some compilers may erroneously accept it).\nThe usual approach to \u0026ldquo;partially specialize\u0026rdquo; a function template is to add an overload like this:\n1 2 3 4 5 6 7  namespace std { template\u0026lt;typename T\u0026gt; // an overloading of std::swap  void swap(Widget\u0026lt;T\u0026gt;\u0026amp; a, Widget\u0026lt;T\u0026gt;\u0026amp; b) // note the lack of \u0026#34;\u0026lt;...\u0026gt;\u0026#34;  { // after \u0026#34;swap\u0026#34;  a.swap(b); } }   However, rather than overloading a common function template, what we do here is overloading a function template std::swap in the special std namesapce, where it\u0026rsquo;s not allowed to add new templates or classes or functions or anything else into it (the contens of std are determined solely by the C++ standardization committee). Even though programs that cross the line will almost certainly compile and run, their behavior is undefined.\nThus in this case, not to declare the non-member function to be a specialization or overloading of std::swap, we just make a normal non-member swap function in Widget-related namespace:\n1 2 3 4 5 6 7 8 9 10 11 12  namespace WidgetStuff { ... // templatized WidgetImpl, etc.  template\u0026lt;typename T\u0026gt; class Widget {...}; // including the swap member function  ... template\u0026lt;typename T\u0026gt; // non-member swap function  void swap(Widget\u0026lt;T\u0026gt;\u0026amp; a, Widget\u0026lt;T\u0026gt;\u0026amp; b) // not part of the std namespace  { a.swap(b); } }   The name lookup rules in C++ (specifically the rules known as argument-dependent lookup or Koenig lookup) will guarantee the Widget-specific version of swap in WidgetStuff will be invoked if any code calls swap on two Widget objects.\nUsage Let\u0026rsquo;s look from a client\u0026rsquo;s point of view and see how to use the swap. Ideally, we want to call a T-specific version of swap if there is one, but to fall back on the general version in std if there\u0026rsquo;s not. To fulfill this idea:\n1 2 3 4 5 6 7 8  template\u0026lt;typename T\u0026gt; void doSomething(T\u0026amp; obj1, T\u0026amp; obj2) { using std::swap; // make std::swap available in this function  ... swap(obj1, obj2); // call the best swap for obejcts of type T  ... }   When compilers see the call to swap, they search for the best swap to invoke - according to C++\u0026rsquo;s name lookup rules, it follows the order below:\n Find any T-specific swap at global scope or in the same namespace as the type T (if T is Widget in the namespace WidgetStuff, compilers will find swap in WidgetStuff defined above) If no T-specific swap exists, compilers will use swap in std, thanks to the using declaration that makes std::swap visible in this function.  If there\u0026rsquo;s a T-specific specialization of std::swap, use the specialized version If not, use the general swap template function.    One thing worth noting is to not qualify the call like this:\n1  std::swap(obj1, obj2); // the wrong way to call swap   here we force compilers to consider only the swap in std (including any template specializations), thus eliminating the possibility of getting a more appropriate T-specific version defined elsewhere. Alas, some misguided programmers (or even some standard library) do qualify calls to swap in this way. To make code work as efficiently as possible, we\u0026rsquo;d better totally specialize std::swap for our classes.\nSummary We\u0026rsquo;ve discussed the default swap, member swaps, non-member swaps, specializations of std::swap, and calls to swap. Below is a good practice on implementing and using customized swap:\n If the default implementation of swap offers acceptable efficiency for our class or class template, nothing needs to be done to specialize the default std::swap. If not (for class or template using some variation of the pimpl idiom):  offer a public swap member function that efficiently swaps the value of two objects of our type. This function should never throw an exception1 offer a non-member swap in the same namespace as the class or template2. Have it call the swap member function if it\u0026rsquo;s a class (not a class template), specialize std::swap for the class. Have it also call the swap member function     One of most useful applications of swap is to help classes and class templates offer the strong exception-safety guarantee (See 29 for details). Generally speaking, efficiency and non-exception are two swap characteristics that always go hand in hand, because highly efficient swaps are almost always based on operations on built-in types (such as the pointers underlying the pimpl idiom), and operations on built-in types never throw exceptions.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n The non-exception constraint can\u0026rsquo;t apply to the non-member version, because the default version of swap is based on copy construction and copy assignment, and generally both copy functions are allowed to throw exceptions.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":166,"section":"notes","tags":["technique","cpp"],"title":"Item-25 Consider support for a non-throwing swap","uri":"https://nianze.ml/en/notes/2018/02/support-for-a-non-throwing-swap/"},{"content":"If we need type conversions on all parameters to a function including the one pointed to by the this pointer, the function must be a non-member.\nHaving classes support implicit type conversions is generally a bad idea. One good and common exception to the rule is when creating numerical types, for example, we want to allow implicit conversions from integers to user-defined rationals type:\n1 2 3 4 5 6 7 8 9  class Rational { public: Rational(int numerator = 0, // ctor is deliberately not explicit,  int denominator = 1); // allowing implicit int-to-Rational conversion  int numerator() const; // accessor for numerator  int denominator() const; // accessor for denominator, see item 22 private: ... };   We\u0026rsquo;d like to support arithmetic operation of multiplication, and one way is to declare it as a member function of Rational:\n1 2 3 4 5  class Rational { public: ... const Rational operator*(const Rational\u0026amp; rhs) const; // return const: item 3; taking a reference-to-const as argument: item 20, 21 };   This design is fine to multiply rationals with rationals:\n1 2 3 4 5  Rational oneEighth(1, 8); Rational oneHalf(1, 2); Rational result = oneHalf * oneEighth; // fine result = result * oneEighth; // fine   However, for mixed-mode operations, where Rationals is multiplied with ints, there will be a potential error:\n1 2  result = oneHalf * 2; // fine result = 2 * oneHalf; // error!   This problem is clearer for analysis when we rewrite the last two examples in their equivalent functional form:\n1 2  result = oneHalf.operator*(2); // fine result = 2.operator*(oneHalf); // error!   For the first statement:\nthe object oneHalf is an instance of a class that contains an operator* taking a Rational as its argument. Compilers know we\u0026rsquo;re passing an int and that the function requires a Rational, and they also know they can conjure up a suitable Rational by implicit type conversion - calling the Rational constructor with the int we provided, so compilers will happily call that function as if it had been written like this:\n1 2  const Rational temp(2); // create a temporary Rational object from 2 result = oneHalf * temp; // same as oneHalf.operator*(temp);   Of course, compilers are allowed to do this implicit type conversion only because a non-explicit constructor is involved. If we add keyword explicit before the constructor above, neither of the two mixed-type multiplication statements would compile.\nNow for the second statement:\nit turns out that parameters are eligible for implicit type conversion only if they are listed in the parameter list. The implicit parameter pointed to by this, which is also the obejct on which the member function is invoked, is never eligible for implicit conversions. Back to the second statement, int type 2 does not have associated class containing a function operator* taking a Rational type object as its argument, nor is 2 listed in the parameter list for an implicit type conversion to Rational. That is the cause of compilation failure.\nIn fact, when compilers fail to find a matching member function, they will also look for non-member operator*s (i.e., ones at namespace or global scope) that can be called like this:\n1  result = operator*(2, oneHalf);   And this is exactly what we want if we\u0026rsquo;d like to support mixed-mode arithmetic: make opeartor* a non-member function, thus allowing compilers to perform implicit type conversions on all arguments:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Rational { ... // contains no operator* }; const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) // now a non-member function { return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); } Rational oneForth(1, 4); Rational result; result = oneForth * 2; // fine result = 2 * oneForth; // it works now   Now comes anoter worry: should operator* be made a friend of the Rational class?\nIn this case, the answer is no, because operator* can be implemented entirely through Rational\u0026rsquo;s public interface. This leads to an important observation:\n The opposite of a member function is a non-member function, not a frient function.\n There\u0026rsquo;s some misunderstanding that if a function is related to a class and should not be a member (due, for example, to type conversions on all arguments), it should be a friend. This reasoning turns out to be flawed. The basic rule is to avoid friend functions whenever we can.\n P.S.: This item contains the truth, but it is not the whole truth. When we cross the line from Object-Oriented C++ into Template C++ (item 1), and make Rational a class template instead of a class, refer to item 46 for some new issues to consider, new ways to solve them, and new design implications.\n","description":"","id":167,"section":"notes","tags":["technique","cpp"],"title":"Item-24 Declare non-member functions when type conversions should apply to all parameters","uri":"https://nianze.ml/en/notes/2018/02/when-to-declare-non-member-functions/"},{"content":"Prefer non-member non-friend functions to member functions for better encapsulation, packaging flexibility, and functional extensibility.\nSuppose there\u0026rsquo;s a class representing web browsers containing following three functions:\n1 2 3 4 5 6 7 8  class WebBrowser { public: ... void clearCache(); void clearHistory(); void removeCookies(); ... };   Clients may want to perform these three actions together, so WebBrowser might offer two ways to achieve the goal:\n Add a member function  1 2 3 4 5 6  class WebBrowser { public: ... void clearEverything(); // calls clearCache(), clearHistory(), and removeCookies()  ... };    Add a non-member non-friend function  1 2 3 4 5 6  void clearBrowser(WebBrowser\u0026amp; wb) { wb.clearCache(); wb.clearHistory(); wb.removeCookies(); }   As the title suggests, the non-member approach is better, and below is the reasons:\nEncapsulation If something is encapsulated, it\u0026rsquo;s hidden from view. The more something is encapsulated, the fewer things can see it, the fewer impact clients get affected by potential change, and the greater flexibility we have to change the inmplementation.\n As a coarse-grained measure of how much code can see a piese of data, we can count the number of functions that can access that data: the more functions that can access it, the less encapsulated the data.\n According to item 22, data members should all be private, so the number of functions that can access them is the number of member functions of the class plus the number of friend functions. Thus, given a member function clearEverything() (which can access not only the private data of a class, but also private functions, enums, typedefs, etc) and a non-member non-friend function clearBrower(), the latter yields greater encapsulation.\nTwo more things worth noting are:\n Friend functions have the same access to a class\u0026rsquo;s private members, hence the same impact on encapsulation. So from an encapsulation point of view, the choice is between member functions and non-member non-friend functions. (BTW, under the view point of implicit type conversion, item 24, the choice is between member and non-member functions) A function being a non-member of one class can still be a member of another class. For example, clearBrowser() could be declared as a static member function in some utility class. As long as it is not part of (or a friend of) WebBrowser, it doens\u0026rsquo;t affect the encapsulation of WebBrowser\u0026rsquo;s private members.  Packaging flexibility In C++, rather than declared in a class, a more natural approach would be to make clearBrowser() a non-member function in the same namespace as WebBrowser:\n1 2 3 4 5  namespace WebBrowserStuff { class WebBrowser {...}; void clearBrowser {...}; ... }   Unlike classes, namespace can be spread across multiple source file. For convenience functions like \u0026lsquo;clearBrowser\u0026rsquo;, this is important, because clients will generally be interested in only some of the convenience functions, and there\u0026rsquo;s no reason for them to compile all of the functions including those they don\u0026rsquo;t need. A straight forward way to separate convenience functions by their functionalities is to declare them in different header files:\n1 2 3 4 5 6  // header \u0026#34;webbrowser.h\u0026#34; - header for class WebBrowser itself // as well as \u0026#34;core\u0026#34; WebBrowser-related functionality namespace WebBrowserStuff { class WebBrowser {...}; ... // \u0026#34;core\u0026#34; related functionality, e.g.: non-member functions almost all clients need }   1 2 3 4  // header \u0026#34;webbrowserbookmarks.h\u0026#34; namespace WebBrowserStuff { ... // bookmark-related convenience functions }   1 2 3 4  // header \u0026#34;webbrowsercookies.h\u0026#34; namespace WebBrowserStuff { ... // cookie-related convenience functions }   This is exactly how the standard C++ library is organized: there are dozens of headers (e.g.: \u0026lt;vector\u0026gt;, \u0026lt;algorithm\u0026gt;, \u0026lt;memory\u0026gt;, etc.), each declaring some of the functionality in std. This allows clients to be compilation dependent only on the parts of the system they actually use (item 31 shows other ways to reduce compilation dependencies).\nOn the other side, partitioning is not possible for member functions, because a class must be defined in its entirety.\nExtensibility Putting all convenience functions in multiple header files but one namespace also means that clients can easily extend the set of convenience functions. All they have to do is add more non-member non-friend functions to the namespace, which is another feature classes can\u0026rsquo;t offer, because class definitions are closed to extension by clients. Even though clients can derive new classes, the derived classes have no access to private members in the base class, so such \u0026ldquo;extended functionality\u0026rdquo; has second-class status. Besides, as item 7 explains, not all classes are designed to be base classes.\n","description":"","id":168,"section":"notes","tags":["technique","cpp"],"title":"Item-23 Prefer non-member non-friend function to member function","uri":"https://nianze.ml/en/notes/2018/02/prefer-non-member-non-friend-function-to-member-function/"},{"content":"Declaring data members private gives clients syntactically uniform access to data, affords fine-grained access control, allows invariants to be enforced, and offers class authors implementation flexibility.\nSyntactic consistency If data member aren\u0026rsquo;t public, the only way for clients to access an object is via member functions. If everything in the public interface is a function, clients know they will always use parentheses when accessing a member of the class, which is called \u0026ldquo;sysntactic consistency\u0026rdquo;.\nPricise control over the accessibility If we use functions to get or set data member\u0026rsquo;s value, we can implement multiple levels of accessibility:\n1 2 3 4 5 6 7 8 9 10 11 12 13  class AccessLevels { public: ... int getReadOnly() const { return readOnly; } int getReadWrite() const { return readWrite; } void setReadWrite(int value) { readWrite = value; } void setWriteOnly(int value) { writeOnly = value; } private: int noAccess; // no access to this int  int readOnly; // read-only access to this int  int readWrite; // read-write access to this int  int writeOnly; // write-only access to this int };   Since it is rare that every data member need a getter and setter, such fine-grained access control is important.\nEncapsulation Encapsulation offers class authors implementation flexibility. Through a function, we can replace a data member with a computationi while nobody using the interface notice the change. For example, suppose we are writing an application monitoring the speed of passing cars, and each passing car\u0026rsquo;s speed will be collected into the class:\n1 2 3 4 5 6 7  class SpeedDataCollection { ... public: void addValue(int speed); // add a new data value  double averageSoFar() const; // return average speed  ... };   There are two ways to implement the member function averageSoFar:\n have a data member in the classs that is a running average of all the speed data so far collected. averageSoFar will simply return the value of this data member. have averageSoFar compute its value anew each time it\u0026rsquo;s called by examining each data value in the collection  Both approaches have pros and cons, and decision on which to use depends on the specific use case:\n Method one makes each SpeedDataCollection object bigger for the extra data member holding the running average, the accumulated total, and the number of data points, but averageSoFar will be very efficient (it is just an inline function, see item 30). For an application where averages are needed frequently, and memory is not an issue, keeping a running average will be preferable. Method two will make averageSoFar run slower, but each SpeedDataCollection object will be smaller. Thus it is preferable in applications where memory is tight (e.g., an embedded roadside device), and where averages are needed only infrequently  The point is, by encapsulating the average through a member function, we can interchange different implementations, and clients will only have to, at most, recompile (we can even eliminate recompilation by the technique described in item 31). Since only member functions can affect data members, it is ensured that the class invariants are always maintained. Moreover, through function interfaces, we have flexibility for extra capabilities with ease (similar concept of \u0026ldquo;properties\u0026rdquo; in Delphi and C#, albeit with the need to type an extra set of parentheses):\n to notify other objects when data members are read or written to verify class invariants and function pre-and postconditions to perform synchronization in threaded environments  On the other side, if we don\u0026rsquo;t encapsulate data members from clients, we give up the right to change our future implementation decisions. Even if we own the source code to a class, our ability to chagne anything public is extremely restricted, because too much client code will be broken. Public means unencapsulated, and unencapsulated means unchangeable, which is especailly true for widely used classes.\nprotected data members The argument above is also applicable for protected data members. In fact, no only the reasoning about syntactic consistency and fine-grained access control is applicable, the argument on encapsulation is also true for them:\nsuppose we eliminate a protected data member, and then all the derived classes using it, typically in an unknowably large amount of size, will be broken, which is exactly the same case for public data members used by large number of different clients.\nThus, from an encapsulation point of view, there are really only two access levels:\n private, which offers encapsulation everything else, which doesn\u0026rsquo;t ","description":"","id":169,"section":"notes","tags":["technique","cpp"],"title":"Item-22 Declare data members private","uri":"https://nianze.ml/en/notes/2018/02/declare-data-members-private/"},{"content":"Never return a pointer or reference to a local stack object, a refenrence to a heap-allocated object, or a pointer or reference to a local static object if there is a change that more than one such object will be needed (item 4 provides a \u0026ldquo;counter\u0026rdquo; example that is reasonable in single-threaded environments).\nCase Study There are some situations where we must return an object, no matter how much effort we want to put into rooting out the evil of pass-by-value to pursue the heighest efficiency. Otherwise, we may invariably make a fatal mistake: pass references to objects that don\u0026rsquo;t exist.\nConsider following class for representing rational numbers with a multiplying function:\n1 2 3 4 5 6 7 8 9 10 11 12  class Rational { public: Rational(int numerator = 0, // see item 24 for why this  int denominator = 1); // ctor isn\u0026#39;t declared explicit ... private: int n,d; // numerator and denominator friend: const Rational // see item 3 for why the return type is const  operator**(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs); };   We may want to remove the cost of construction and destruction from return-by-value, considering using return by reference instead. However, a reference is just a name for some existing object. In the case of opeartor*, the product of the two object does not exist before we call the function, so if operator* want to return a reference to the product, it must create the result itself.\nA function can create a new object in only two ways: on the stack or on the heap.\nReturn a pointer or reference to a local stack object Creation on the stack is accomplished by defining a local variable:\n1 2 3 4 5  const Rational\u0026amp; operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) // bad code ! { Rational result(lhs.n * rhs.n, lhs.d * rhs.d); return result; }   There\u0026rsquo;s a serious problem: the function returns a reference to result, which is a local object, and local objects are destroyed when the function exits, ending to return a reference to an ex-Rational. Any caller glancing at this return value would instantly enter the realm of undefined behavior.\nThe fact is, any function returning a reference (or a pointer) to a local object is brocken.\nReturn a reference to a heap-allocated object Heap-based objects come into being through the use of new, so the heap-based opearator* looks like this:\n1 2 3 4 5  const Rational\u0026amp; operation*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) // bad code ! { Rational *result = new Raional(lhs.n * rhs.n, lhs.d * rhs.d); return *result; }   Now comes a different problem: who will apply delete matching the use of new?\nEven if callers are conscientious and well intentioned, there\u0026rsquo;s not much they can do to prevent leaks in reasonable usage scenarios like this:\n1 2 3  Rational x, y, z; Rational w = x * y * z; // same as operator*(operator*(x,y),z)   There are twoe uses of new that need to be undone with uses of delete. Yet there\u0026rsquo;s no reasonable way for clients to get at the pointers hidden behind the references being returned from the calls to operator* and make calls to delete. This is a guaranteed resource leak.\nReturn a reference to a local static object If, however, we jump outside of the box, considering returning a reference to a static Rational, and think that this will avoid all but one initial constructor call without suffering from calling a constructor for each product result returned from operatior* in above on-the-stack and on-the-heap approaches:\n1 2 3 4 5 6  const Rational\u0026amp; operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) // bad code ! { static Rational result; // static object  result = ...; // put the product inside result  return result; }   Like all designs employing the use of static objects, this one immediately raises thread-safety hackles, but there\u0026rsquo;s a deeper flaw: consider following perfectly reasonable client code:\n1 2 3 4 5 6 7 8  bool operator==(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs); Rational a,b,c,d; ... if ((a * b) == (c * d)) { // do whatever appropriate when the products are equal } else { // do whatever appropriate when the products are unequal }   Problem here is that the expression ((a * b) == (c * d)) will always evaluate to true, regardless of the values of a, b, c, and d.\nLet\u0026rsquo;s rewrite the code in its equivalent functional form to understand what happened:\n1  if (operator==(operator*(a, b), operator*(c, d)))   When operator== is called, there will already be two active calls to opearator*, each of which will return a reference to the static Rational object inside opeartion*, which, as is a static local object, will always be the exact one, with same value.\nSome may ask,\n Well, if one static isn\u0026rsquo;t enough, maybe a static array will do the trick\u0026hellip;\n The problem is, however, it is very hard to implement this arry of size n:\n if n is too small, we may run out of places to store return values and fall back to the single-static design situation; if n is too big, we\u0026rsquo;ll decrease the performance of the program, because every object in the array will be constructed the first time the function is called - a cost of n constructors and equally n destructors even if the function is called only once. how to put the values we need into the array\u0026rsquo;s objects and what is the cost. The most direct way is via assignment, which cost the same as a call to a destructor (to destroy the old value) plus a call to a constructor (to copy over the new value) how to decide the position of target result in the array  The right way: return by value The right way to write a function that must return a new object is to have that function reutrn a new object like this or something essentially equivalent:\n1 2 3 4  inline const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { return Rational(lhs.n * rhs.n, lhs.d * rhs.d); }   In the long run, the cost of constructing and destructing operator*\u0026rsquo;s return value is a small price to pay for correct behavior. What\u0026rsquo;s more, since C++ allows compiler implementers to apply optimizations to immprove the performance of the generated code, it turns out that in some cases, construction and destruction of operator*\u0026rsquo;s return value can be safely eliminated, so the program will run faster than we expect and still behave correctly as it\u0026rsquo;s supposed to be.\nIn summary, when deciding between returning a reference and returning an object, we should make choice that offers correct behavior.\n","description":"","id":170,"section":"notes","tags":["technique","cpp"],"title":"Item-21 Don't return a reference when we have to return an object","uri":"https://nianze.ml/en/notes/2018/02/do-not-return-a-ref-when-must-return-an-object/"},{"content":"Pass by reference-to-const is typically more efficient than pass by value and avoids the slicing problem.\nPass-by-value can be an expensive operation. For example, consider the following class hierarchy:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Person { public: Person(); // parameters omitted for simplisity  virtual ~Person(); // item 7 explains why virtual  ... private: std::string name; std::string address; }; class Student:public Person { public: Student(); // parameters omitted for simplisity  ~Student(); ... private: std::string schoolName; std::string schoolAddress; };   Now consider what will happen if we call a function validateStudent, which takes a Student argument (by value) and returns whether it is a real student:\n1 2 3  bool validateStudent(Student s); // pass a Student object by value Student plato; bool platoIsOK = validateStudent(plato); // call the function   A Student object has two string object within it, while its base class Person contains two additional string type data members. So the parameter-passing cost of this function is one call to the Student copy constructor matched with two string copy constructor, and one call to the base class Person\u0026rsquo;s copy constructor, which also entails two more string construction. When the Student object is destroyed, each constructor call is matched by a destructor call. Overall, the cost of passing a Student by value is six constructors and six destructors.\nIt would be nice is there were a way to bypass all those constructions and destructions. The answer is: pass by reference-to-const:\n1  bool validateStudent(const Student\u0026amp; s);   Since no new objects are being created, there\u0026rsquo;s no constructor or destructor call. The const in the revised parameter declaration is important, for it guarantees that the callers would not worry about validateStudent making changes to the Student they passed in (when passing by value, validateStudent would be able to modify only a copy of the Student they passed in, so the callers know they are shielded from any changes the function might make to the Student).\nApart from efficiency, passing parameters by reference also avoids the slicing problem: when a derived class object is passed (by value) as a base class object, the base class copy constructor is called, and the extra features in derived class object are \u0026ldquo;sliced\u0026rdquo; off. For example:\n1 2 3 4 5 6 7 8 9 10 11 12  class Window { public: ... std::string name() const; // return name of window  virtual void display() const; // draw window and contents }; class windowWiScroBars: public Window { public: ... virtual void display() const; };   Below is a bad example if you want to write a function to print out a window\u0026rsquo;s name and then display the window:\n1 2 3 4 5  void printNameAndDisplay(Window w) { std::cout \u0026lt;\u0026lt; w.name(); w.displey(); }   When you call this functiona with a WindowWithScrollBars object:\n1 2  WindowWithScrollBars wwsb; printNameAndDisplay(wwsb);   Since it is passed by value, the parameter w will be constructed as a Window object. Regardless of the type of object passed to the function, inside printNameAndDisplay, w will act like an object of class Window (it is an object of class Window after all), and all the specialized information that made wwsb act like a WindowWithScrollBars object will be sliced off.\nHowever, if we revised the function declaration like this:\n1 2 3 4 5  void printNameAndDisplay(const Window\u0026amp; w) // fine, parameter won\u0026#39;t be sliced { std::cout \u0026lt;\u0026lt; w.name(); w.display(); }   Now w will act like whatever kind of window is actually passed in.\nException In general, the only types for which we can reasonably assume that pass-by-value is inexpensive are:\n built-in types STL iterator function object types  Under the hood of the C++ compiler, a reference is implemented as pointers, so passing by reference usually means passing a pointer. This is why for built-in types (e.g., an int), it\u0026rsquo;s more efficient to pass it by value than by reference. Also, iterators and function objects in the STL are more efficient to copy and are not subject to the slicing problem because they are designed to be passed by value (this is an example where rules change depending on which part of C++ we are using, see item 0).\nOn the other hand, we can not conclude that all small types are necessarily good pass-by-value candidate:\n  the user-defined types, despite being small in terms of size, may have expensive copy constructors, such as most STL containers that contain little more than a pointer but leading to copying everything they point to when applying copying operation.\n  even if the copy constructors are inexpensive, compilers may treat user-defined small types differently with buiilt-in types: for example, some compilters refuse to put objects consisting of only a double into a register, even though they will happily place naked doubles there, so we can be better off passing such objects by reference, for compilers will certainly put pointers (the implementation of references) into registers.\n  a type that is small now may be bigger in a future release, for its internal implementation may change; things can even change when we switch to a different C++ implementation, for example, some implementations of the standard library\u0026rsquo;s string type are seven times as big as others.\n  In summary, for everything else other than built-in types and STL iterator and function object types, follow the advice and prefer pass-by-reference-to-const over pass-by-value.\n","description":"","id":171,"section":"notes","tags":["technique","cpp"],"title":"Item-20 Perfer pass-by-reference-to-const to pass-by-value","uri":"https://nianze.ml/en/notes/2018/02/perfer-pass-by-reference-to-const/"},{"content":"Before definining a new type, be sure to consider all the issues discussed in this item.\nIn object-oriented programming wolrd, defining a new class defines a new type, yet designing good types is challenging. Good types have a natural syntax, intuitive semantics, and one or more efficient implementations. To disign effective classes, we must understand the issues we face, and ask ourselves the following questions to constrain the design:\n  How should objects of the new type be created and destroyed?\nThis influences the desiggn of the class\u0026rsquo;s constructors and destructors, as well as memory allocation and deallocation functions(operator new, operator new[],operator delete,operator delete[])\n  How should object initialization differ from object assignment?\nThie determines the behavior of constructor (for initialization) and assignment operator (for assignment).\n  What does it mean for objects of the new type to be passed by value?\nCopy constructor defines how pass-by-value is implemented for a type.\n  What are the restrictions on legal values for the new type?\nValid combinations of values for a class\u0026rsquo;s data member may require some error checking inside member functions such as constructors, assignment operators, and \u0026ldquo;setter\u0026rdquo; functions. It may also affect the exceptions (as well as related exception specification) thrown by member functions.\n  Does the new type fit into an inheritance graph?\nIf the class is inherited from existing classes, it is constrained by the base class (particularly by base class\u0026rsquo;s design on virtual or non-virtual, item 34, 36). If the class will be base class of other classes, we should consider whether to declare the functions as virtual or not (especially the destructor, item 7).\n  What kind of type conversions are allowed for the new type?\n If we wish to allow object of type T1 to be implicitly converted into objects of type T2, we need to write either a type conversion function in class T1 (e.g., operator T2) or a non-explicit constructor in class T2 that can be called with a single argument. If we wish to allow explicit conversions only, we need to write functions to perform the conversions and avoid making type conversion operators or non-explicit constructors with only one argument (item 15).    What operators and functions make sense for the new type?\nThis determines which functions will be member functions and which not (item 23, 24, 46).\n  What standard functions should be disallowed?\nThis determines the standard functions declared as private (item 6).\n  Who should have access to the members of the new type?\nThis determines if a member is public, protected, or private. It also determines which classes and/or functions should be friends, as welll as to nest one class inside another.\n  What is the \u0026ldquo;undeclared interface\u0026rdquo; of the new type?\nThis guarantees the performance, exception safety (item 29), and resource usage (e.g., locks and dynamic memory) clients will expect, which will impose constraints on the class implementation.\n  How general is the new type?\nIf we\u0026rsquo;re defining a whole family of types, we may want to define a new class template instead of a new class.\n  Is a new type really what we need?\nIf a new derived class is only added into some functionality to an existing class, maybe a simple definition of one or more non-member functions or templates will be better approach.\n  Once these questions solved properly, user-defined classes in C++ yield types that are at least as good as the built-in types, which makes all the effort worthwhile.\n","description":"","id":172,"section":"notes","tags":["technique","cpp"],"title":"Item-19 Treat class design as type design","uri":"https://nianze.ml/en/notes/2018/02/class-design-is-type-design/"},{"content":"Good interfaces are easy to use correctly and hard to use incorrectly.\nTo design a good interface, it\u0026rsquo;s always good to make the interface in consistency and behave in compatibility with built-in types. After all, clients already know how types like int behave, so we should strive to make our types behave the same way. A good (though not perfect) example is the interface to STL containers: every STL container has a member function named size that tells how many objects are in the container. On the contrary, in Java, we use the length property for arrays, the length method for Strings, and the size method for Lists; as for .Net, Arrays have a property named Length, while ArrayLists have a property named Count. No matter how convenient modern IDEs may be, inconsistency imposes mental fricition into a developer\u0026rsquo;s work.\nA good way to think of the interface design is to consider the kinds of mistakes that clients might make, and we could try the following 4 ways:\n Creating new types Constraining object values Restricting operations on types Eliminating client resource management responsibilities  Creating new types Say we\u0026rsquo;re designing the constructor for a class representing dates in time:\n1 2 3 4  class Date { public: Date(int month, int day, int year); };   There at least two possible errors that clients might easily make:\n  the parameters might be passed in the wrong order:\n1  Date d(30, 3, 1995); // Should be \u0026#34;3, 30\u0026#34;     the parameters might be invalid \u0026lt;month, day\u0026gt; pair:\n1  Date d(2, 30, 1995); // In the keyboard, `2` is next to \u0026#39;3\u0026#39;, so this kind of silly error is not uncommon     To prevent such kind of client errors, we could introduce new types:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  struct Day { explicit Day(int d) :val(d){} int val; }; struct Month { explicit Month(int m) :val(m){} int val; }; struct Year { explicit Year(int y) :val(y){} int val; }; class Date { public: Date(const Month\u0026amp; m, const Day\u0026amp; d, const Year\u0026amp; y); ... };   This will prevent some silly interface usage errors effectively:\n1 2 3  Date d(30, 3, 1995); // error: wrong type! Date d(Day(30), Month(3), Year(1995)); // error: wrong type! Date d(Month(3), Day(30), Year(1995)); // fine   Constraining object values Once the type is right, we may consider adding some restriction on the values of those types. The Month in example above only has 12 valid values, so the Month type should reflect this restriction. One way is to use an enum to represent the month, but considering enums can be used like ints (item 2), it is not as type-safe as we might like. A safer solution is to predefine the set of all valid Months:\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Month { public: static Month Jan() {return Month(1);} // functions returning all  static Month Feb() {return Month(2);} // valid Month values  ... static Month Dec() {return Month(12);} ... private: explicit Month(int m); // prevent creation of new Month values  ... // month-specific data }; Date d(Month::Mar(), Day(30), Year(1995));   The reason to use functions (returning local static objects) instead of (non-local static) objects to represent specific months is explained in item 4:\n the relative order of initialization of non-local static objects defined in different translation units is undefined.\n Restricting operations on types A good example for restricting operations on types is in item 3 explaining how const qualifying the return type from operator* can prevent clients from making following errors for user-defined types:\n1  if (a * b = c)... // meant to do a comparison   Again, it is always good to have our types behave consistently with the built-in types. Such kind of operation is illegal for int type, so unless there\u0026rsquo;s a good reason, it should be illegal for our types, too.\nEliminating client resource management responsibilities Any interface that requires that client remember to do something is prone to incorrect use. A bad example is function createInvestment in item 13, which returns pointers to dynamically allocated objeects in an Investment hierarchy.\n1  Investment* createInvestment(); // parameters omitted for simplicity   Needless to say, this is prone to resource leak, for chances are that clients either forget to manually delete the pointer, or delete the same pointer more than once\nItem 13 shows that we could preempt this problem by using smart pointers. But a better solution is to let the function createInvestment return a smart pointer in the first place:\n1  std::tr1::shared_ptr\u0026lt;Investment\u0026gt; createInvestment();   Moreover, returning a tr1::shared_ptr makes it possible to prevent a host of other client errors regarding resource release, for tr1::shared_ptr allows a resource-release function (called a \u0026ldquo;deleter\u0026rdquo;) to be bound to the smart pointer when the smart pointer is created (item 14, auto_ptr does not support this functionality).\nFor example, instead of using delete to release an Investment object resource, clients may expect to use a function called getRidOfInvestment. By binding getRidOfInvestment to tr1::shraed_ptr as its deleter, and return this smart pointer, clients will not make mistakes such as using the wrong resource-destruction mechanism (using delete instead of getRidOfInvestment).\nThus, in order to bind the deleter, we could define a null tr1::shared_ptr with getRidofInvestment as its second argument (the first argument is null because we may not be sure the resource to be managed during initialization), and implement createInvestment like this:\n1 2 3 4 5 6 7 8  std::tr1::shared_ptr\u0026lt;Investment\u0026gt; createInvestment() { std::tr1::shared_ptr\u0026lt;Investment\u0026gt; // return a null shared_ptr  retVal(static_cast\u0026lt;Investment*\u0026gt;(0), // see item 27 for static_cast  getRidOfInvestment); // bind a custom deleter  ... // make retVal point to the correct object  return retVal; }   Since tr1::shared_ptr insists on an actual pointer, we use a cast to solve the problem. Of course, it would be better to pass the raw pointer to the smart pointer\u0026rsquo;s constructor if the raw pointer to be managed by retVal could be determined prior to creating retVal, rather than to initialize retVal to null and then making an assignment to it (item 26).\nWhat\u0026rsquo;s more, another nice feature of tr1::shared_ptr is that it automatically uses its per-pointer deleter to release resource, which eliminates the \u0026ldquo;cross-DLL problem\u0026rdquo; that shows up when an object its created using new in one dynamically linked library (DLL) but is deleted in a different DLL, leading to runtime errors. For example, if Stock is a class derived from Investment and createInvestment is implemented like this:\n1 2 3 4  std::tr1::shared_ptr\u0026lt;Investment\u0026gt; createInvestment() { return std::tr1::shared_ptr\u0026lt;Investment\u0026gt;(new Stock); }   the returned tr1::shared_ptr pointing to the Stock keeps track of which DLL\u0026rsquo;s delete should be used when the reference count for the Stock becomes zero, so there\u0026rsquo;s no more concern for the cross-DLL problem.\nThe most common implementation of tr1::shared_ptr comes from Boost (item 55). Since it is such an easy way to eliminate some client errors, it\u0026rsquo;s worth an overview of the cost of using it: Boost\u0026rsquo;s shared_ptr is twice the size of a raw pointer, uses dynamically allocated memory for bookkeeping and deleter_specific data, uses a virtual function call when invoking its deleter, and incurs thread synchronization overhead when modifying the reference count in an application it believes is multithreaded.\nAlthough compared to a raw pointer, the tr1::shared_ptr is bigger, slower, and uses auxiliary dynamic memory, the reduction in client errors will be apparent， and the additional runtime costs will be unnoticeable in many applications.\n","description":"","id":173,"section":"notes","tags":["technique","cpp"],"title":"Item-18 Make interfaces easy to use correctly and hard to use incorrectly","uri":"https://nianze.ml/en/notes/2018/02/make-interfaces-easy-to-use-correctly/"},{"content":"Failure to do this can lead to subtle resource leaks when exceptions are thrown.\nSuppose there\u0026rsquo;re two functions:\n1 2  int priority(); // reveal processing priority void processWidget(std::tr1::shared\u0026lt;Widget\u0026gt; pw, int priority); // do some processing on a dynamically allocated `Widget` in accord with the priority above   Apparently, following code won\u0026rsquo;t compile:\n1  processWidget(new Widget, priority());   This is because tr1::shared_ptr\u0026rsquo;s constructor taking a raw is explicit, there\u0026rsquo;s no implicit conversion from the raw pointer (returned by new Widget) to the tr1::shared_ptr (required by processWidget).\nHowever, even though the code below does compile, seems correct, and carefully uses shared_ptr to manage resource, it may still leak resources:\n1  processWidget(std::tr1::shared_ptr\u0026lt;Widget\u0026gt;(new Widget), priority());   The two arguments as function parameters must be evaluated before a call to processWidget is generated, and the first argument actually consists of two parts:\n execution of the expression new Widget call to the tr1::shared_ptr constructor  Thus, before processWidget can be called, following three steps must take place:\n Call priority Execute new Widget Call the tr1::shared_ptr constructor  Unlike Java and C#, where function parameters are always evaluated in a particular order, C++ compilers are free to decide the order of steps above. Although new Widget must take place before tr1::shared_ptr constructor can be call (for the result of new operation is the argument of the smart pointer\u0026rsquo;s constructor), the call to priority() can be performed first, second, or third. If compilers choose to perform it second (maybe for efficiency consideration):\n Execute new Widget Call priority Call tr1::shared_ptr constructor  The problem here is that, once the call to priority yields an exception, the pointer returned from new Widget has not turned over to the resource-managing object, and resource leaks.\nLuckily, it is very simple to avoid this problem: use a separate statement to create Widget and store it in a smart pointer, then pass the smart pointer to processWidget:\n1 2  std::tr1::shared_ptr\u0026lt;Widget\u0026gt; pw(new Widget); // standalone statement processWidget(pw, priority()); // won\u0026#39;t leak   Now the new Widget expression and the call to tr1::shared_ptr constructor are in a different statement from the call to priority, compilers are not allowed to move the call to priority between them.\n","description":"","id":174,"section":"notes","tags":["technique","cpp"],"title":"Item-17 Store newed objects in smart pointers in standalone statements","uri":"https://nianze.ml/en/notes/2018/02/store-newed-objects-in-smart-pointers-in-standalone-statements/"},{"content":"If you use [] in a new expression, use [] in the corresponding delete expression; If not, no [] in the matching delete expression.\nWhen employing a new expression, two things happen:\n membory is allocated (via the function operator new, item 49, 51) one or more constructors are called for that memory  When a delete is used, two other things happen:\n one or more destructors are called for the memory The memory is deallocated (via the function operator delete, item 51)  The fact is that the memory layout for single objects is generally different from the memory layout for arrays, and the memory for an array usually includes extra area for the size of the array (making it easier for delete to know how many destructor to call) while memory for a single object lacks this information:\n   Memory type Memory layout     Array |n|Object|Object|Object|\u0026hellip;|   Single object |Object|    When we use delete on a pointer, delete [] will assumes an array is pointed to, otherwise it assumes a single object. Let\u0026rsquo;s see what will happen if the uses of new and delete is not matching:\n1 2  std::string *stringPtr1 = new std::string; std::string *stringPtr2 = new std::string[100];     delete [] stringPtr1;\nThe result is undefined. delete will read some memory and interpret what it read as an array size, then start invoking the destructors, and it\u0026rsquo;s probably not holding the objects of the type it\u0026rsquo;s busy destructing at this point.\n  delete stringPtr2;\nIt\u0026rsquo;s undefined behavior too. It\u0026rsquo;s easy to see the expression would lead to too few destructors being called. Furthermore, it\u0026rsquo;s also undefined for built-in types (which lack destructors), too.\n  The rule is particularly important to bear in mind when writing a class containing a pointer to dynamically allocated memory and also offering multiple constructors, for we must be careful to use the same form of new in all the constructors to initialize the pointer member. After all, there\u0026rsquo;s only one form of delete in the destructor.\nThe rule is also noteworthy for typedef-inclined:\n1 2 3 4 5  typedef std::string AddressLines[4]; // a person\u0026#39;s address has 4 lines std::string *pal = new AddressLines; // return type is string*, just like \u0026#34;new string[4]\u0026#34; would  delete pal; // undefined! delete [] pal; // fine, array form of delete is the matched version   To avoid such confusion, abstain from typedefs for array types. Try using string and vector from the standard C++ library (item 54) - those templates reduce the need for dynamically allocated arrays to nearly zero: for example, we may define AddressLines as type vector\u0026lt;string\u0026gt;.\n","description":"","id":175,"section":"notes","tags":["technique","cpp"],"title":"Item-16 Use the same form in corresponding uses of new and delete","uri":"https://nianze.ml/en/notes/2018/02/use-the-same-form-in-matching-new-and-delete/"},{"content":"Each RAII class should offer a way to get at the resource it manages.\nFrom time to time, some APIs require access to raw resources, so it is a good habit to design the resource-managing classes in such a way that it provides access to raw resources. For example, suppose there\u0026rsquo;s a function we\u0026rsquo;d like to use with Investment objects, which is managed by smart pointer:\n1 2 3  int daysHeld(const Investment *pi); // return number of days investment has been held  std::tr1::shared_ptr\u0026lt;Investment\u0026gt; pInv(createInvestment()); // item 13   Since dayHeld wants a raw Investment* pointer, if passing an object of type tr1::shared_ptr\u0026lt;Investment\u0026gt;, the code won\u0026rsquo;t compile:\n1  ind days = daysHeld(pInv); // error   We need to find a way to get the access to the raw resources, and generally there are two ways:\n Implicit conversion (convenient for clients) Explicit conversion (generally preferred)  Implicit conversion Pointer dereferencing operators (operator-\u0026gt; and operator*) are implicit conversion to the underlying raw pointers, which is virtually provided by all smart pointer classes. Suppose there\u0026rsquo;s a member function bool isTaxFree() inside the class Investment, and we can access the member function like this:\n1 2 3  bool taxable1 = !(pInv-\u0026gt;isTaxFree()); // access resource via operator-\u0026gt;  bool taxable2 = !((*pInv).isTaxFree()); // access resource via operator*   When it is necessary to get at the raw resource inside an RAII object, another way of conversion is through an implicit conversion function. Consider following RAII class for fonts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  FontHandle getFont(); // from C API void releaseFont(FontHandle fh); // from the same C API  class Font { // self-defined RAII class public: explicit Font(FontHanlde fh) // acquire resource  : f(fh) // use pass-by-value because the C API does  {} ~Font() { releaseFont(f); } // release resource  operator FontHandle() const {return f;} // implicit conversion function  private: FontHandle f; // the raw font resource };   This makes calling into the following C API easy and natural:\n1 2 3 4 5 6  void changeFontSize(FontHandle f, int newSize); // the C API  Font f(getFont()); int newFontSize; ... changeFontSize(f, newFontSize); // implicitly convert Font to FontHandle   However, the downsize is that implicit conversions increase the chance of errors - a FontHandle may be created when a Font is really intended:\n1 2 3 4  Font f1(getFont()); ... FontHandle f2 = f1; // meant to copy a Font object but implicitly converted f1 into  // FontHandle, and copied the underlying resource   Explicit conversion In order to avoid unintended implicit conversion, an explicit conversion function like get is a preferable path. We can exchange the implicit convertion function to following explicit one:\n1 2 3 4 5 6 7 8  class Font { ... FontHandle get() const { return f; } // explicit conversion function ... }; ... // and use it like this: changeFontSize(f.get(), newFontSize); // explicitly convert Font to FontHandle   Both explicit conversion and implicit conversion make sense, and the preference depends on the specific task and the circumstances in which the RAII class performs, as long as one adheres to item 18\u0026rsquo;s advice: to make interfaces easy to use correctly and hard to use incorrectly.\n","description":"","id":176,"section":"notes","tags":["technique","cpp"],"title":"Item-15 Provide access to raw resource in resource-managing classes","uri":"https://nianze.ml/en/notes/2018/02/provide-access-to-raw-rsc/"},{"content":"Copying an RAII object entails copying the resource it manages, so the copying behavior of the resource determines the copying behavior of the RAII object.\nWe can use auto_ptr and tr1::shared_ptr to manage heap-based resources, as introduced in item 13. However, not all resources are heap-based, and for such resources, we need to create our own resource-managing classes to deal with a general question:\n what should happen when an RAII object is copied?\n Mostly, there are 4 possibal choices:\n1. Prohibit copying In some cases, it makes no sense to allow RAII objects to be copied, so we should prohibit it. As explained in item 6, we declare the copying operations private without definition. A good example is class Mutex, which is synchronization primitives and comes with two functions lock and unlock:\n1 2 3  void lock(Mutex *pm); // lock mutex pointed to by pm  void unlock(Mutex *pm); // unlock the mutex   We should not forget to unlock a Mutex we\u0026rsquo;ve locked, and it rarely makes sense to have \u0026ldquo;copies\u0026rdquo; of synchronization privitives, so we can create an uncopyable class to manage the locks:\n1 2 3 4 5 6 7 8 9 10 11  class Lock: private Uncopyable { // prohibit copying, see item 6 public: explicit Lock(Mutex *pm) : mutexPtr(pm) { lock(mutexPtr); } // acquire resource  ~Lock() { unlock(mutexPtr); } // release resource  private: Mutex *mutexPtr; };   And we can use Lock in the conventional RAII fashion:\n1 2 3 4 5 6 7 8 9 10 11 12  Mutex m; // define the mutex ... { // create block to define critical section  Lock ml(\u0026amp;m); // lock the mutex  ... // perform critical section operations  // Lock ml2(ml); this is prohibited behavior! } // automatically unlock mutex at end of block    2. Reference-count the underlying resource Sometimes it\u0026rsquo;s desirable to hold on to a resource until the last object using it has been destroyed. We could implement reference-counting copying behavior by containing a tr1::shared_ptr data member, but in some cases we may have to customize the behavior when the reference count goes to zero, for the default behavior is to call delete.\nThe way we customize tr1::shared_ptr is to specify a \u0026ldquo;deleter\u0026rdquo; - a function or function object to be called when the reference count goes to zero (auto_ptr does not give us this privilege), which is an optional second parameter to the tr1::shared_ptr constructor:\n1 2 3 4 5 6 7 8 9 10 11  class Lock { public: explicit Lock(Mutex *pm); // init shared_ptr with the Mutex  : mutexPtr(pm, unlock) // to point to and the unlock func as the deleter  { lock(mutexPtr.get()); // see item 15 for info on \u0026#34;get\u0026#34;  } private: std::tr1::shared_ptr\u0026lt;Mutex\u0026gt; mutexPtr; // use shared_ptr instead of raw pointer };   Since a class\u0026rsquo;s destructor (both user-defined ones and compilter-generated ones) automatically invokes the destructors of the class\u0026rsquo;s non-static data members, there\u0026rsquo;s no need to declare a destructor for class Lock explicitly (item 5). We simply rely on the default compilter-generated behavior, and that\u0026rsquo;s enough.\n3. Copy the underlying resource Sometimes we want to copy the resource-managing object as well as the resource it wraps, - that is to say, we want the resourse-managing object to perform a \u0026ldquo;deep copy\u0026rdquo;. A good example is the standard string type: in sompe implementation, a string type object consists of a pointer to heap memory, where the charactors making up the string are stored, and a copy is made of both the pointer and the memory it points to when such an object get copied.\n4. Transfer owenership of the underlying resource On rere occasions, we wish only one RAII object refers to a raw resource and the ownership of the resource is transfered from the copied object to the copying object, as is the meaning of \u0026ldquo;copy\u0026rdquo; used by auto_ptr.\nIn this situation, we may have to write our own version of copying functions (copy constructor and copy assignment operator), since the default compiler-generated ones may not do what we want. In some cases, we\u0026rsquo;ll also want to support generalized versions of copying functions, which is discussed in item 45.\n","description":"","id":177,"section":"notes","tags":["technique","cpp"],"title":"Item-14 Copy behavior in resource-managing classes","uri":"https://nianze.ml/en/notes/2018/02/copy-behavior-of-raii/"},{"content":"Use RAII objects such as tr1::shared_ptr and auto_ptr to prevent resource leaks.\nFirst of all, let\u0026rsquo;s make clear the concept: a resource is something that we need to return to the system once we\u0026rsquo;re done using it, such as dynamically allocated memory, file descriptors, mutex locks, fonts and brushes in graphical user interfaces (GUIs), database connections, and network sockets.\nThe motivation of using objects to manage resources is that, it is hard to write manually managed code to deal with complex control flow where necessary resource handling operation such as delete may have to be skipped due to premature continue statement or unexpected exception, ending up with resource leak.\nOn the other hand, by putting resources inside objects, we can rely on C++\u0026rsquo;s automatic destructor invocation to make sure that the resources are released properly. Luckily, there\u0026rsquo;re two kinds of smart pointer that is ideal for this kind of situation:\n std::auto_ptr: destructor automatically calls delete on what it points to when the auto_ptr is destroyed. There\u0026rsquo;s only one auto_ptr pointing to the underlying resoures each time std::tr1::shared_ptr: is a reference-counting smart pointer (RCSP). Similar to garbage collection but can\u0026rsquo;t break cycles of references (e.g.: two otherwise unused objects pointing to one another).  1. auto_ptr We can use auto_ptr to manage a class Investment that comes with a factory function (item 7) without worrying about resource leak:\n1 2 3 4 5 6 7  Investment* createInvestment(); // factory function, return ptr to dynamically allocated object  void f() { std::auto_ptr\u0026lt;Investment\u0026gt; pInv(createInvestment()); // call factory function  ... // use pInv like a pointer } // automatically delete pInv via auto_ptr\u0026#39;s dtor   There are two critical aspects worth noting:\n Resources are acquired and immediately turned over to resource-managing objects. It is a common trick to acquire a resource and initialize a resource-managing object in the same statement, which is called Resource Acquisition Is Initialization (RAII). Resource-managing objects use their destructors to ensure that resources are released. Things could be tricky when the act of releasing resources can lead to exceptions being thrown, which is the matter addressed in Item 8.  Pay attention to the limitation of auto_ptr: its sole ownership of the resource policy requires that copying auto_ptrs via copy constructor or copy assignment operator sets them to null:\n1 2 3 4 5  std::auto_ptr\u0026lt;Investment\u0026gt; pInv1(createInvestment()); // pInv1 points to the object returned from the factory function  std::auto_ptr\u0026lt;Investment\u0026gt; pInv2(pInv1); // pInv2 now points to the object; pInv1 is null  pInv1 = pInv2; // pInv1 points to the object, and pInv2 is null now   2. shared_ptr An alternative RAII object, shared_ptr, is an RCSP(reference-counting smart pointer), which is a smart pointer that keeps track of how many objects point to a particular resource and automatically deletes the resource when nobody is pointing to it any longer. The code above is almost the same as with shared_ptr, but copying behavior is much more natural:\n1 2 3 4 5 6 7 8 9 10 11 12  void f() { std::tr1::shared_ptr\u0026lt;Investment\u0026gt; pInv(createInvestment()); // call factory function  ... // use pInv as before  std::tr1::shared_ptr\u0026lt;Investment\u0026gt; pInv1(createInvestment()); // pInv1 points to the object returned from createInvestment  std::tr1::shared_ptr\u0026lt;Investment\u0026gt; pInv2(pInv1); // both pInv1 and pInv2 now point to the object  pInv1 = pInv2; // nothing has changed  } // automatically delete pInv via shared_ptr\u0026#39;s dtor   There is more information on tr1::shared_ptr in item 14, item 18, and item 54. For now, another point worth noting is that, since both auto_ptr and tr1::shared_ptr use delete in their destructors rather than delete [] (item 16), it is a bad idea to wrap dynamically allocated arrays with auto_ptr or tr1::shared_ptr:\n1 2 3  std::auto_ptr\u0026lt;std::string\u0026gt; pStr(new std::string[10]); // wrong delete form will be used, bad idea!  std::tr1::shared_ptr\u0026lt;int\u0026gt; pInt(new int[1024]); // same problem   Since having createInvestment returning a raw pointer type is error-prone, we\u0026rsquo;ll see in item 18 that an interface modification is preferred.\n","description":"","id":178,"section":"notes","tags":["technique","cpp"],"title":"Item-13 Use objects to manage resources","uri":"https://nianze.ml/en/notes/2018/02/use-objects-to-manage-resources/"},{"content":"Be sure to copy all of an object\u0026rsquo;s data members and all of its base class parts.\nIn a well-designed object-oriented system that encapsulate the internal parts of objects, there should only be two copying function:\n copy constructor copy assignment operator  As item 5 introduced, we may create our own versions of copy function. The thing is, while the compiler-generated ones copy all the data of the object being copied as expected, the manually defined copy functions may be implemented in the wrong way, the partial-copied way:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Customer { public: ... Customer(const Customer\u0026amp; rhs); Customer\u0026amp; operator=(const Customer\u0026amp; rhs); private: std::string name; //int age; potential new data memberf }; Customer::Customer(const Customer\u0026amp; rhs) :name(rhs.name){} // copy rhs\u0026#39;s data  Customer\u0026amp; Customer::operator=(const Customer\u0026amp; rhs) { name = rhs.name; // copy rhs\u0026#39;s data  return *this; // item 10 }   Everything is fine here, unless there\u0026rsquo;s more data members, such as the age, added into the Customer class. Interesting thing is that even if there\u0026rsquo;s new data member added, compiler will most likely not complain about potential partial-copy problem if we don\u0026rsquo;t add the data member to the copying functions and all the constructors. So we have to rely on ourselves.\nA more subtle way to get into the problem comes from inheritance:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class PriorityCustomer: public Customer { public: ... PriorityCustomer(const PriorityCustomer\u0026amp; rhs); PriorityCustomer\u0026amp; operator=(const PriorityCustomer\u0026amp; rhs); private: int priority; }; PriorityCustomer::PriorityCustomer(const PriorityCustomer\u0026amp; rhs) : priority(rhs.priority) {} PriorityCustomer\u0026amp; PriorityCustomer::operator=(const PriorityCustomer\u0026amp; rhs) { priority = rhs.priority; return *this; }   The problem here is that derived class PriorityCustomer also contains inherited data members (Customer.name) but the copying functions only cover its newly added data member (PriorityCustomer.priority), ending up with a partial-copy problem. In order to take care of the base class parts, which are typically private (item 22), we need to invoke the corresponding base class functions and implement the derived class\u0026rsquo;s copying function in this way:\n1 2 3 4 5 6 7 8 9 10 11  PriorityCustomer::PriorityCustomer(const PriorityCustomer\u0026amp; rhs) : Cutomer(rhs), // invoke vase class copy ctor priority(rhs.priority) {} PriorityCustomer\u0026amp; PriorityCustomer::operator=(const PriorityCustomer\u0026amp; rhs) { Customer::operator=(rhs); // assign base class part  priority = rhs.priority; return *this; }   Sometimes you may find the copy constructor and copy assignment operator share a lot of code bodies, so a good way to eliminate the duplication is to create a third (private) member function that both copying functions call. Don\u0026rsquo;t let one copying function call the other, since it makes no sense:\n You can\u0026rsquo;t do an assignment operation even before the object get constructed and initialized. It may corrupt object if calling copy construction function in copy assignment operator.  In summary, copy all parts mean:\n copy all local data members (especially those get added later) invoke the appropriate copying function in all base classes ","description":"","id":179,"section":"notes","tags":["technique","cpp"],"title":"Item-12 Copy all parts of an object","uri":"https://nianze.ml/en/notes/2018/01/copy-all-parts-of-an-object/"},{"content":"Solve self assignment situation in operator= by comparing addresses of source and target objects, careful statement ordering, and copy-and-swap.\nWhen operator= applies on more than one object, two or more of the objects may be the same:\n1 2  a[i] = a[j] // potential assignment to self *px = *py; // potential assignment to self   This is the result of aliasing (having more than one way to refer to an object). In general, operations on references or pointers to multiple objects of the same type (or objects of different types derived from the same base class) need to consider that the objects might be the same.\nWhen trying to manage resources manually rather than to take advantage of resource-managing objects (item 13, item 14), it is possible to accidentally release a resource before being done using it:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Bitmap{...}; class Widget{ ... private: Bitmap *pb; // ptr to a heap-allocated object }; Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) // unsafe impl. of operator= { delete pb; // stop using cur. bitmap  pb = new Bitmap(*rhs.pb); // start using a copy of rhs\u0026#39;s bitmap  return *this; // item 10 }   When *this (the target of the assignment) and rhs (the source of the assignment) are the same object, delete destroys both of them in the begining, resulting to the fact that this points to a deleted object instead of being unchanged by the assignment to self. Moreover, besides self-assignment-unsafe, this implementation of operator= is also exception-unsafe.\nThere are three possible ways to solve the problem:\n Identity test at the top (solve self-assignment-unsafe) A careful ordering of statements (solve both self-assignment-unsafe and exception-unsafe) Copy and swap. (solve both potential unsafe situation)  1. Identity test 1 2 3 4 5 6 7  Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { if (this == \u0026amp;rhs) return *this; // test: if a self-assignment, do nothing  delete pb; pb = new Bitmap(*rhs.pb); return *this; }   The problem here is that once the new Bitmap expression yields an exception (due to insufficient memory or Bitmap\u0026rsquo;s copy constructor throwing one), this will end up refer to a deleted Bitmap, which is toxic for there\u0026rsquo;s no way to safely delete them or even safely read them.\n2. Careful reorder 1 2 3 4 5 6 7  Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { Bitmap *pOrig = pb; // remember original pb  pb = new Bitmap(*rhs.pb); // point pb to a copy of rhs\u0026#39; bitmap  delete pOrig; // delete the original pb  return *this; }   Under this implementation, even it new Bitmap throws an exception, pb and this remain unchanged. Moreover, it does work even without the identity test.\nConsidering efficiency, it may be sensible to put the identity test back at the top. However, considering the frequency of self-assignment situation as well as the longer codes and more branches in the flow of control, it may actually decrease runtime speed (at least the effectiveness of instruction prefetching, caching, and pipelining can be reduced).\n3. Copy and swap This is an alternative way to the above careful reordering technique, which is closely associated with exception safety (item 29).\n1 2 3 4 5 6 7 8 9 10 11  class Widget { ... void swap(Widget\u0026amp; rhs); // exchange *this\u0026#39;s and rhs\u0026#39;s data; see item 29 for details }; Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { Widget temp(rhs); // make a copy  swap(temp); // swap *this\u0026#39;s data with the copy\u0026#39;s  return *this; }   A variation taking advantage of the fact that passing by value makes a copy of it (item 20):\n1 2 3 4 5  Widget\u0026amp; Widget::operator=(Widget rhs) // pass by value, rhs is a copy of the object passed in { swap(rhs); // swap *this\u0026#39;s data with the copy\u0026#39;s  return *this; }   This variation sacrifices the clarity but may let compilers generate more efficient code by moving the copying operation from the body of the function to construction of the parameter.\n","description":"","id":180,"section":"notes","tags":["technique","cpp"],"title":"Item-11 Handle self assignment in operator=","uri":"https://nianze.ml/en/notes/2018/01/handle-self-assignment/"},{"content":"As title suggests.\nAssignment is able to chain together:\n1 2  int x,y,z; x = y = z = 15; // chain of assignment   Basically, the chain is parsed from right to left, so the result of the updated z is assigned to y, then the result of the second assignment (the updated y) is assigned to x:\n1  x = (y = (z = 15));   In order to achieve this, we need to implement the assignment operators (as well as +=, -=, *=, etc) in the following convention, where we make the assignment return a reference to its left-hand argument:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Widget { public: ... Widget\u0026amp; operator=(const Widget\u0026amp; rhs) // return type is a reference to the current class  { ... return *this; // return the left-hand object  } Widget\u0026amp; operator=(int rhs) { ... return *this; // even if the right-hand side parameter type is unconventional  // we can still apply this convention  } Widget\u0026amp; operator+=(const Widget\u0026amp; rhs) { ... return *this; } ... };   ","description":"","id":181,"section":"notes","tags":["technique","cpp"],"title":"Item-10 Have assignment operators return a reference to *this","uri":"https://nianze.ml/en/notes/2018/01/have-assignment-op-return-a-ref/"},{"content":"It is discouraged practice to emit exceptions from destructors.\nConsider what should be done to create a resource-managing class for DBConnection class below:\n1 2 3 4 5 6  class DBConnection { public: ... static DBConnection creast(); // return DBConnection obj  void close(); // close connection; throw an exception if closing fails };   To ensure clients don\u0026rsquo;t forget to call close() on DBConnection objects, we may want to put close() inside the destructor of managing class:\n1 2 3 4 5 6 7 8 9 10  class DBConn { // class to manage DBConnection object public: ... ~DBConn() // make sure database connections are closed  { db.close(); } private: DBConnetion db; };   However, once db.close() yields an exception, DBConn\u0026rsquo;s destructor will propogate the exception, which would be a problem: considering std::vector\u0026lt;DBConn\u0026gt; v, chances are that two simultaneously active exceptions (from calling ~DBConn()) arise during destroying the vector v, and program execution will either terminate or yield undefined behavior. Moreover, premature program termination or undefined behavior can result from destructors emitting exceptions even without using containers and arrays. There are 2 ways to handle the situation:\n Terminate the program  1 2 3 4 5 6 7 8  DBConn::~DBConn() { try { db.close(); } catch(...) { // make log entry: the call to close failed;  std::abort(); } }   This will prevent the exception from propagating out of the destructor and then leading to undefined behavior.\n Swallow the exception  1 2 3 4 5 6 7  DBConn::~DBConn() { try { db.close(); } catch(...) { // make log entry: the call to close failed;  } }   In general, swallowing exception is a bad idea for it suppresses imporant information, but it is preferable sometimes when the program is asked to be able to reliably continue execution even after an error has been encountered.\nA better strategy is to design DBConn\u0026rsquo;s interface so that its clients have an opportunity to handle the possible exception by themselves:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class DBConn { public: ... void close() // new interface for clients  { // to handle possible exception outside dtor  db.close(); closed = true; // keep track of whether db has been closed  } ~DBConn() { if (!closed) { try { // close the connecton  db.close(); // if the client didn\u0026#39;t  } } catch (...) { // make log entry: the call to close failed;  // terminate or swallow  } } private: DBConnection db; bool closed; };   Under such a design, if clients decide to ignore the opportunity to close the connection and handle the possible exception by themselves for they believe that no error will occur, they can rely on DBConn\u0026rsquo;s destructor to call close() for them. However, if close() does throw in ~DBConn, they\u0026rsquo;re in no position to complain if DBConn swallows the exception or terminates the program.\nIn summary,\n Never emit exceptions from destructors. If functions in a destructor may throw, catch it and then either swallow it or terminate the program. When class clients need to be able to react to any operation that may throw exceptions, provide a non-destructor function for them to handle such exceptions. ","description":"","id":182,"section":"notes","tags":["technique","cpp"],"title":"Item-8 Prevent exception from leaving destructor","uri":"https://nianze.ml/en/notes/2018/01/prevent-exception-from-leaving-dtor/"},{"content":"If a class has any virtual functions (for polymorphic purpose), it should have a virtual destructor.\nIn the convention of factory functions, we use base class pointers manipulating derived class objects during runtime, which gives us the convenience of polymophism.\nBecause C++ specifies that when a derived class object is deleted through a pointer to a base class with a non-virtual destructor, results are undefined, we need to declare the destructor as virtual. Otherwise, what typically happens at runtime is that, while base class data members get destroyed, the derived part of the object (i.e., the data members declared in the derived class) is never destroyed, ending with a curious \u0026ldquo;partially destroyed\u0026rdquo; object that is an excellent way to leak resources, corrupt data structures, and waste time debugging.\nBasically, the implementation of virtual functions requires that objects carry a pointer (called a vptr, virtual table pointer) accessible at runtime to determine which virtual functions should be invoked on the object. The vptr points to vtbl (virtual table), which is an array of function pointers to appropriate actual functions.\nSometimes we may want to create an abstract class (which contains pure virtual functions) but don\u0026rsquo;t have any pure virtual functions in mind, we may simply make a pure virtual destructor:\n1 2 3 4  class AWOV { // \u0026#34;Abstract w/o Virtuals\u0026#34; public: virtual ~AWOV() = 0; // declare pure virtual destructor };   Since AWOV has a pure virtual function, it\u0026rsquo;s abstract as we wish while also benifits us with not worrying about the derived class destructor problem at the same time, but there\u0026rsquo;s one twist: a definition of the pure virtual destructor must still be provided:\n1  AWOV::~AWOV() {} // definition of pure virtual destructor   Otherwise the linking will complain, because compilers will generate a call from derived classes' destructors to each base class, all the way up to ~AWOV, yet the body of base class destructor function can\u0026rsquo;t be found.\nHowever, not all base classes are designed to be used polymorphically. For classes not designed to be base classes (std::string, STL container types such as vector, list, set, etc.) or not designed to be used polymorphically (item 6, Uncopyable class), we should not declare virtual destructors. Here is an example:\n1 2 3 4 5 6 7  class Point { // a 2D point public: Point(int xCoord, int yCoord); ~Point(); private: int x, y; };   If an int occupies 32 bits, a Point object typically fits into a 64-bit register, which can be passed as a 64-bit quantity to functions written in other languages such as C or FORTRAN. However, if Point\u0026rsquo;s destructor is declared virtual, Point object will increased from 64 bits (for the 2 ints) to 96 bits (for 2 ints with the vptr) on 32-bit architecture, or to 128 bits on 64-bit architecture (where pointers are 64 bits in size). As a result, portability decreases.\nIn short words, gratuitously declaring all destructors virtual is just as wrong as never declaring them virtual; declare a virtual destructor in a class if and only if that class contains at least one virtual function.\n","description":"","id":183,"section":"notes","tags":["technique","cpp"],"title":"Item-7 Declare destructor virtual in polymorphic base classes","uri":"https://nianze.ml/en/notes/2018/01/virtual-dtor-in-polymorphic-base-class/"},{"content":"Declare unwanted member functions private without implementations to disallow functionality automatically provided by compilers.\nIf we want to prevent functions such as copy constructor being generated in order to maintain the object uniqueness, explicitly declare the copy constructor and the copy assignment operator private, so that the client of the class will not be able to copy the object.\nTo make it foolproof, declare member functions private and deliberately not implemente them so that member and friend functions will not be able to copy the object, either.\nAnother possible solution to prevent copying is to inherit from a well-designed base class such as this:\n1 2 3 4 5 6 7 8  class Uncopyable { protected: Uncopyable() {} // allow construction of derived objects  ~Uncopyable() {} // allow destruction of derived objects private: Uncopyable(const Uncopyable\u0026amp;); // prevent copying  Uncopyable\u0026amp; operator=(const Uncopyable\u0026amp;); // prevent copying };   To inherit from the base class, simply:\n1 2 3  class HomeForSale: private Uncopyable { ... // no copy ctor or copy assign. operator declaration };   This will be the same effect as the following design:\n1 2 3 4 5 6 7 8  class HomeForSale{ public: ... private: ... HomeForSale(const HomeForSale\u0026amp;); HomeForSale\u0026amp; operator=(const HomeForSale\u0026amp;); };   There are some subtleties about the implementation and use of Uncopyable:\n inheritance from Uncopyable needn\u0026rsquo;t be public (item 32 and 39) Uncopyable destructor needn\u0026rsquo;t be virtual (item 7: the base class is not designed to be used polymorphically) it\u0026rsquo;s eligible for the empty bass class optimization described in item 39, but use of this technique could lead to multiple inheritance (item 40), which will sometimes in turn disable the empty base class optimization (item 39) Boost (item 55) provides a similar class named noncopyable ","description":"","id":184,"section":"notes","tags":["technique","cpp"],"title":"Item-6 Disallow unwanted compiler-generated functions","uri":"https://nianze.ml/en/notes/2018/01/functions-silently-created/"},{"content":"Compilers may implicitly generate their own versions of default constructor, copy constructor, copy assignment operator, and destructor.\nAll the compiler generated functions will be both public and inline (item 30). An empty class declared like this:\n1  class Empty{};   is essentially equivalent to:\n1 2 3 4 5 6 7 8 9  class Empty { public: Empty() { ... } // default constructor  Empty(const Empty\u0026amp; rhs) { ... } // copy constructor  ~Empty() { ... } // destructor  // will be _virtual_ only if inheriting  // from a base class with virtual destructor  Empty\u0026amp; operator=(const Empty\u0026amp; rhs) { ... } // copy assignment operator };   These functions are generated only if they are needed:\n1 2 3  Empty e1; // default constructor and destructor generated Empty e2(e1); // copy constructor generated e2 = e1; // copy assignment operator generated   Basically, the generated default constructor and the destructor will invocate constructors and destructors of base classes and non-static data members, while the copy constructor will simply copy each non-static data member of the source object to the target object.\n specifically,\n  for data member of user-defined type, call the data member\u0026rsquo;s copy constructor with source object\u0026rsquo;s corresponding member\u0026rsquo;s value as argument for data member of built-in type, directly copy the corresponding source data member\u0026rsquo;s bits  Copy assignment operator behaves generally the same as copy constructor, but the code is only generated when the resulting code is both legal and has a reasonable chance of making sense. For example:\n1 2 3 4 5 6 7 8 9  template\u0026lt;class T\u0026gt; class NamedObject { public: NamedObject(std::string\u0026amp; name, const T\u0026amp; value); ... private: std::string\u0026amp; nameValue; // a reference  const T objectValue; // a const }   In below situation, implicitly generated copy assignment operator will make no sense for nameValue and illegal for objectValue:\n1 2 3 4 5 6 7 8  std::string youngMan(\u0026#34;child\u0026#34;); std::string oldMan(\u0026#34;adult\u0026#34;); NamedObject\u0026lt;int\u0026gt; p(youngMan, 10); NamedObject\u0026lt;int\u0026gt; s(oldMan, 50); p = s; // nameValue assignment will make no sense!  // objectValue assignment will be illegal due to its constness   Since p.nameValue and s.nameValue refer to different string object, the assignment will be in a conundrum:\n should compiler choose to let p.nameValue refer to new string object? (actually C++ does not allow reference referring to different one)? should compiler choose to change the string content \u0026ldquo;child\u0026rdquo; to \u0026ldquo;adult\u0026rdquo;? (this will affect other objects that hold pointers or references to original string \u0026ldquo;child\u0026rdquo;)  Neither will be sensible, so C++ refuses to compile the code. In this situation, a copy assignment operator must be defined manually.\nFinally, derived classes will not be able to have generated implicit copy assignment operators if base classes declare the copy assignment operator private, for derived copy assignment operators are supposed to handle base class parts, but they don\u0026rsquo;t have the right to invoke the base member functions in this situation.\n","description":"","id":185,"section":"notes","tags":["technique","cpp"],"title":"Item-5 What functions C++ silently generates","uri":"https://nianze.ml/en/notes/2018/01/functions-silently-created/"},{"content":"Since C++ is fickle about initialization, some good coding style is suggested.\nThere are basically only 3 rules we need to remember if wanting to avoid tragedy of using objects before they\u0026rsquo;re initialized:\n always manually initialize non-member objects of built-in type, becauese C++ sometimes initializes them and sometimes not. in constructors, prefer to use member initialization list to assignment inside the constructor body; data members in the initialization list is suggested to be in the same order as they are declared in the class (which helps to avoid reader confusion) replacing non-local static objects with local static objects in order to avoid initialization order problems across translation units.  1. Initialize non-member built-in type object No need to remember rules about when built-in type object initialization is guaranteed to take place and when it isn\u0026rsquo;t, for they\u0026rsquo;re too complicated to know.\nJust form a good habit to always initialize objects before using them manually.\n1 2 3 4  int x = 0; // manual init. of an int const char *text = \u0026#34;A C-style string\u0026#34;; // manual init. of a pointer double d; std::cin \u0026gt;\u0026gt; d;   2. Initialize data member with member initialization list The arguments in the initialization list are used as constructor arguments for the various data members (will be copy-constructed), which will be more efficient than a call to the default constructor followed by a calll to the copy assignment operator.\n For data members of const and references, since they can\u0026rsquo;t be assigned (item 5), initialization list must be used. For built-in type data members, even though there\u0026rsquo;s no difference in cost betweeen initialization and assignment, it is a good habit to place them in member initialization list for consistency. For data members of user-defined type, since compilers will automatically call default constructors for absent ones in initialization list, even if you just want to call the default constructor, it is still a good habit to call the default constructors in the initialization list, just to make a good habbit to guarantee there\u0026rsquo;s no data member left uninitialzed.  Exception: multiple constructors share large common member initialization list may consider moving assignment to a single (private) function called by all the constructors, which will be helpful for initializing values from reading a file or database.\n3. Initialze non-local static objects defined in different translation units Glossary:  static object: one that exists from the time it\u0026rsquo;s constructed until the end of the program (i.e., their destructors will be called when main finishes executing) local static object:  objects declared static inside functions (it\u0026rsquo;s local to a function)   non-local static object:  global objects objects defined at namespace scope objects declared static inside classes objects declared static at file scope   translation unit: the source code giving rise to a single object file (basically a single source file plus all of its #include files)  Below is an example of non-local static objects requiring correct order of initialization (firstly tfs, secondly tempDir):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  //======================== // fileSystem.h class FileSystem { // created by library developer public: ... std::size_t numDisks() const; ... }; extern FileSystem tfs; // non-local static object for clients to use  // \u0026#34;tfs\u0026#34; = \u0026#34;the file system\u0026#34;  //======================== // directory.h #include \u0026lt;fileSystem.h\u0026gt; // created by library clientclass Directory { public: Directory( params ); ... }; Directory tempDir( params ); // non-local static object for  // directory of temporary files  //======================== // directory.cpp Directory::Directory( params ) { ... std::size_t disks = tfs.numDisks(); // use the tfs objects  ... }   Since the relative order of initialization of non-local static objects (tfs vs. tempDir) defined in different translation units (fileSystem vs. directory) is undefined, and given the fact that C++ guarantees that local static objects are initialized when the object\u0026rsquo;s definition is first encountered during a call to that function, simply replace direct accesses to non-local static objects with calls to functions that return references to local static objects, and the problem is solved, with a little bonus of saving the cost of constructing/destructing the object in the situation of the function never being called (this design implementation is the well-known singleton pattern):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  //======================== // fileSystem.h class FileSystem {...}; // as before  FileSystem\u0026amp; tfs() // replace the tfs object; { // could also be static in the FileSystem class  static FileSystem fs; // define and initialize a local static object  return fs; // return a reference to it } //======================== // directory.h #include \u0026lt;fileSystem.h\u0026gt; class Directory { ... }; // as before  Directory\u0026amp; tempDir( params ) // replace the tempDir object; { // could also be static in the Directory class  static Directory td(params); // definea and initialize a local static object  return td; // return a reference to it } //======================== // directory.cpp Directory::Directory( params ) { ... std::size_t disks = tfs().numDisks(); // use the new tfs()  ... }    P.S.: There\u0026rsquo;s limitation for non-const static object (local or non-local) in multiple threads scenarios. One way to deal with the trouble is to manually invoke all the reference-returning functions during the single-threaded startup portion of the program to eliminate initialization-related race condition.\n","description":"","id":186,"section":"notes","tags":["technique","cpp"],"title":"Item-4 Initialize objects before they're used","uri":"https://nianze.ml/en/notes/2018/01/initialize-before-use/"},{"content":"Useful tips on using const in C++.\nThe const keyword allows you to specify a semantic constraint and compilers will enforce that constraint. It is remarkably versatile:\n outside of class, you may use it for constants at global or namespace scope, as well as for objects declared static at file, function or block scope inside classes, you may use it for both static and non-static data members, for pointers when declaring functions, you may also refer const to function\u0026rsquo;s return value, function parameters, and, for member functions, to the function as a whole  1. const pointer 1 2 3 4 5 6  char greeting[] = \u0026#34;Hello\u0026#34;; char *p = greeting; // non-const pointer, non-const data const char *p = greeting; // non-const pointer, const data char * const p = greeting; // const pointer, non-const data const char * const p = greeting; // const pointer, const data char const * const p = greeting; // const pointer, const data   If the const appears to the left of the asterisk, what\u0026rsquo;s pointed to is constant; if the word const appears to the right of the asterisk, the pointer itself is constant. It\u0026rsquo;s helpful to read pointer declarations right to left: const char * const p reads as \u0026ldquo;p is a constant pointer to constant chars\u0026rdquo;.\n2. const iterator STL iterators are modeled on pointers. Treat it like this:\n iterator -\u0026gt; T* pointer const iterator -\u0026gt; T* const pointer const_iterator -\u0026gt; const T* pointer  1 2 3 4 5 6 7 8 9  std::vector\u0026lt;int\u0026gt; vec; ... const std::vector\u0026lt;int\u0026gt;::iterator iter = vec.begin(); // acts like T* const *iter = 10; // OK. ++iter; // error.  std::vector\u0026lt;int\u0026gt;::const_iterator cIter = vec.begin(); // acts like const T* *cIter = 10; // error. ++cIter; // OK.   3. const function return value Generally speaking, having a function return a constant value is inappropriate, but sometimes doing so may reduce implicit errors out of incidence without giving up safety or efficiency.\n1 2 3 4 5  class Rational { ... // contains no operator* }; const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs);   Declaring the return value of operator* to be const prevent typos like this:\n1  if (a * b = c) // meant to do a comparison for some user-defined objects   4. const function parameters const parameters act just like local const objects. Unless there\u0026rsquo;s a need to modify aparameter or local object, be sure to declare it const, for it may save you from annoying errors like if (a = b) above.\n5. const member functions The purpose of const on member functions is to identify which member functions may be invoked on const objects, which benefits us for:\n making the interface of a class easier to understand (which functions may modify an object and which may not) making it possible to work with const-qualified objects (which makes up a very important C++ feature: overloading member functions differing only in their constness)  5.1 Bitwise constness vs. Logical constness 5.1.1 Bitwise constness  Bitwise constness: a member function is const if and only if it doesn\u0026rsquo;t modify any of the object\u0026rsquo;s data members (excluding those that are static). This is also C++\u0026rsquo;s definition of constness\n However, member functions that don\u0026rsquo;t act very const pass the bitwise test, such as a function including a char* const pointer manipulating a char* type class member:\n1 2 3 4 5 6 7 8 9  class CTextBlock { public: ... //inappropriate but bitwise const declaration of operator[]  char\u0026amp; operator[](std::size_t position) const {return pText[position];} private: char *pText; };   Since operator[]\u0026rsquo;s implementation doesn\u0026rsquo;t modify pText in any way, compilers will happily generate code after verifying that it is indeed bitwise const. However, when you create a constant object with a particular value and invoke only const member functions on it, you can still change its value:\n1 2 3  const CTextBlock cctb(\u0026#34;Hello\u0026#34;); // declare constant object char *pc = \u0026amp;cctb[0]; // call the const operator[] *pc = \u0026#39;J\u0026#39; // cctb has value \u0026#34;Jello\u0026#34; now   To solve this problem, we may store data as a string instead of communicating through a C API char*:\n1 2 3 4 5 6 7 8 9 10 11 12  class TextBlock { public: ... // operator[] for const objects  const char\u0026amp; operator[] (const std::size_t position) const {return text[position];} // operator[] for non-const objects  char\u0026amp; operator[] (const std::size_t position) const {return text[posion];} private: std::string text; };   Remeber the C++ feature mentioned above? By overloading operator[] and giving the different versions different return types, we can handle const and non-const TextBlock objects differently:\n1 2 3 4 5 6 7  TextBlock tb(\u0026#34;Hello\u0026#34;); const TextBlock ctb(\u0026#34;World\u0026#34;); std::cout \u0026lt;\u0026lt; tb[0]; // fine, call and reading a non-const TextBlock object tb[0] = \u0026#39;x\u0026#39;; // fine, call and writing a non-const TextBlock object std::cout \u0026lt;\u0026lt; ctb[0]; // fine, call and reading a const TextBlock object ctb[0] = \u0026#39;x\u0026#39;; // error! call to a const TextBlock object is fine  // but making an assignment to returned const char\u0026amp; type gives us an error   5.1.2 Logical constness  Logical constness: a const member function might modify some of the bits in the object on which it\u0026rsquo;s invoked, but only in ways that clients cannot detect.\n A typical example of logical constness shows in such a scenario: say we want to cache the length for a CTextBlock object, and we define it like as\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class CTextBlock { public: ... std::size_t length() const; private: char *pText; std::size_t textLength; book lengthIsValid; }; std::size_t CTextBlock::length() const { if(!lengthIsValid) { textLength = std::strlen(pText); // error: can\u0026#39;t asssign to textLength  lengthIsValid = true; // and lengthIsValid in a const member function  } return textLength; }   Bitwise constness test fails and compilers complains due to the assignment to textLength and lengthIsValid, but it is supposed to be valid for const CTextBlock objects. The solution is to take advantage of C++\u0026rsquo;s keyword mutable, which frees non-static data members from the constraints of bitwise constness:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class CTextBlock { public: ... std::size_t length() const; private: char *pText; mutable std::size_t textLength; mutable book lengthIsValid; }; std::size_t CTextBlock::length() const { if(!lengthIsValid) { textLength = std::strlen(pText); // error: can\u0026#39;t asssign to textLength  lengthIsValid = true; // and lengthIsValid in a const member function  } return textLength; }   According to the mutable\u0026rsquo;s definition, you may notice that const member function will not check bitwise constness for static data members. This is because following facts:\n The this pointer in a const qualified member function is a const type, and this is inherently related to an instance of a class static data members are not related to a class instance For non-static data member lengthIsValid = true;, think of it as this-\u0026gt;lengthIsValid = true;, which is not compilable when the type of this is const CTextBlock* without mutable added. Think of static data member staticMember as CTextBlock::staticMember, so there\u0026rsquo;s no constraints from const type this pointer.  5.2 Avoiding duplication in const and non-const member function There are two versions of operator[] in class TextBlock, which is duplication and tempts us to have one version of operator[] call the other one. Although generally speaking casting is a bad idea, here we may find enough reasons to justify its usage so long as we use it properly (note that we call const version in non-const version, not the other way around!):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class TextBlock { public: ... const char\u0026amp; operator[](const std::size_t position) const { ... // some extra tasks such as bounds checking,  ... // log access data, verify data integrity  ... // to make code duplication unbearablly tedious  return text[position]; } char\u0026amp; operator[](const std::size_t position) const { return const_cast\u0026lt;char\u0026amp;\u0026gt; ( // cast away const on return type  static_cast\u0026lt;const TextBlock\u0026amp;\u0026gt;(*this)[position]; // add const to *this\u0026#39;s type in order to call const version of operator[]  ); } };   It\u0026rsquo;s definitely worth knowing this technique of implementing a non-const member function in terms of its const twin, although the syntax is somehow ungainly.\n","description":"","id":187,"section":"notes","tags":["technique","cpp"],"title":"Item-3 Use const whenever possible","uri":"https://nianze.ml/en/notes/2018/01/use-const-whenever-possible/"},{"content":"C++ is a multiparadigm programming langrage.\nInstead of regarding C++ as a single language, we\u0026rsquo;d better treat it as a federation of related languages, where rules within a particular sublanguage tend to be simple and straightforward, while rules between sublanguages may change.\nBasically, there are four primary sublanguages:\n C: Based on ideas of blocks, statements, the preprocessor, built-in data types, arrays, pointers, etc, rules of C style C++ are simple: no templates, no exceptions, no overloading, etc. Object-Oriented C++: Based on ideas of classes(including constructors and destructors), encapsulation, inheritance, polymorphism, virtual functions(dynamic binding), etc, style of this part of C++ goes with the classic Object-Oriented design rules. Template C++: this is generic programming part of C++, where template considerations pervade C++. Due to its great power, templates give rise to a completely new programming paradigm, template metaprogramming(TMP, item 48). The STL: With beautifully meshing conventions of containers, iterators, algorithms and function objects, the STL is a very special template library and has its particular ways of doing things.  There\u0026rsquo;s an interesting comparison among the four sublanguages: pass-by-value is generally preferred to pass-by-reference for built-in (i.e., C-style) types in favor of its higher efficiency, but for Object-Oriented C++ pass-by-reference will usually be better due to the consideration of user-defined constructors and destructors; pass-by-reference is especially the dominant usecase in template C++ for you don\u0026rsquo;t even know the type of object you\u0026rsquo;re dealing with; however, the old C pass-by-value rule applies to the case of STL, because iterators and function objects are modeled on pointers in C (see item 20).\nIn summary, rules for effective C++ programming vary, depending on the part of C++ you are using.\n P.S.: Today I found that the 3rd edition of effective C++ added some new items. So new posts will follow the third edition\u0026rsquo;s arrangement. This item 0 is supposed to be item 1 in 3rd edition, but I just put it in front of the item 1 which I already wrote. After all, that\u0026rsquo;s how programmers count :)\n","description":"","id":188,"section":"notes","tags":["technique","cpp"],"title":"Item-0 Federation of languages","uri":"https://nianze.ml/en/notes/2018/01/cpp-is-multiparadigm/"},{"content":"Some tips about \u0026lt;iostream\u0026gt;\nOne advantage of \u0026lt;iostream\u0026gt; over \u0026lt;stdio.h\u0026gt; (which includes C-style scanf and printf) is that built-in types like int are read and written in the same manner as user-defined types like Rational:\n1 2 3 4 5  int i; Rational r; // r is a user-defined rational number ... cin \u0026gt;\u0026gt; i \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; r;   So considering type safety and extensibility offered by the classes and functionas in the iosteam library, in general we should prefer \u0026lt;iostream\u0026gt; to \u0026lt;stdio.h\u0026gt;. In order for this code to compile, we mus define operator\u0026gt;\u0026gt; and operator\u0026lt;\u0026lt; for Rational type. A typical output routine may look like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  clas Rational { public: Rational (int numerator = 0, int denominator = 1); ... private: int n, d; friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; s, const Rational\u0026amp; r); }; ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; s, Rational\u0026amp; r) { s \u0026lt;\u0026lt; r.n \u0026lt;\u0026lt; \u0026#39;/\u0026#39; \u0026lt;\u0026lt; r.d; return s; }   There are some subtle points worth noting: operator\u0026lt;\u0026lt; is not a member function (explained in item 19) and the Rational object to be output is passed as a reference-to-const rather than as an object (see item 22).\nHowerver, there are still very few situations where \u0026lt;stdio.h\u0026gt; may be more sensible to use:\n Some implementations of iostream operations are less efficient than corresponding C stream operations, so it may make sense for applications requiring extreme performance. During the course of standardization, iostream library was modified in some fundamental ways, so it may make sense for applications targeting at maximum portablility. Since classes of the iostream library have constructors while functions in \u0026lt;stdio.h\u0026gt; do not, when concerning about initialization order of static objects (see item 47) the standard C library may be more useful because you can always call it with impunity.  By the way Technically speaking, the standardizatoin committee eliminated \u0026lt;iostream.h\u0026gt; in favor of \u0026lt;iostream\u0026gt; when they truncated the names of the other non-C standard header names, but chances are that most compilers support both of them. However, there is a subtle difference between them:\n when #include \u0026lt;iostream\u0026gt;, the iostream library is ensconced within the namespace std (item 28) when #include \u0026lt;iostream.h\u0026gt;, we get the same elements but they are at global scope  Thus we usually prefer using \u0026lt;iostream\u0026gt; for name conflicts consideration.\n","description":"","id":189,"section":"notes","tags":["technique","cpp"],"title":"Item-2 Compare \u003ciostream\u003e to \u003cstdio.h\u003e","uri":"https://nianze.ml/en/notes/2018/01/tips-on-iostream/"},{"content":"A new (hopefully) daily review on C++.\nThis is another new series, which I plan to update daily (well, hopefully :P). It\u0026rsquo;s mainly about C++, which is my current main development language. Each day I\u0026rsquo;ll follow 1 item in the Effective C++ 2nd edition by Scott Meyers to discuss 1 tiny point of C++.\nThe item 1 of the book tells us when we should prefer the compiler to the preprocessor, or more specifically, why we should prefer consts, enums and inlines to #define. Now let\u0026rsquo;s take a closer look.\nPrefer const to #define There are two ways we may consider, when we want to define a constant:\n1 2 3 4  // method one #define PI_1 3.1415926 // method two const double PI_2 = 3.1415926;   However, since PI_1 may be removed by preprocessor and never be seen by compilers, making it absent in the symbol table, this can be confusing during debugging if we get an error refering to 3.1415926 rather than PI_1 (especially when PI_1 is defined in a header file written by somebody else). Thus, instead of using a preprocessor macro, we\u0026rsquo;d better go with const. Below is some tricks with const.\nTricks on const definition   When defining constant pointers, use two const to make sure both the pointer as well as the content pointed by the pointer are immutable:\n1  const char * const blogger = \u0026#34;Nzo\u0026#34;;     For class-specific constants, of which we want to limit the scope, we declare it as a static member, since there\u0026rsquo;s no way we may create a class-scope-specific or class-encapsulated(i.e., private) constant using a #define (once a macro is defined, it\u0026rsquo;s in force for the rest of the compilation unless it\u0026rsquo;s #undefed somewhere along the line). Pay attention to the difference between constant declaration and constant definition:\n1 2 3 4 5 6 7  // game.h class GamePlayer { private: static const int NUM_TURNS = 5; // constant declaration with initial value  static const double PI; // constant declaration without initial value  int scores[NUM_TURNS]; // use of constant };   1 2 3  // game.cpp const int GamePlayer::NUM_TURNS; // constant definition in impl. file const double GamePlayer::PI = 3.14; // provide initial value at definition   It\u0026rsquo;s worth noting that older compilers (primarily those written before 1995) may complain about providing initial value for static class member at the point of declaration. Most of time we may solve the problem by putting the initial value at definition time, but in the situation where we need the integral value of NUM_TURNS during compilation time (in the example above, compilers must know the size of the array during compilation), we may use a trick affectionately known as the enum hack, which takes advantage of the fact that the value of an enumerated type can be used where ints are expected:\n1 2 3 4 5 6  // Game.h class GamePlayer { private: enum { NUM_TURNS = 5 }; // NUM_TURNS is a symbolic name for 5  int scores[NUM_TURNS]; // fine with old compilers };   There are mainly 2 reasons we may still see the enum hack today:\n It\u0026rsquo;s legal to take the address of a const, but it\u0026rsquo;s not legal to take the address of an enum, so if you don\u0026rsquo;t want people to get a pointer or reference to your integral constants, an enum will enforce that constraint (and this makes the enum behave somewhat like a #define). It\u0026rsquo;s purely pragmatic. Lots of code (such as template metaprogramming, item 48) still employs it.  For modern compilers, on the other hand, rules change a bit in a more convenient way. Usually C++ requires that you provide a difinition for anything you use, but class-specific constants that are stitic and of integral type (e.g., integers, chars, bools) are an exception. As long as you don\u0026rsquo;t take thier address, you can declare and read them without providing a definition, and (good) compilers will not allocate unneccessary memory for these integral-type const objects, which will make the static const integral an lvalue.\n  Prefer inline to #define Another common (mis)use of the #define is using it to implement macros that look like functions:\n1  #define max(a,b) ((a) \u0026gt; (b) ? (a) : (b))   This macro will lead to following weird things:\n1 2 3  int a = 5, b = 0; max(++a, b); // a increments twice max(++a, b+10); // a increments once   Thus, we may prefer using a regular inline function that provides both predictable behavior and type-safety:\n1  inline int max(int a, int b) { return a \u0026gt; b ? a : b; }   If you complain that the above inline function only deals with int type, then we may just use inline template function, which nicely fixes the problem:\n1 2 3 4  template\u0026lt;typename T\u0026gt; inline const T\u0026amp; max (const T\u0026amp; a, const T\u0026amp; b) { return a \u0026gt; b ? a : b; } // since we don\u0026#39;t know what T is, // we pass by reference-to-const, see item 20   Basically, this template generates a whole family of functions, each of which takes two objects convertible to the same type and returns a reference to the greater of the two objects in const version.\nWhen to use preprocessor However, preprocessor is never dead. We still need preprocessor for tasks such as #include to include libraries, as well as #ifdef/#ifndef to control compilation.\n","description":"","id":190,"section":"notes","tags":["technique","cpp"],"title":"Item-1 Prefer consts, enums and inlines to #defines","uri":"https://nianze.ml/en/notes/2018/01/start-of-effective-cpp-series/"},{"content":"My first post in the new machine learning series.\nAlthough I\u0026rsquo;ve chosen https://nianze.ml as my personal website domain name, I haven\u0026rsquo;t really posted any article on Machine Learning at all, which may somehow be misleading. Considering it\u0026rsquo;s new year and my website has just been re-designed, it\u0026rsquo;s perfect time for new plans, so I\u0026rsquo;ve made a dicision to begin a new series related to ml: I\u0026rsquo;ll write down learning notes during my self-study in machine learning. Recently I\u0026rsquo;m reading the book Hands-On Machine Learning with Scikit-Learn and TensorFlow by Aurélien Géron, which should be a good start for this new series.\nAt first the post is intended to be written in Chinese, but considering there\u0026rsquo;re so many technique terms in English that I do not know the exact Chinese translation, I\u0026rsquo;ll just start with English.\nAs the first post in this series, let\u0026rsquo;s just take a overview on machine learning system.\nTypes of machine learning There are broadly three ways to classify machine learning systems, and each of these three could be further categorized into multiple sub-categories:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  Machine learning system ├── trained with supervision or without │ ├── supervised learning │ │ ├── k-Nearest Neighbors │ │ ├── Linear Regression │ │ ├── Logistic Regression │ │ ├── Support Vector Machines (SVMs) │ │ ├── Decision Trees and Random Forests │ │ └── Neural networks │ ├── unsupervised learning │ │ ├── clustering │ │ │ ├── k-Means │ │ │ ├── Hierarchical Cluster Analysis (HCA) │ │ │ └── Expectation Maximization │ │ ├── Visualization and dimensionality reduction │ │ │ ├── Principal Component Analysis (PCA) │ │ │ ├── Kernel PCA │ │ │ ├── Locally-Linear Embedding (LLE) │ │ │ └── t-distributed Stochastic Neighbor Embedding (t-SNE) │ │ └── Association rule learning │ │ ├── Apriori │ │ └── Eclat │ ├── semisupervised learning │ └── reinforcement learning ├── learn incrementally or in a whole batch │ ├── online learning (incremental learning) │ │ ├── adapting rapidly to changing data and autonomous system │ │ └── out-of-core learning (training on large quantities of data) │ └── batch learning └── predict based on a model or not ├── instance-based learning (using a similarity measure) └── model-based learning   Main challenges of machine learning  Bad data  Insufficient quantity of training data Nonrepresentative training data Poor-quality data Irrelevant features   Bad algorithm  Overfitting the training data Underfitting the training data    We reduce overfitting by constraining the degrees of freedom the model has, which is called regularization. The amount of regularization can be controlled by a hyperparameter, which is a parameter of the learning algorithm (not of the model). The larger the hyperparameter, the smaller the model parameter, ending up with more constrain we apply to the model and less degrees of freedom.\nOn the other side, to solve underfitting problem, we may consider:\n select more powerful model with more parameters feed better fetures reduce the constraints (e.g., reducing the regularization hyperparameter)  Testing and validating Usually we split data into three groups:\n training set validation set test set  And take following common workflow:\n train multiple models with various hyperparameters using the training set select the model and hyperparameters tht perform best on the validation set run a single final tets against the test set to get an estimate of the generalization error (out-of-sample error)  Further, we can use cross-validation technique to reuse data:\n split trainig set into complementary subsets train each model against a different combination of these subsets and validate against the remaining parts select the model type and hyperparameters with best performance train the final model by feeding the full training set to the chosen model and hyperparameters measure the generalized error on the test set  Concept checkout:   How would you define Machine Learning?\n ML is a system that can learn from data. Specifically, given performance measure, the learning will result in better performance at some tasks.    Can you name four types of problems where it shines?\n Complex problems without known algorithmic solution Long hand-tuned rules System that needs to adapt to fluctuating environment Data mining (help humans learn)    What is a labeled training set?\n It\u0026rsquo;s a training set that contains the desired solution (a label) for each instance    What are the two most common supervised tasks?\n Regression and classification    What is the purpose of test set and validation set?\n A test set is used to estimate the generalization error that a model will make on new instances, before the model is launched in production. A validation set is used to compare models. It makes it possible to select the best model and tune the hyperparameters.    Why would you prefer cross-validation?\n Cross-validation is a technique that makes it possible to compare models (for model selection and hyperparameter tuning) without the need for a separate validation set. This saves precious training data.   ","description":"","id":191,"section":"notes","tags":["technique","machine learning"],"title":"Machine learning overview","uri":"https://nianze.ml/en/notes/2018/01/start-of-machine-learning-series/"},{"content":"Work Experience Bloomberg LP  May 2017 - Today\nFull stack software developer\nBuilding Trader Access Manager service that manages user privileges for Bloomberg terminal clients\n Oracle Corp.  May 2016 - Aug. 2016\nSoftware Engineer Intern\nVirtualizing static fields in 3rd-party Java library during runtime to improve memory efficiency in Weblogic Server\n  Skills Programming  C++, JavaScript, Python, LaTeX\n  Education New York University  Master of Music - Music Technology\n Cornell University  Master of Engineering - Electrical and Computer Engineering\n Southeast University  Bachelor of Engineering - Electronic Science \u0026amp; Technology\n  Hobbies Music  YouTube Bilibili  Photography My current gears:\n iPhone SE 2 Leica SL Hexar RF ZEISS Biogon T* 21mm f/2.8 ZM ZEISS Distagon T* 35mm f/1.4 ZM Voigtländer Nokton 50mm f/1.2 Aspherical VM LEICA APO-SUMMICRON-M 75 f/2 ASPH. LightPix Labs FlashQ Q20II Nikon COOLSCAN IV ED (LS-40 ED)  Some of my photos:\n Flickr Instagram Weekly Visual Project   ","description":"","id":192,"section":"","tags":null,"title":"Nianze (Nzo) Liu","uri":"https://nianze.ml/en/about/"},{"content":"A gallery for some of my photos stored in Flickr. You may also check out my Instagram.\nTotal images: 0     ","description":"","id":193,"section":"gallery","tags":["photography"],"title":"Flickr Photo Gallery","uri":"https://nianze.ml/en/gallery/digital/2017/01/01/flickr-photo-gallery/"},{"content":"Detailed review on binary search.\nThis post is based on an article on binary search from Topcoder.\nClassic: Finding a value in a sorted sequence Consider the following sequence of integers sorted in ascending order and say we are looking for the number 55:\n| 0 | 5 | 13 | 19 | 22 | 41 | 55 | 68 | 72 | 81 | 98 |\n\u0026ndash;\u0026gt;\n| 55 | 68 | 72 | 81 | 98 |\n\u0026ndash;\u0026gt;\n| 55 | 68 |\nDepending on how we choose the median of an even number of elements we will either find 55 in the next step or chop off 68 to get a search space of only one element. Either way, we conclude that the index where the target value is located is 7.\n1 2 3 4 5 6 7 8 9 10 11 12 13  binary_search(A, target): lo = 1, hi = size(A) while lo \u0026lt;= hi: mid = lo + (hi-lo)/2 if A[mid] == target: return mid else if A[mid] \u0026lt; target: lo = mid+1 else: hi = mid-1 // target was not found   Taking it further: the main theorem Consider a predicate p defined over some ordered set S (the search space). The search space consists of candidate solutions to the problem. We use the predicate to verify if a candidate solution is legal (does not violate some constraint) according to the definition of the problem.\n \u0026ldquo;Main theorem\u0026rdquo;: binary search can be used if and only if for all x in S, p(x) implies p(y) for all y \u0026gt; x\n We can use binary search to find the smallest legal solution (i.e. the smallest x for which p(x) is true) by following two steps:\n Designing a predicate. Note that we need to choose what the algorithm should find - either the first x for which p(x) is true or the last x for which p(x) is false. Proving that binary search can be applied to the predicate. This is where we use the main theorem, verifying that the conditions laid out in the theorem are satisfied.  These two parts are most often interleaved: when we think a problem can be solved by binary search, we aim to design the predicate so that it satisfies the condition in the main theorem.\nImplementation Given an array A (following array) and a target value (say 55), return the index of the first element in A equal to or greater than the target value.\nSample sequence:\n| 0 | 5 | 13 | 19 | 22 | 41 | 55 | 68 | 72 | 81 | 98 |\nSolution:\nPredicate p(A[x]): \u0026ldquo;Is A[x] greater than or equal to the target value?\u0026rdquo;.\nSearch space S (indices):\n| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |\nApply the predicate (with a target value of 55) to array A:\n| no | no | no | no | no | no | yes | yes | yes | yes | yes |\nImplementing the discrete algorithm:\n1 2 3 4 5 6 7 8 9 10 11 12 13  binary_search(lo, hi, p): while lo \u0026lt; hi: mid = lo + (hi-lo)/2 if p(mid) == true: hi = mid else: lo = mid+1 if p(lo) == false: complain // p(x) is false for all x in S! return lo // lo is the least x for which p(x) is true   Two crucial lines:\n hi = mid :\nWhen p(mid) is true, we can discard the second half of the search space, since the predicate is true for all elements in it (by the main theorem). However, we can not discard mid itself, since it may well be the first element for which p is true. This is why moving the upper bound to mid is as aggressive as we can do without introducing bugs. lo = mid+1\nIf p(mid) is false, we can discard the first half of the search space, but this time including mid. p(mid) is false so we don’t need it in our search space. This effectively means we can move the lower bound to mid+1.  If we wanted to find the last x for which p(x) is false:\n1 2 3 4 5 6 7 8 9 10 11 12  binary_search(lo, hi, p): while lo \u0026lt; hi: mid = lo + (hi-lo+1)/2 // note: rounds up instead of down if p(mid) == true: hi = mid-1 else: lo = mid if p(lo) == true: complain // p(x) is true for all x in S! return lo // lo is the greatest x for which p(x) is false   Explanation:\nIf we use mid = lo + (hi-lo)/2, which rounds down, consider what happens when running this code on some search space for which the predicate gives:\n| no | yes |\nThe code will get stuck in a loop. It will always select the first element as mid, but then will not move the lower bound because it wants to keep the no in its search space. So mid needs to round up instead of down.\nNote:\n  Why using mid = lo + (hi-lo)/2 instead of the usual mid = (lo+hi)/2?\n To avoid another potential rounding bug: in the first case, we want the division to always round down, towards the lower bound. But division truncates, so when lo+hi would be negative, it would start rounding towards the higher bound. Coding the calculation this way ensures that the number divided is always positive and hence always rounds as we want it to. To avoid integer overflow.    Just remember to always test the code on a two-element set where the predicate is false for the first element and true for the second.\n  Example: FairWorkload In the problem, a number of workers need to examine a number of filing cabinets. The cabinets are not all of the same size and we are told for each cabinet how many folders it contains. We are asked to find an assignment such that each worker gets a sequential series of cabinets to go through and that it minimizes the maximum amount of folders that a worker would have to look through.\nSolution:\n  Imagine that we have an unlimited number of workers. For some number MAX, we can calculate the minimum number of workers needed so that each worker has to examine no more than MAX folders (if this is possible) by greedy algorithm:\nWe assign first worker to the cabinet 1. Since the cabinets must be assigned in sequential order (a worker cannot examine cabinets 1 and 3 without examining 2 as well), it’s always optimal to assign him to the second cabinet as well, if this does not take him over the limit we introduced (MAX). If it would take him over the limit, we conclude that his work is done and assign a new worker to the second cabinet. We proceed in a similar manner until all the cabinets have been assigned and assert that we’ve used the minimum number of workers possible, with the artificial limit (MAX) we introduced. Note here that the number of workers is inversely proportional to MAX: the higher we set our limit, the fewer workers we will need.\n  What we want is the smallest MAX such that the number of workers required is less than or equal to the number of workers available. So the predicate is:\nCan the workload be spread so that each worker has to examine no more than x folders, with the limited number of workers available?\n  The code:\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  int getMostWork( vector folders, int workers ) { int n = folders.size(); int lo = *max_element( folders.begin(), folders.end() ); int hi = accumulate( folders.begin(), folders.end(), 0 ); while ( lo \u0026lt; hi ) { int x = lo + (hi-lo)/2; int required = 1, current_load = 0; for ( int i=0; i\u0026lt;n; ++i ) { if ( current_load + folders[i] \u0026lt;= x ) { // the current worker can handle it  current_load += folders[i]; } else { // assign next worker  ++required; current_load = folders[i]; } } if ( required \u0026lt;= workers ) hi = x; else lo = x+1; } return lo; }   To verify that the solution doesn’t lock up, we can use a small no/yes example with folders={1,1} and workers=1.\nThe overall complexity of the solution is O(n log SIZE), where SIZE is the size of the search space. This is very fast.\nIn this example, we used a greedy algorithm to evaluate the predicate. In other problems, evaluating the predicate can come down to anything from a simple math expression to finding a maximum cardinality matching in a bipartite graph.\nConclusion  Design a predicate which can be efficiently evaluated and so that binary search can be applied Decide on what you’re looking for and code so that the search space always contains that (if it exists) If the search space consists only of integers, test your algorithm on a two-element set to be sure it doesn’t lock up Verify that the lower and upper bounds are not overly constrained: it’s usually better to relax them as long as it doesn’t break the predicate. An all-around template looks like this according to my previous post on binary search:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  public class Solution { /** * @return first occurrence position of the target */ int findPosition(int[] nums, int target) { if (nums == null || nums.length == 0) { return -1; } int start = 0, end = nums.length - 1; while (start + 1 \u0026lt; end) { int mid = start + (end - start) / 2; if (nums[mid] == target) { end = mid; // for case of \u0026#34;return first position\u0026#34;  //start = mid; for case of \u0026#34;return last position\u0026#34;  //return mid; for case of \u0026#34;return any position\u0026#34;  } else if (nums[mid] \u0026lt; target) { start = mid; } else if (nums[mid] \u0026gt; target) { end = mid; } } // exchange the position of two [if statement] if want to return last postion  if (nums[start] == target) { return start; } if (nums[end] == target) { return end; } // target strictly between {A[start-1], A[start]}  // or strictly between {A[start], A[end]}  // or strictly between {A[end, A[end+1]}  return -1; } }   ","description":"","id":194,"section":"notes","tags":["algorithm"],"title":"Binary search review","uri":"https://nianze.ml/en/notes/2016/binary-search-review/"},{"content":"Build a graph to solve alien dictionary problem via DFS/BFS.\nAlien Dictionary There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.\nFor example,\nGiven the following words in dictionary,\n[ \u0026quot;wrt\u0026quot;, \u0026quot;wrf\u0026quot;, \u0026quot;er\u0026quot;, \u0026quot;ett\u0026quot;, \u0026quot;rftt\u0026quot; ] The correct order is: \u0026ldquo;wertf\u0026rdquo;.\nNote:\n You may assume all letters are in lowercase. If the order is invalid, return an empty string ([\u0026ldquo;abcd\u0026rdquo;,\u0026ldquo;ab\u0026rdquo;] is invalid). There may be multiple valid order of letters, return any one of them is fine.  Method 1: DFS Build the graph (post-adjacency list and visited list), then use DFS to build the correct order, while checking the loop at the same time.\nNote:\n visited[]: -1(not exist), 0(no pre-node), 1(visiting), 2(visited) The order of adding char into stringbuilder is reversed: add post nodes to sb firstly in order to avoid missing pre-nodes for current nodes later. e.g.: for correct order \u0026ldquo;abc\u0026rdquo;, if meet \u0026lsquo;b\u0026rsquo; firstly, build the sb as \u0026ldquo;cb\u0026rdquo;, and then meet \u0026lsquo;a\u0026rsquo;, build it as \u0026ldquo;cba\u0026rdquo;; otherwise, when meet \u0026lsquo;b\u0026rsquo;, build sb as \u0026ldquo;bc\u0026rdquo;, and then meet \u0026lsquo;a\u0026rsquo;, resulting in \u0026ldquo;bca\u0026rdquo;, which is incorrect.)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  private static int N = 26; public String alienOrder(String[] words) { boolean[][] adj = new boolean[N][N]; int[] visited = new int[N]; if (!buildGraph(words, adj, visited)) return \u0026#34;\u0026#34;; // \u0026#34;abcd\u0026#34; -\u0026gt; \u0026#34;ab\u0026#34;  StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; N; i++) { if (visited[i] == 0) { if (!dfs(adj, visited, sb, i)) return \u0026#34;\u0026#34;; } } return sb.reverse().toString(); } private boolean dfs(boolean[][] adj, int[] visited, StringBuilder sb, int i) { visited[i] = 1; // visiting  for (int j = 0; j \u0026lt; N; j++) { if (adj[i][j]) { // connected post nodes  if (visited[j] == 1) return false; // loop case  if (visited[j] == 0) { if (!dfs(adj, visited, sb, j)) return false; } } } visited[i] = 2; // visited  sb.append((char)(\u0026#39;a\u0026#39; + i)); return true; } private boolean buildGraph(String[] words, boolean[][] adj, int[] visited) { Arrays.fill(visited, -1); // init to not existed  for (int i = 0; i \u0026lt; words.length; i++) { for (char c : words[i].toCharArray()) visited[c - \u0026#39;a\u0026#39;] = 0; if (i \u0026gt; 0) { String w1 = words[i-1], w2 = words[i]; int len = Math.min(w1.length(), w2.length()), j = 0; for (; j \u0026lt; len; j++) { char c1 = w1.charAt(j), c2 = w2.charAt(j); if (c1 != c2) { adj[c1 - \u0026#39;a\u0026#39;][c2 - \u0026#39;a\u0026#39;] = true; break; } } if (j == len \u0026amp;\u0026amp; w1.length() \u0026gt; w2.length()) return false; // \u0026#34;abcd\u0026#34; -\u0026gt; \u0026#34;ab\u0026#34;  } } return true; }   Method 2: BFS Build the graph(post-adjacency list and visited list), then use Karn\u0026rsquo;s algorithm to do topological sort (essentially BFS).\nNote:\n visited[]: -1(not exist), 0(no pre-node), 1,2,3\u0026hellip;(pre-nodes number)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  public String alienOrder(String[] words) { List\u0026lt;Set\u0026lt;Integer\u0026gt;\u0026gt; adj = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 26; i++) adj.add(new HashSet\u0026lt;Integer\u0026gt;()); int[] degree = new int[26]; Arrays.fill(degree, -1); // init the adj and degree list  for (int i = 0; i \u0026lt; words.length; i++) { for (char c : words[i].toCharArray()) { if (degree[c-\u0026#39;a\u0026#39;] \u0026lt; 0) degree[c-\u0026#39;a\u0026#39;] = 0; } if (i \u0026gt; 0) { String w1 = words[i-1], w2 = words[i]; int len = Math.min(w1.length(), w2.length()); for (int j = 0; j \u0026lt; len; j++) { int c1 = w1.charAt(j) - \u0026#39;a\u0026#39;, c2 = w2.charAt(j) - \u0026#39;a\u0026#39;; if (c1 != c2) { if (!adj.get(c1).contains(c2)) { adj.get(c1).add(c2); degree[c2]++; } break; } if (j == len-1 \u0026amp;\u0026amp; w1.length() \u0026gt; w2.length()) return \u0026#34;\u0026#34;; // \u0026#34;abcd\u0026#34; -\u0026gt; \u0026#34;ab\u0026#34;  } } } // topological sort  Deque\u0026lt;Integer\u0026gt; q = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; degree.length; i++) { if (degree[i] == 0) q.offer(i); } StringBuilder sb = new StringBuilder(); while (!q.isEmpty()) { int i = q.poll(); sb.append((char) (\u0026#39;a\u0026#39; + i)); for (int j : adj.get(i)) { degree[j]--; if (degree[j] == 0) q.offer(j); } } for (int d : degree) if (d \u0026gt; 0) return \u0026#34;\u0026#34;; // has loop  return sb.toString(); }   ","description":"","id":195,"section":"notes","tags":["algorithm"],"title":"Alien dictionary","uri":"https://nianze.ml/en/notes/2016/alien-dictionary/"},{"content":"Use greedy algorigthm to solve task scheduleing problem.\nStarter Given tasks with cooldown time between the same task. Calculate the minimum total time to finish all the tasks. The order of tasks cannot be changed.\ne.g.:\nGiven tasks：[12323], and cooldown time is 3\nReturn: 7, since length of [1 2 3 _ _ 2 3] is 7\nMethod: Use hashmap to store the most recent same tasks\u0026rsquo;s time\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public static int min_time(int[] tasks, int interval){ if(tasks == null || tasks.length == 0){ return 0; } Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;Integer, Integer\u0026gt;(); int time = 0; for(int task : tasks){ Integer task_last_time = map.get(task); if(task_last_time != null \u0026amp;\u0026amp; task_last_time + interval + 1 \u0026gt; time){ time = task_last_time + interval + 1; } map.put(task, time); time++; } return time; } // Improve: space complexity a little to no more than O(n)  // use LinkedHashMap to remove the elder task that exceeds the cooldown time  Map\u0026lt;K,V\u0026gt; map = new LinkedHashMap\u0026lt;K,V\u0026gt;(int cooldown, 1.0f) { // load factor 1.0  @Override protected boolean removeEldestEntry(Map.Entry\u0026lt;K,V\u0026gt; eldest) { return size() \u0026gt; cooldown; } };   Follow up: What if the order is OK to change? Method: Greedy algorithm - always look for the task with highest remaining time at each time.\nThere are two version of implementation:\n Use priorityQueue to sort the tasks with highest remaining times, time: O(nlog(n)), where n is the total number of tasks, space: O(n) Use two array to store the remaining times and available time for each task, and each time scan these two arraies to find the appropriate task time: O(klog(n)), where k is the number of task kinds, space: O(n)  Using method One：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public int schedule(int[] tasks, int cooldown) { HashMap\u0026lt;Integer, Integer\u0026gt; freqMap = new HashMap\u0026lt;\u0026gt;(); for (int t : tasks) { freqMap.put(t, freqMap.getOrDefault(t, 0) + 1); } Queue\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt; maxHeap = new PriorityQueue\u0026lt;\u0026gt;(freqMap.size(), new Comparator\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt;() { @Override public int compare(Map.Entry\u0026lt;Integer, Integer\u0026gt; e1, Map.Entry\u0026lt;Integer, Integer\u0026gt; e2) { return e2.getValue() - e1.getValue(); } }); Deque\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt; waitQueue = new ArrayDeque\u0026lt;\u0026gt;(); HashMap\u0026lt;Integer, Integer\u0026gt; timeMap = new HashMap\u0026lt;\u0026gt;(); int time = 0; maxHeap.addAll(freqMap.entrySet()); while (!maxHeap.isEmpty() || !waitQueue.isEmpty()) { if (!maxHeap.isEmpty()) { Map.Entry\u0026lt;Integer, Integer\u0026gt; cur = maxHeap.poll(); time++; timeMap.put(cur.getKey(), time); cur.setValue(cur.getValue() - 1); waitQueue.offer(cur); if (waitQueue.size() \u0026lt; cooldown + 1) continue; Map.Entry\u0026lt;Integer, Integer\u0026gt; front = waitQueue.poll(); if (front.getValue() \u0026gt; 0) maxHeap.offer(front); } else { Map.Entry\u0026lt;Integer, Integer\u0026gt; front = waitQueue.poll(); if (front.getValue() \u0026gt; 0) { maxHeap.offer(front); time = timeMap.get(front.getKey()) + cooldown; } } } return time; }   Similar question: LC358 Rearrange String k Distance Apart\nMethod one:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  public String rearrangeString(String str, int k) { HashMap\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (char c : str.toCharArray()) { map.put(c, map.getOrDefault(c, 0) + 1); } Queue\u0026lt;Map.Entry\u0026lt;Character, Integer\u0026gt;\u0026gt; maxHeap = new PriorityQueue\u0026lt;\u0026gt;(map.size(), new Comparator\u0026lt;Map.Entry\u0026lt;Character, Integer\u0026gt;\u0026gt;() { @Override public int compare(Map.Entry\u0026lt;Character, Integer\u0026gt; e1, Map.Entry\u0026lt;Character, Integer\u0026gt; e2) { return e2.getValue() - e1.getValue(); } }); Deque\u0026lt;Map.Entry\u0026lt;Character, Integer\u0026gt;\u0026gt; waitQueue = new ArrayDeque\u0026lt;\u0026gt;(); maxHeap.addAll(map.entrySet()); StringBuilder sb = new StringBuilder(); while (!maxHeap.isEmpty()) { Map.Entry\u0026lt;Character, Integer\u0026gt; cur = maxHeap.poll(); sb.append(cur.getKey()); cur.setValue(cur.getValue()-1); waitQueue.offer(cur); if (waitQueue.size() \u0026lt; k) continue; Map.Entry\u0026lt;Character, Integer\u0026gt; front = waitQueue.poll(); if (front.getValue() \u0026gt; 0) maxHeap.offer(front); } return sb.length() == str.length() ? sb.toString() : \u0026#34;\u0026#34;; }   Method two:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  public String rearrangeString(String str, int k) { int[] count = new int[26]; int[] valid = new int[26]; StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; str.length(); i++) { count[str.charAt(i) - \u0026#39;a\u0026#39;]++; } for (int i = 0; i \u0026lt; str.length(); i++) { int c = findNext(count, valid, i); if (c == -1) return \u0026#34;\u0026#34;; sb.append((char)(\u0026#39;a\u0026#39;+c)); count[c] -= 1; valid[c] = i + k; } return sb.toString(); } private int findNext(int[] count, int[] valid, int index) { int pos = -1, max = -1; for (int i = 0; i \u0026lt; 26; i++) { if (count[i] \u0026gt; 0 \u0026amp;\u0026amp; count[i] \u0026gt; max \u0026amp;\u0026amp; index \u0026gt;= valid[i]) { pos = i; max = count[i]; } } return pos; }   ","description":"","id":196,"section":"notes","tags":["algorithm"],"title":"Task schedule - greedy algorithm","uri":"https://nianze.ml/en/notes/2016/task-schedule/"},{"content":"Summary on LinkedList reversing.\nStarter Special case: LC206 reverse all the nodes in one pass: 1 2 3 4 5 6 7 8 9 10  public ListNode reverseList(ListNode head) { ListNode newHead = null; while (head != null) { ListNode next = head.next; head.next = newHead; newHead = head; head = next; } return newHead; }   General case: LC92 reverse nodes from position m to n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public ListNode reverseBetween(ListNode head, int m, int n) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy, end, cur; for (int i = 0; i \u0026lt; m-1; i++) { pre = pre.next; } end = pre.next; cur = end.next; for (int i = 0; i \u0026lt; n - m; i++) { end.next = cur.next; cur.next = pre.next; pre.next = cur; cur = end.next; } return dummy.next; }   Main dish: LC25 Reverse Nodes in k-Groups 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  /** * Reverse a link list between pre and next exclusively * e.g.: * 0-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;6 * | | * pre next * * after call pre = reverse(pre, next): * 0-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;4-\u0026gt;5-\u0026gt;6 * | | * pre next * @param pre * @param next * @return the precedence of parameter next */ private static ListNode reverse(ListNode pre, ListNode next) { ListNode end = pre.next, cur = end.next; while (cur != next) { end.next = cur.next; cur.next = pre.next; pre.next = cur; cur = end.next; } return end; } public ListNode reverseKGroup(ListNode head, int k) { if (head == null || k == 1) return head; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; int i = 0; while (head != null) { head = head.next; if (++i % k == 0) pre = reverse(pre, head); } return dummy.next; } /** * Note: the while loop is the same as following process, which is easier to understand: * while(head != null){ * i++; * if(i % k ==0){ * pre = reverse(pre, head.next); * head = pre.next; * }else { * head = head.next; * } * } */ }   ","description":"","id":197,"section":"notes","tags":["algorithm"],"title":"LinkedList reversing","uri":"https://nianze.ml/en/notes/2016/linkedlist-reversing/"},{"content":"Two pointer template to solve substring problem.\nLC76 Minimum Window Substring Method: Two Pointer with map  Scanning from left to right, keep the head and length of minimum window substring so far. Use an int[256] array or a HashMap to store target charater counts.  1 2 3 4 5 6 7 8 9 10 11 12 13  public String minWindow(String s, String t) { int[] map = new int[256]; for (char c : t.toCharArray()) { map[c]++; } int start = 0, end = 0, len = Integer.MAX_VALUE, head = 0, count = t.length(); while (end \u0026lt; s.length()) { if (map[s.charAt(end++)]-- \u0026gt; 0) count--; while (count == 0) { if (end - start \u0026lt; len) len = end - (head = start); if (map[s.charAt(start++)]++ == 0) count++; } } return len == Integer.MAX_VALUE ? \u0026#34;\u0026#34; : s.substring(head, head + len); }   Template1 For most substring problem, we are given a string and need to find a substring of it which satisfy some restrictions. A general way is to use a hashmap assisted with two pointers.\nOne thing needs to be mentioned is that when asked to find maximum substring, we should update maximum after the inner while loop to guarantee that the substring is valid. On the other hand, when asked to find minimum substring, we should update minimum inside the inner while loop.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  int findSubstring(string s){ int[] map = new int[256]; int counter; // check whether the substring is valid  int start = 0, end = 0; //two pointers, one point to tail and one head  int d; //the length of substring  for() { /* initialize the hash map here */ } while(end \u0026lt; s.length()){ if(map[s.charAt(end++)]-- ?){ /* modify counter here */ } while(/* counter condition */){ /* update d here if finding minimum */ //increase start to make it invalid/valid again  if(map[s[start++]]++ ?){ /*modify counter here*/ } } /* update d here if finding maximum*/ } return d; }    https://discuss.leetcode.com/topic/30941/here-is-a-10-line-template-that-can-solve-most-substring-problems\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":198,"section":"notes","tags":["algorithm"],"title":"Substring type problem's template","uri":"https://nianze.ml/en/notes/2016/substring-template/"},{"content":"Several ways to remove invalid parentheses problem.\nStarter  Return only one possible result\n Method: Two pass with counter  Scanning from left to right, ending up removing extra \u0026lsquo;)\u0026rsquo; Scanning from right to left, ending up removing extra \u0026lsquo;(\u0026rsquo;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  public String removeInvalidParantheses(String s) { StringBuilder firstPass = new StringBuilder(); int counter = 0; for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); if (c == \u0026#39;(\u0026#39;) { counter++; firstPass.append(\u0026#39;(\u0026#39;); } else if (c == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; counter \u0026gt; 0) { counter--; firstPass.append(\u0026#39;)\u0026#39;); } else if (c != \u0026#39;)\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;(\u0026#39;) { firstPass.append(c); } } if (counter == 0) return firstPass.toString(); counter = 0; StringBuilder sb = new StringBuilder(); for(int i = firstPass.length() - 1; i \u0026gt;= 0; i--) { char c = firstPass.charAt(i); if (c == \u0026#39;)\u0026#39;) { counter--; sb.append(\u0026#39;)\u0026#39;); } else if (c == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; counter \u0026lt; 0) { counter++; sb.append(\u0026#39;(\u0026#39;); } else if (c != \u0026#39;)\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;(\u0026#39;) { sb.append(c); } } return sb.reverse().toString(); }   Main dish (follow up)  Return all the possible results\n Method 1: Two pass with DFS  same idea as starter question: using dfs searching for valid candidate without extra \u0026lsquo;)\u0026rsquo;, then reverse the string and search for the second pass to remove all the extra \u0026lsquo;(\u0026rsquo; for continuous \u0026lsquo;)\u0026rsquo;, say \u0026ldquo;())\u0026rdquo;, always remove the first \u0026lsquo;)\u0026rsquo; firstly, so \u0026ldquo;())\u0026rdquo; -\u0026gt; \u0026ldquo;()\u0026quot;: for j:[prev_j ~ i], if (s[j] == par1 \u0026amp;\u0026amp; (j == prev_j || s[j-1] != par1)), remove s.charAt(j) each recursive call, store previous i to prev_i to indicate that first half of string before i is valid, so no need to check again each recursive call, store previous j to prev_j in order to prevent duplicate answers. e.g.:\nif no prev_j stored, it\u0026rsquo;s hard to prevent the same result from two different ching branches:  \u0026ldquo;()a)a)\u0026rdquo; -\u0026gt; \u0026ldquo;(a)a)\u0026rdquo; -\u0026gt; \u0026ldquo;(aa)\u0026rdquo; \u0026ldquo;()a)a)\u0026rdquo; -\u0026gt; \u0026ldquo;()aa)\u0026rdquo; -\u0026gt; \u0026ldquo;(aa)\u0026rdquo;   Time : every path generates one valid answer, if there\u0026rsquo;s k valid answer, the search will have k leaves. Since each recursive call requires O(n) time from string atenatino. O(n*m) may be fair enough to describe the time complexity, where n is length of string and m is the total nodes (numver of all the rec calls) in the ch tree Space: O(n*k) due to stringbuilder, k is the number of valid answer, n is the length of string  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public List\u0026lt;String\u0026gt; removeInvalidParentheses(String s) { List\u0026lt;String\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); remove(s, ans, 0, 0, new char[]{\u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;}); return ans; } private void remove(String s, List\u0026lt;String\u0026gt; ans, int prev_i, int prev_j, char[] par) { for (int count = 0, i = prev_i; i \u0026lt; s.length(); i++) { if (s.charAt(i) == par[0]) count++; if (s.charAt(i) == par[1]) count--; if (count \u0026gt;= 0) continue; for (int j = prev_j; j \u0026lt;= i; j++) { // count \u0026lt; 0, there\u0026#39;s extra par[1]  if (s.charAt(j) == par[1] \u0026amp;\u0026amp; (j == prev_j || s.charAt(j-1) != par[1])) { remove(s.substring(0,j) + s.substring(j+1), ans, i, j, par); } } return; } StringBuilder reversed = new StringBuilder(); for (int i = s.length() - 1; i \u0026gt;= 0; i--) { reversed.append(s.charAt(i)); } if (par[0] == \u0026#39;(\u0026#39;) { remove(reversed.toString(), ans, 0, 0, new char[]{\u0026#39;)\u0026#39;, \u0026#39;(\u0026#39;}); } else { ans.add(reversed.toString()); } }   Method 2: BFS Naive way of thinking:\nFor a string with n length, each char have 2 states \u0026ldquo;keep/remove\u0026rdquo;, which is 2^n states, and each state requires checkValid, which runs in O(n). Together the BFS require O(n*2^n).\nIdeally, it should be O(C(n,k) + n), where k is the number of chars needs removal. To avoid generating duplicate strings, refer to this post\n","description":"","id":199,"section":"notes","tags":["algorithm"],"title":"Remove Invalid Parentheses","uri":"https://nianze.ml/en/notes/2016/invalid-parentheses/"},{"content":"Convert Char to String.\n Use String.valueOf(char) Use Character.toString(char)  Note: this method simply returns a call to String.valueOf(char)   Use string concatenation String s = \u0026quot;\u0026quot; + 'c'  Note: this compiles down to  1  String s = new StringBuilder().append(\u0026#34;\u0026#34;).append(\u0026#39;c\u0026#39;).toString();    which is less efficient because StringBuilder is backed by char[] (over-allocated by StringBuilder() to 16) and this array will be copied to the resulting String. On the other hand, String.valueOf(char) wraps the char in a single-element array and passes it to the package private constructor String(char[], boolean), which avoids the array copy.1     http://stackoverflow.com/questions/8172420/how-to-convert-a-char-to-a-string-in-java\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":200,"section":"notes","tags":["algorithm"],"title":"Convert Char to String in Java","uri":"https://nianze.ml/en/notes/2016/char-to-string/"},{"content":"Deque vs. LinkedList vs. Stack\nQuote From javadoc:\n ArrayDeque is likely to be faster than Stack when used as a stack, and faster than LinkedList when used as a queue.\n Use ArrayDeque or LinkedList as queue1 Cons of Linked List  Linked structures are the worst structure to iterate with a cache miss on each element Have to allocating a node for each item to insert, which essentially involves JVM/OS and expensive For pop() operation, it mark internal nodes eligible for garbage collection and that\u0026rsquo;s more work behind the scene  Pros of Linked List  When removing the current element during iteration, LinkedList has better performance Worth to note: LinkedList supports null element  When use ArrayDeque as queue  if only need to add/remove of both ends, use ArrayDeque e.g.: when using BFS, consider ArrayDeque first.  Use ArrayDeque or Stack as Stack2 Deque exposes a set of operations which is all about being able to fetch/add/remove items from the start or end of a collection, iterate etc. There\u0026rsquo;s deliverately no way to access an element by position, which Stack exposes because it\u0026rsquo;s a subclass of Vector, making the Stack inconsistent.\n http://stackoverflow.com/questions/6163166/why-is-arraydeque-better-than-linkedlist\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n http://stackoverflow.com/questions/12524826/why-should-i-use-deque-over-stack\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":201,"section":"notes","tags":["algorithm"],"title":"When use Dueque","uri":"https://nianze.ml/en/notes/2016/dueque/"},{"content":"DFS, BFS and Union-find comparison.\nJudge if the given graph is a tree Remember to check 2 things:\n whether the graph has cycle whether number connected component(s) is more than 1  DFS: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // time: O(max(E,n)) space: O(n) for adjacency list  public boolean validTree(int n, int[][] edges) { int[] visited = new int[n]; List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; adjList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { adjList.add(new ArrayList\u0026lt;Integer\u0026gt;()); } for (int[] e : edges) { adjList.get(e[0]).add(e[1]); adjList.get(e[1]).add(e[0]); } if (hasCycle(-1, 0, visited, edges)) { return false; } // cycle case  for (int i : visited) { if (i == 0) { return false; } } // not single connected components  return true; } private boolean hasCycle(int prev, int cur, int[] visited, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; adjList) { visited[cur] = 1; // 1 means current vertex is being visited  for (Integer succ : adjList.get(cur)) { if (succ == prev) continue; // exclude curr\u0026#39;s prev node  if (visited[succ] == 1) { return true; } // has cycle  if (visited[succ] == 0) { if (hasCycle(cur, succ, visited, adjList)) { return true; } } } visited[cur] = 2; // complete visiting  return false; }   BFS: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // O(max(E,n)), space: O(n) for adjacency list  public boolean validTree(int n, int[][] edges) { int[] visited = new int[n]; List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; adjList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { adjList.add(new ArrayList\u0026lt;Integer\u0026gt;()); } for (int[] e : edges) { adjList.get(e[0]).add(e[1]); adjList.get(e[1]).add(e[0]); } Deque\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.addLast(0); visited[0] = 1; // mark curr node as being visited  while (!queue.isEmpty()) { int cur = queue.removeFirst(); for (Integer succ : adjList.get(cur)) { if (visited[succ] == 1) { return false; } // has cycle  if (visited[succ] == 0) { visited[succ] = 1; queue.addLast(succ); } } visited[cur] = 2; // compete visiting  } for (int i : visited) { if (i == 0) { return false; } } // not single connected components  return true; }   Union-find: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  // time: O(E), space: O(n) for union-find set  class UnionFind { int[] parent; int[] rank; int count; UionFind(int n) { parent = new int[n]; rank = new int[n]; count = n; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; } // initially each node\u0026#39;s paren is itself  } int find(int x) { if (x != parent[x]) { x = find(parent[x]); // path compression  } return parent[x]; } boolean union(int x, int y) { int X = find(x), Y = find(y); if (X == Y) { return false; } if (rank[Y] \u0026lt; rank[X]) { parent[Y] = X; } // Y is lower  else if (rank[X] \u0026lt; rank[Y]) { parent[X] = Y;} // X is lower  else { // rank of X, Y is the same  parent[Y] = X; rank[X]++; } count--; return true; } } public boolean validTree(int n, int[][] edges) { UnionFind uf = new UnionFind(n); for (int[] edge : edges) { int x = edge[0], y = edge[1]; if (!uf.union(x, y)) { return false; } // has cycle  } return uf.count == 1; }   ","description":"","id":202,"section":"notes","tags":["algorithm"],"title":"Valid tree","uri":"https://nianze.ml/en/notes/2016/valid-tree/"},{"content":"What should be noted when doing binary search.\nBS search - search for first or last target\u0026rsquo;s position Key points\n start + 1 \u0026lt; end -\u0026gt; avoid never-end loop start + (end - start) / 2 -\u0026gt; avoid stack overflow nums[mid] judgement depends on the purpose:  start = mid; for case of \u0026ldquo;return last position\u0026rdquo; end = mid; for case of \u0026ldquo;return first position\u0026rdquo; return mid; for case of \u0026ldquo;return any position\u0026rdquo;   After the while loop, start + 1 = end, there may are 5 possible scenarios:  target \u0026lt; nums[start], now start == 0 target == nums[start] nums[start] \u0026lt; target \u0026lt; nums[end] `target == A[end] nums[end] \u0026lt; target, now end = nums.length - 1;    Binary search template: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  public class Solution { /** * @return first occurrence position of the target */ int findPosition(int[] nums, int target) { if (nums == null || nums.length == 0) { return -1; }\tint start = 0, end = nums.length - 1; while (start + 1 \u0026lt; end) { int mid = start + (end - start) / 2; if (nums[mid] == target) { end = mid; // for case of \u0026#34;return first position\u0026#34;  //start = mid; for case of \u0026#34;return last position\u0026#34;  //return mid; for case of \u0026#34;return any position\u0026#34;  } else if (nums[mid] \u0026lt; target) { start = mid; } else if (nums[mid] \u0026gt; target) { end = mid; } }\t// exchange the position of two [if statement] if want to return last postion  if (nums[start] == target) { return start; } if (nums[end] == target) { return end; } // target strictly between {A[start-1], A[start]}  // or strictly between {A[start], A[end]}  // or strictly between {A[end, A[end+1]}  return -1; } }    Note 1: It\u0026rsquo;s a good habit to always to include trivial test case at first line:  1 2 3  if (nums == null || nums.length == 0) { return -1; }    Note 2: Remember to consider all the corner case at the end:  1 2 3  if (target \u0026lt;= start) { return ??; } if (target \u0026lt;= end) { return ??; } return ???; // corner case!   ","description":"","id":203,"section":"notes","tags":["algorithm"],"title":"Binary search basic","uri":"https://nianze.ml/en/notes/2016/binary-search/"},{"content":"东风夜放花千树，更吹落、星如雨。\n宝马雕车香满路。凤箫声动，玉壶光转，一夜鱼龙舞。\nThis music is from Spirited Away (千と千尋の神隠し), which is a 2001 Japanese animated fantasy film written and directed by Hayao Miyazaki and produced by Studio Ghibli. The melody is peaceful and elegant, which is written by Youmi Kimura (木村 弓), a Japanese singer and lyre performer.\nActually, I choose this one because this is chosen as the library\u0026rsquo;s closing-door music when I\u0026rsquo;m a undergrad.\nEverytime the music is on, we know it is 10:00pm and it is time to go back to dorm. At that time I always prefer to stay as late as possible in the library until the guard cruising around to drive me away. If the assignment is still not yet finished and deadline is approaching, I might even decided to go to the lab building around, finishing the remaining part.\nSometimes when I stepping out of the library building, the Big Dipper lied right ahead of me on the sky, and I would wear my headphones, turn on the music, and ride my bycicle back to the dorm. On the way, thinking about everything, past and future, I could only felt the wind.\nAnd all those days are spirited away:\n ","description":"","id":204,"section":"posts","tags":["clarinet","music"],"title":"Spirited away","uri":"https://nianze.ml/en/posts/2016/spirited-away/"},{"content":"As the new semester approaches, I finished two more clarinet covers\nHello especially The music is from ED of\nSilver Spoon, which\nis full of pastorale and optimism. Every time\nI hear the song, I recall the happy daily life of Yuugo Hachiken in his\nagricultural school. May you also enjoy this happiness as I do.\n  つないだ手 Another ED from Fullmetal Alchemist FA, also from Japanese manga artist\nHiromu Arakawa(荒川 弘). Below\nis her self-portray of bespectacled cow.\n  I have to say Hiromi\u0026rsquo;s manga is always my type. I can find an optimism from\nevery person in her manga, which makes me think about the good side of life.\nAnd then you\u0026rsquo;ll know that:\n Take it easy, and all is well.\n ","description":"","id":205,"section":"posts","tags":["clarinet","music"],"title":"New semester is coming","uri":"https://nianze.ml/en/posts/2016/new-semester/"},{"content":"My new year\u0026rsquo;s first cover is for Hiroyuki Sawano!\nAnother beautiful piece from Hiroyuki Sawano I have to admit that I\u0026rsquo;m a big fan of Hiroyuki Sawano. Every time I listen to his music, my heart is always filled with strength.\nThis Aesthetic is from his original album Musica released in 2009-07-15.\nAesthetic   Longing for you day and in dream\n盼望著你白天與夜夢中\nI\u0026rsquo;m hoping you are here and leading my way\n我期盼你在身邊牽引著我向前\nYou steers my road anytime I need\n你總在我需要時引領著我\nIf you walk away，I will follow you\n如果你離開了，我將會跟隨著你\nTrying my life with your sacred gifts you gave to me\n盡我一生攜帶直著你贈予我的神聖禮物\nI won\u0026rsquo;t vain and succeed it as your precious soul\n我向你高貴的靈魂看齊即使功成名就也不驕傲自負\nHolding your hand\n緊握著你的手\nAnd I\u0026rsquo;m walking through the all of the world\n在黯淡的天空中\nCarrying your wish like the Venus in the dim sky\n緊擁著你如金星般閃耀的夢想將足跡遍佈整個世界\n","description":"","id":206,"section":"posts","tags":["clarinet","music"],"title":"New year cover - Aesthetic","uri":"https://nianze.ml/en/posts/2016/aesthetic/"},{"content":"A mark on the end of my first semester in Cornell.\nFinally\u0026hellip; After a busy semester, finally I have some time to try some new pieces of music:\n運命と恋心   Hope this winter be a productive one!\nBTW, the cover image is credit to pixiv user 駒＠ついった:\n呪縛 by 駒＠ついった on pixiv\n","description":"","id":207,"section":"posts","tags":["clarinet","music"],"title":"End of my first semester in Cornell","uri":"https://nianze.ml/en/posts/2015/end-of-semester/"},{"content":"A small piece of music to celebrating the Halloween.\nCelebrating the Halloween! To celebrate the Halloween, I picked this piece of music, with some photos I took recently in the campus. Hope the magic fantasy style able to match with those old buildings in Cornell.\nHope you enjoy!\nIt\u0026rsquo;s only the fairytale  ","description":"","id":208,"section":"posts","tags":["clarinet","music"],"title":"Halloween celebration","uri":"https://nianze.ml/en/posts/2015/halloween-celebration/"},{"content":"Some of my early clarinet cover is collected here in this article.\nWhy I launched the clarinet cover project In the summer of 2015, I started recording my clarinet cover inspired by ShonHayashi when I accidentally found his Youtube channel. At that time, actually, I haven\u0026rsquo;t touched my clarinet for a long time, partially due to my old opinion that clarinet is such a classical instrument that it is never a good fit for performing mordern style music.\nAnd I changed my opinion since I heard ShonHayashi\u0026rsquo;s clarinet cover on Vocaloid then.\n \u0026ldquo;Whoa! He plays the clarinet so well, why not to have a try muself just like him?\u0026rdquo;\n In my mind, clarinet is not as expressive as violin or piano: the voice character of clarinet feels like silk, so it is hard to handle music with too strong emotions - maybe that\u0026rsquo;s why it is hard to see clarinet in Rock music :). However, it\u0026rsquo;s worth a try for music with elegant and sweet styles. Especially a good fit to imitate human voice1.\nSo, since I happen to know how to play this instrument, why not to have fun with it, and play some music that once touched me?\n  Listen to the Clarinet by sherrae78, on DeviantArt.  My early covers in summer of 2015 At that moment, I did not know how to transcribe a sheet on my own, so I simply picked some of my favorite covers from ShonHayashi. All of these clarinet sheets below are transcribed by him.\n地球最後の告白を   Let it go   Jenga (ジェンガ)   Vogel im Käfig   ODDS \u0026amp; ENDS    Reference from what Mozart wrote to Stadler \u0026ldquo;Never should I have thought that a clarinet could be capable of imitating the human voice as it was imitated by you.\u0026rdquo;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":209,"section":"posts","tags":["clarinet","vocaloid","music"],"title":"Early collection of clarinet cover","uri":"https://nianze.ml/en/posts/2015/clarinet-cover-collection/"}]