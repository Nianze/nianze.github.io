{
  "title": "Remove Invalid Parentheses",
  "content": "Several ways to remove invalid parentheses problem.\nStarter Return only one possible result\nMethod: Two pass with counter Scanning from left to right, ending up removing extra \u0026lsquo;)\u0026rsquo; Scanning from right to left, ending up removing extra \u0026lsquo;(\u0026rsquo; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public String removeInvalidParantheses(String s) { StringBuilder firstPass = new StringBuilder(); int counter = 0; for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); if (c == \u0026#39;(\u0026#39;) { counter++; firstPass.append(\u0026#39;(\u0026#39;); } else if (c == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; counter \u0026gt; 0) { counter--; firstPass.append(\u0026#39;)\u0026#39;); } else if (c != \u0026#39;)\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;(\u0026#39;) { firstPass.append(c); } } if (counter == 0) return firstPass.toString(); counter = 0; StringBuilder sb = new StringBuilder(); for(int i = firstPass.length() - 1; i \u0026gt;= 0; i--) { char c = firstPass.charAt(i); if (c == \u0026#39;)\u0026#39;) { counter--; sb.append(\u0026#39;)\u0026#39;); } else if (c == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; counter \u0026lt; 0) { counter++; sb.append(\u0026#39;(\u0026#39;); } else if (c != \u0026#39;)\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;(\u0026#39;) { sb.append(c); } } return sb.reverse().toString(); } Main dish (follow up) Return all the possible results\nMethod 1: Two pass with DFS same idea as starter question: using dfs searching for valid candidate without extra \u0026lsquo;)\u0026rsquo;, then reverse the string and search for the second pass to remove all the extra \u0026lsquo;(\u0026rsquo; for continuous \u0026lsquo;)\u0026rsquo;, say \u0026ldquo;())\u0026rdquo;, always remove the first \u0026lsquo;)\u0026rsquo; firstly, so \u0026ldquo;())\u0026rdquo; -\u0026gt; \u0026ldquo;()\u0026rdquo;: for j:[prev_j ~ i], if (s[j] == par1 \u0026amp;\u0026amp; (j == prev_j || s[j-1] != par1)), remove s.charAt(j) each recursive call, store previous i to prev_i to indicate that first half of string before i is valid, so no need to check again each recursive call, store previous j to prev_j in order to prevent duplicate answers. e.g.:\nif no prev_j stored, it\u0026rsquo;s hard to prevent the same result from two different ching branches: \u0026ldquo;()a)a)\u0026rdquo; -\u0026gt; \u0026ldquo;(a)a)\u0026rdquo; -\u0026gt; \u0026ldquo;(aa)\u0026rdquo; \u0026ldquo;()a)a)\u0026rdquo; -\u0026gt; \u0026ldquo;()aa)\u0026rdquo; -\u0026gt; \u0026ldquo;(aa)\u0026rdquo; Time : every path generates one valid answer, if there\u0026rsquo;s k valid answer, the search will have k leaves. Since each recursive call requires O(n) time from string atenatino. O(n*m) may be fair enough to describe the time complexity, where n is length of string and m is the total nodes (numver of all the rec calls) in the ch tree Space: O(n*k) due to stringbuilder, k is the number of valid answer, n is the length of string 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public List\u0026lt;String\u0026gt; removeInvalidParentheses(String s) { List\u0026lt;String\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); remove(s, ans, 0, 0, new char[]{\u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;}); return ans; } private void remove(String s, List\u0026lt;String\u0026gt; ans, int prev_i, int prev_j, char[] par) { for (int count = 0, i = prev_i; i \u0026lt; s.length(); i++) { if (s.charAt(i) == par[0]) count++; if (s.charAt(i) == par[1]) count--; if (count \u0026gt;= 0) continue; for (int j = prev_j; j \u0026lt;= i; j++) { // count \u0026lt; 0, there\u0026#39;s extra par[1] if (s.charAt(j) == par[1] \u0026amp;\u0026amp; (j == prev_j || s.charAt(j-1) != par[1])) { remove(s.substring(0,j) + s.substring(j+1), ans, i, j, par); } } return; } StringBuilder reversed = new StringBuilder(); for (int i = s.length() - 1; i \u0026gt;= 0; i--) { reversed.append(s.charAt(i)); } if (par[0] == \u0026#39;(\u0026#39;) { remove(reversed.toString(), ans, 0, 0, new char[]{\u0026#39;)\u0026#39;, \u0026#39;(\u0026#39;}); } else { ans.add(reversed.toString()); } } Method 2: BFS Naive way of thinking:\nFor a string with n length, each char have 2 states \u0026ldquo;keep/remove\u0026rdquo;, which is 2^n states, and each state requires checkValid, which runs in O(n). Together the BFS require O(n*2^n).\nIdeally, it should be O(C(n,k) + n), where k is the number of chars needs removal. To avoid generating duplicate strings, refer to this post\n",
  "summary": "Several ways to remove invalid parentheses problem.\n",
  "date": "2016-11-06T00:00:00Z",
  "lastmod": "2016-11-06T00:00:00Z",
  "permalink": "https://nianze.github.io/en/notes/2016/invalid-parentheses/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["algorithm"],
  "categories": ["coding"],
  "series": ["algorithm"]
}
