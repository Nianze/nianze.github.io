{
  "title": "Task schedule - greedy algorithm",
  "content": "Use greedy algorigthm to solve task scheduleing problem.\nStarter Given tasks with cooldown time between the same task. Calculate the minimum total time to finish all the tasks. The order of tasks cannot be changed.\ne.g.:\nGiven tasks：[12323], and cooldown time is 3\nReturn: 7, since length of [1 2 3 _ _ 2 3] is 7\nMethod: Use hashmap to store the most recent same tasks\u0026rsquo;s time\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public static int min_time(int[] tasks, int interval){ if(tasks == null || tasks.length == 0){ return 0; } Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;Integer, Integer\u0026gt;(); int time = 0; for(int task : tasks){ Integer task_last_time = map.get(task); if(task_last_time != null \u0026amp;\u0026amp; task_last_time + interval + 1 \u0026gt; time){ time = task_last_time + interval + 1; } map.put(task, time); time++; } return time; } // Improve: space complexity a little to no more than O(n) // use LinkedHashMap to remove the elder task that exceeds the cooldown time Map\u0026lt;K,V\u0026gt; map = new LinkedHashMap\u0026lt;K,V\u0026gt;(int cooldown, 1.0f) { // load factor 1.0 @Override protected boolean removeEldestEntry(Map.Entry\u0026lt;K,V\u0026gt; eldest) { return size() \u0026gt; cooldown; } }; Follow up: What if the order is OK to change? Method: Greedy algorithm - always look for the task with highest remaining time at each time.\nThere are two version of implementation:\nUse priorityQueue to sort the tasks with highest remaining times, time: O(nlog(n)), where n is the total number of tasks, space: O(n) Use two array to store the remaining times and available time for each task, and each time scan these two arraies to find the appropriate task time: O(klog(n)), where k is the number of task kinds, space: O(n) Using method One：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public int schedule(int[] tasks, int cooldown) { HashMap\u0026lt;Integer, Integer\u0026gt; freqMap = new HashMap\u0026lt;\u0026gt;(); for (int t : tasks) { freqMap.put(t, freqMap.getOrDefault(t, 0) + 1); } Queue\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt; maxHeap = new PriorityQueue\u0026lt;\u0026gt;(freqMap.size(), new Comparator\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt;() { @Override public int compare(Map.Entry\u0026lt;Integer, Integer\u0026gt; e1, Map.Entry\u0026lt;Integer, Integer\u0026gt; e2) { return e2.getValue() - e1.getValue(); } }); Deque\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt; waitQueue = new ArrayDeque\u0026lt;\u0026gt;(); HashMap\u0026lt;Integer, Integer\u0026gt; timeMap = new HashMap\u0026lt;\u0026gt;(); int time = 0; maxHeap.addAll(freqMap.entrySet()); while (!maxHeap.isEmpty() || !waitQueue.isEmpty()) { if (!maxHeap.isEmpty()) { Map.Entry\u0026lt;Integer, Integer\u0026gt; cur = maxHeap.poll(); time++; timeMap.put(cur.getKey(), time); cur.setValue(cur.getValue() - 1); waitQueue.offer(cur); if (waitQueue.size() \u0026lt; cooldown + 1) continue; Map.Entry\u0026lt;Integer, Integer\u0026gt; front = waitQueue.poll(); if (front.getValue() \u0026gt; 0) maxHeap.offer(front); } else { Map.Entry\u0026lt;Integer, Integer\u0026gt; front = waitQueue.poll(); if (front.getValue() \u0026gt; 0) { maxHeap.offer(front); time = timeMap.get(front.getKey()) + cooldown; } } } return time; } Similar question: LC358 Rearrange String k Distance Apart\nMethod one:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public String rearrangeString(String str, int k) { HashMap\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (char c : str.toCharArray()) { map.put(c, map.getOrDefault(c, 0) + 1); } Queue\u0026lt;Map.Entry\u0026lt;Character, Integer\u0026gt;\u0026gt; maxHeap = new PriorityQueue\u0026lt;\u0026gt;(map.size(), new Comparator\u0026lt;Map.Entry\u0026lt;Character, Integer\u0026gt;\u0026gt;() { @Override public int compare(Map.Entry\u0026lt;Character, Integer\u0026gt; e1, Map.Entry\u0026lt;Character, Integer\u0026gt; e2) { return e2.getValue() - e1.getValue(); } }); Deque\u0026lt;Map.Entry\u0026lt;Character, Integer\u0026gt;\u0026gt; waitQueue = new ArrayDeque\u0026lt;\u0026gt;(); maxHeap.addAll(map.entrySet()); StringBuilder sb = new StringBuilder(); while (!maxHeap.isEmpty()) { Map.Entry\u0026lt;Character, Integer\u0026gt; cur = maxHeap.poll(); sb.append(cur.getKey()); cur.setValue(cur.getValue()-1); waitQueue.offer(cur); if (waitQueue.size() \u0026lt; k) continue; Map.Entry\u0026lt;Character, Integer\u0026gt; front = waitQueue.poll(); if (front.getValue() \u0026gt; 0) maxHeap.offer(front); } return sb.length() == str.length() ? sb.toString() : \u0026#34;\u0026#34;; } Method two:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public String rearrangeString(String str, int k) { int[] count = new int[26]; int[] valid = new int[26]; StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; str.length(); i++) { count[str.charAt(i) - \u0026#39;a\u0026#39;]++; } for (int i = 0; i \u0026lt; str.length(); i++) { int c = findNext(count, valid, i); if (c == -1) return \u0026#34;\u0026#34;; sb.append((char)(\u0026#39;a\u0026#39;+c)); count[c] -= 1; valid[c] = i + k; } return sb.toString(); } private int findNext(int[] count, int[] valid, int index) { int pos = -1, max = -1; for (int i = 0; i \u0026lt; 26; i++) { if (count[i] \u0026gt; 0 \u0026amp;\u0026amp; count[i] \u0026gt; max \u0026amp;\u0026amp; index \u0026gt;= valid[i]) { pos = i; max = count[i]; } } return pos; } ",
  "summary": "Use greedy algorigthm to solve task scheduleing problem.\n",
  "date": "2016-11-14T00:00:00Z",
  "lastmod": "2016-11-14T00:00:00Z",
  "permalink": "https://nianze.github.io/en/notes/2016/task-schedule/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["algorithm"],
  "categories": ["coding"],
  "series": ["algorithm"]
}
