{
  "title": "Alien dictionary",
  "content": "Build a graph to solve alien dictionary problem via DFS/BFS.\nAlien Dictionary There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.\nFor example,\nGiven the following words in dictionary,\n[ \u0026#34;wrt\u0026#34;, \u0026#34;wrf\u0026#34;, \u0026#34;er\u0026#34;, \u0026#34;ett\u0026#34;, \u0026#34;rftt\u0026#34; ] The correct order is: \u0026ldquo;wertf\u0026rdquo;.\nNote:\nYou may assume all letters are in lowercase. If the order is invalid, return an empty string ([\u0026ldquo;abcd\u0026rdquo;,\u0026ldquo;ab\u0026rdquo;] is invalid). There may be multiple valid order of letters, return any one of them is fine. Method 1: DFS Build the graph (post-adjacency list and visited list), then use DFS to build the correct order, while checking the loop at the same time.\nNote:\nvisited[]: -1(not exist), 0(no pre-node), 1(visiting), 2(visited) The order of adding char into stringbuilder is reversed: add post nodes to sb firstly in order to avoid missing pre-nodes for current nodes later. e.g.: for correct order \u0026ldquo;abc\u0026rdquo;, if meet \u0026lsquo;b\u0026rsquo; firstly, build the sb as \u0026ldquo;cb\u0026rdquo;, and then meet \u0026lsquo;a\u0026rsquo;, build it as \u0026ldquo;cba\u0026rdquo;; otherwise, when meet \u0026lsquo;b\u0026rsquo;, build sb as \u0026ldquo;bc\u0026rdquo;, and then meet \u0026lsquo;a\u0026rsquo;, resulting in \u0026ldquo;bca\u0026rdquo;, which is incorrect.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 private static int N = 26; public String alienOrder(String[] words) { boolean[][] adj = new boolean[N][N]; int[] visited = new int[N]; if (!buildGraph(words, adj, visited)) return \u0026#34;\u0026#34;; // \u0026#34;abcd\u0026#34; -\u0026gt; \u0026#34;ab\u0026#34; StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; N; i++) { if (visited[i] == 0) { if (!dfs(adj, visited, sb, i)) return \u0026#34;\u0026#34;; } } return sb.reverse().toString(); } private boolean dfs(boolean[][] adj, int[] visited, StringBuilder sb, int i) { visited[i] = 1; // visiting for (int j = 0; j \u0026lt; N; j++) { if (adj[i][j]) { // connected post nodes if (visited[j] == 1) return false; // loop case if (visited[j] == 0) { if (!dfs(adj, visited, sb, j)) return false; } } } visited[i] = 2; // visited sb.append((char)(\u0026#39;a\u0026#39; + i)); return true; } private boolean buildGraph(String[] words, boolean[][] adj, int[] visited) { Arrays.fill(visited, -1); // init to not existed for (int i = 0; i \u0026lt; words.length; i++) { for (char c : words[i].toCharArray()) visited[c - \u0026#39;a\u0026#39;] = 0; if (i \u0026gt; 0) { String w1 = words[i-1], w2 = words[i]; int len = Math.min(w1.length(), w2.length()), j = 0; for (; j \u0026lt; len; j++) { char c1 = w1.charAt(j), c2 = w2.charAt(j); if (c1 != c2) { adj[c1 - \u0026#39;a\u0026#39;][c2 - \u0026#39;a\u0026#39;] = true; break; } } if (j == len \u0026amp;\u0026amp; w1.length() \u0026gt; w2.length()) return false; // \u0026#34;abcd\u0026#34; -\u0026gt; \u0026#34;ab\u0026#34; } } return true; } Method 2: BFS Build the graph(post-adjacency list and visited list), then use Karn\u0026rsquo;s algorithm to do topological sort (essentially BFS).\nNote:\nvisited[]: -1(not exist), 0(no pre-node), 1,2,3\u0026hellip;(pre-nodes number) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public String alienOrder(String[] words) { List\u0026lt;Set\u0026lt;Integer\u0026gt;\u0026gt; adj = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 26; i++) adj.add(new HashSet\u0026lt;Integer\u0026gt;()); int[] degree = new int[26]; Arrays.fill(degree, -1); // init the adj and degree list for (int i = 0; i \u0026lt; words.length; i++) { for (char c : words[i].toCharArray()) { if (degree[c-\u0026#39;a\u0026#39;] \u0026lt; 0) degree[c-\u0026#39;a\u0026#39;] = 0; } if (i \u0026gt; 0) { String w1 = words[i-1], w2 = words[i]; int len = Math.min(w1.length(), w2.length()); for (int j = 0; j \u0026lt; len; j++) { int c1 = w1.charAt(j) - \u0026#39;a\u0026#39;, c2 = w2.charAt(j) - \u0026#39;a\u0026#39;; if (c1 != c2) { if (!adj.get(c1).contains(c2)) { adj.get(c1).add(c2); degree[c2]++; } break; } if (j == len-1 \u0026amp;\u0026amp; w1.length() \u0026gt; w2.length()) return \u0026#34;\u0026#34;; // \u0026#34;abcd\u0026#34; -\u0026gt; \u0026#34;ab\u0026#34; } } } // topological sort Deque\u0026lt;Integer\u0026gt; q = new ArrayDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; degree.length; i++) { if (degree[i] == 0) q.offer(i); } StringBuilder sb = new StringBuilder(); while (!q.isEmpty()) { int i = q.poll(); sb.append((char) (\u0026#39;a\u0026#39; + i)); for (int j : adj.get(i)) { degree[j]--; if (degree[j] == 0) q.offer(j); } } for (int d : degree) if (d \u0026gt; 0) return \u0026#34;\u0026#34;; // has loop return sb.toString(); } ",
  "summary": "Build a graph to solve alien dictionary problem via DFS/BFS.\n",
  "date": "2016-11-26T00:00:00Z",
  "lastmod": "2016-11-26T00:00:00Z",
  "permalink": "https://nianze.github.io/en/notes/2016/alien-dictionary/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["algorithm"],
  "categories": ["coding"],
  "series": ["algorithm"]
}
