{
  "title": "[EMCpp]Item-13 Prefer Const_iterators to Iterators",
  "content": "In maximally generic code, prefer non-member versions of begin, end, rbegin, etc., over their member function counterparts.\nIn C++98, using const whenever it\u0026rsquo;s meaningful wasn\u0026rsquo;t practical: it wasn\u0026rsquo;t that easy to create them, and once we had one, the ways we could use it were limited. For example:\n1 2 3 4 5 std::vector\u0026lt;int\u0026gt; values; ... std::vector\u0026lt;int\u0026gt;::iterator it = std::find(values.begin(), values.end(), 1983); values.insert(it, 1998); The code above search for the first occurrence of 1983 (the year \u0026ldquo;C++\u0026rdquo; replaced \u0026ldquo;C with Classes\u0026rdquo;), then insert the value 1998 (first ISO C++ Standard was adopted) at that location. If no 1983 found, insert at the end of the vector. Since the code never modifies what an iterator points to, so acoording to the convention to use const whenever possible, we should use the const-iterator.\nHowever, in C++98, there was no simple way to get a const_iterator from a non-const container. To work it out, we might concider using the cast like the following code, which conceptually works but probably won\u0026rsquo;t compile:\n1 2 3 4 5 6 7 8 9 10 typedef std::vector\u0026lt;int\u0026gt;::iterator IterT; typedef std::vector\u0026lt;int\u0026gt;::const_iterator ConstIterT; std::vector\u0026lt;int\u0026gt; values; ... ConstIterT ci = std::find(static_cast\u0026lt;ConstIterT\u0026gt;(values.begin()), static_cast\u0026lt;ConstIterT\u0026gt;(values.end()), 1983); values.insert(static_cast\u0026lt;IterT\u0026gt;(ci), 1998); // may not compile The problem here is that in C++98, const_iterators weren\u0026rsquo;t acceptable for insertions and erasures, so we cast ci into its non-const version. However, in C++98, there\u0026rsquo;s no portable conversion from a const_iterator to an iterator1, so the last statement probably won\u0026rsquo;t compile. The conclusion: const_iterators were so much trouble in C++98.\nNow that we in the new world of C++11, const_iterators are both easy to get and easy to use. Even for non-const containers, we get cbegin and cend to produce const_iterators:\n1 2 3 4 std::vector\u0026lt;int\u0026gt; values; ... auto it = std::find(values.cbegin(), values.cend(), 1983); values.insert(it, 1998); Maximally Generic Support Taking into account that some containers and container-like data structures offer begin and end as non-member functions, C++11 added the non-member functions begin and end to make sure some generic library code using non-member functions is possible.\nC++14 rectified the oversight in C++11, adding the support for cbegin, cend, rbegin, rend, crbegin, and crend. Now we could generalize the code above into a findAndInsert template as follow:\n1 2 3 4 5 6 7 8 9 10 11 12 13 template\u0026lt;typename C, typename V\u0026gt; void findAndInsert(C\u0026amp; container, // find first occurrence of targetVal in container const V\u0026amp; targetVal, // then insert insertVal there const V\u0026amp; insertVal) { using std::cbegin; using std::cend; auto it = std::find(cbegin(container), // non-member cbegin cend(container), // non-member cend targetVal); container.insert(it, insertVal); } If we\u0026rsquo;re using C++11 and want to write maximally generic code, we may build our own implementation for non-member cbegin:\n1 2 3 4 5 template\u0026lt;class C\u0026gt; auto cbegin(const C\u0026amp; container) -\u0026gt; decltype(std::begin(container)) { return std::begin(container); } Point here is: through its reference-to-const parameter, container, we are invoking the non-member begin function (provided by C++11) on a const container, and this process yields a const_iterator. In fact, this template works even if C is a built-in array type2.\nIt\u0026rsquo;s true in C++11, too.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFor insight into how a template can be specialized for built-in arrays, consult EMCpp item 1\u0026rsquo;s discussion of type deduction in templates that take reference parameters to arrays.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
  "summary": "In maximally generic code, prefer non-member versions of begin, end, rbegin, etc., over their member function counterparts.\n",
  "date": "2018-07-19T18:48:52-04:00",
  "lastmod": "2018-07-19T18:48:52-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/07/prefer-const_iterators-to-iterators/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
