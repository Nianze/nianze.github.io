{
  "title": "[EMCpp]Item-4 Know How to View Deduced Types",
  "content": "Deduced types can often be seen using IDE editors, compiler error messages, and the Boost TypeIndex library, but the results of some tools may be neither helpful nor accurate.\nDependending on the phase of the software development process, we might get type deduction information during coding, compilation, and runtime.\nIDE Editors Code editors in IDEs often show the types of program entities when we hover our cursor over the entity. In order for the IDE to offer this kind of information, our code must be in a more or less compilable state. Moreover, when more complicated types are involved, the information displayed by IDEs may not be helpful.\nCompiler Diagnostics We can get a compiler to show what it deduced for a type by causing a compilation problem using that type:\n1 2 template\u0026lt;typename T\u0026gt; // Declaration only. class TD; // TD == \u0026#34;Type Displayer\u0026#34;. 1 2 3 4 5 6 const int theAnser = 42; auto x = theAnswer; auto y = \u0026amp;theAnswer; TD\u0026lt;decltype(x)\u0026gt; xType; TD\u0026lt;decltype(y)\u0026gt; yType; For the code above, since there\u0026rsquo;s no template definition to instantiate, compiler will yield the error messages like this:\n1 2 error: \u0026#39;xType\u0026#39; uses undefined class \u0026#39;TD\u0026lt;int\u0026gt;\u0026#39; error: \u0026#39;yType\u0026#39; uses undefined class \u0026#39;TD\u0026lt;const int *\u0026gt;\u0026#39; Through these errors, we get useful type information.\nRuntime Output Consider a more complex example involving a user-defined type (Widget), an STL container(std::vector), and an auto variable (vm), which is more representative of the situation where we want to see deduced type information:\n1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename T\u0026gt; // template function to void f(const T\u0026amp; param); // be called std::vector\u0026lt;Widget\u0026gt; createVec(); // factory function const auto vw = createVec(); // init vm with factory return if (!vm.empty()) { f(\u0026amp;vm[0]); // call f ... } This time, if we want to see what type is deduced for T and param, the type information displayed by IDE editors is not reliably useful. For example, the deduced type for T is shown as:\n1 conststd::_Simple_types\u0026lt;std::_Wrap_alloc\u0026lt;std::_Vec_base_types\u0026lt;Widget,std::allocator\u0026lt;Widget\u0026gt; \u0026gt;::_Alloc\u0026gt;::value_type\u0026gt;::value_type * and the param\u0026rsquo;s type is:\n1 const std::_Simple_types\u0026lt;...\u0026gt;::value_type *const \u0026amp; In order to create a textual representation of the type we care about and print it out on screen, we might consider the Boost TypeIndex library1. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;boost/type_index.hpp\u0026gt; template\u0026lt;typename T\u0026gt; void f(const T\u0026amp; param) { using std::cout; using boost::typeindex::type_id_with_cvr; // show T cout \u0026lt;\u0026lt; \u0026#34;T = \u0026#34; \u0026lt;\u0026lt; type_id_with_cvr\u0026lt;T\u0026gt;().pretty_name() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // show param\u0026#39;s type cout \u0026lt;\u0026lt; \u0026#34;param = \u0026#34; \u0026lt;\u0026lt; type_id_with_cvr\u0026lt;decltype(param)\u0026gt;().pretty_name() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; ... } Under compilers from GNU and Clang, Boost.TypeIndex produces this accurate output:\n1 2 T = Widget const* param = Widget const* const\u0026amp; There is something similar called typeid and std::type_info::name in Standard C++ that could also display the type, but the output text may not be straightforward (for example, using \u0026ldquo;PK\u0026rdquo; to stand for \u0026ldquo;pointer to const\u0026rdquo;) and might not be reliable.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
  "summary": "Deduced types can often be seen using IDE editors, compiler error messages, and the Boost TypeIndex library, but the results of some tools may be neither helpful nor accurate.\n",
  "date": "2018-07-06T10:08:00-04:00",
  "lastmod": "2018-07-06T10:08:00-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/07/know-how-to-view-deduced-types/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
