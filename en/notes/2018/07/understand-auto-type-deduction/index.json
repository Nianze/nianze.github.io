{
  "title": "[EMCpp]Item-2 Understand Auto Type Deduction",
  "content": "auto type deduction is usually the same as template type deduction, with an exception in the case of braced initializer. Also, in C++14, as a function return type or a lambda parameter, auto implies template type deduction instead of auto type deduction.\nWith only one curious exception, auto type deduction is template type deduction. In the case of general function template form and its general function call:\n1 2 3 template\u0026lt;typename T\u0026gt; void f(ParamType param); f(expr); // general call compilers use expr to deduce types for T and ParamType. Similarly, in the case where a variable is declared using auto, auto plays the role of T, and the type specifier for the variable acts as ParamType.\nTherefore, there are also three cases based on the type specifier:\nCase 1: the type specifier is a pointer or reference, but not a universal reference Case 2: the type specifier is a universal reference Case 3: the type specifier is neither a pointer nor a reference For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 auto x = 27; // case 3. type specifier is simply auto by itself. const auto cx = x; // case 3. type specifier is const auto. const auto\u0026amp; rx = x; // case 1. type specifier is const auto\u0026amp;. // case 2: auto\u0026amp;\u0026amp; uref1 = x; // x is int and lvalue, so uref1\u0026#39;s type is int\u0026amp; auto\u0026amp;\u0026amp; uref2 = cx; // cx is const int and lvalue, so uref2\u0026#39;s type is const int\u0026amp; auto\u0026amp;\u0026amp; uref3 = 27; // 27 is int and rvlue, so uref3\u0026#39;s type is int\u0026amp;\u0026amp; // array and function names decay into pointers for non-ref type specifiers: const char name[] = \u0026#34;R. N. Briggs\u0026#34;; // name\u0026#39;s type is const char [13] auto arr1 = name; // arr1\u0026#39;s type is const char* auto\u0026amp; arr2 = name; // arr2\u0026#39;s type is const char (\u0026amp;)[13] void someFunc(int, double); // someFunc is a function, type is void(int, double) auto func1 = someFunc; // func1\u0026#39;s type is void (*)(int, double) auto\u0026amp; func2 = someFunc; // func2\u0026#39;s type is void (\u0026amp;)(int, double) Exception: uniform initialization C++98 provides two syntactic choices when we want to declare an int with an initial value:\n1 2 int x1 = 27; int x2(27); By introducing uniform initialization, C++11 adds these two forms:\n1 2 int x3 = { 27 }; int x4{ 27 }; As EMCpp 5 explains, there are advantages to declare variables using auto, so we may prefer:\n1 2 3 4 auto x1 = 27; // type is int, value is 27 auto x2(27); // ditto auto x3 = { 27 }; // type is std::initializer_list\u0026lt;int\u0026gt;, value is {27} auto x4{ 27 }; // ditto However, after this modification, while the first two statements do declare a variable of type int with value 27, the second two actually declare a variable of type std::initializer_list\u0026lt;int\u0026gt; containing a single element with value 27.\nIn fact, when an auto-declared variable is initialized with a braced initializer, auto will assume that the braced initilizer represents a std::initializer_list, which itself is a template for some type T, so there are actually two kinds of type deduction taking place:\nauto type deduction: the type is an instantiation of std::initializer_list template type deduction: the type T in std::initializer_list\u0026lt;T\u0026gt; The only real difference between auto and template type deduction is the assumption that a braced initializer represents a std::initializer_list. This lead to some interesting results:\n1 2 3 4 5 6 7 8 9 auto x = { 11, 23, 9 }; // x\u0026#39;s type is std::initializer_list\u0026lt;int\u0026gt; template\u0026lt;typename T\u0026gt; void f1(T param); f1({ 11, 23, 9 }); // error! can\u0026#39;t deduce type for T. Do not recognise the type for braced initializer template\u0026lt;typename T\u0026gt; void f2(std::initializer_list\u0026lt;T\u0026gt; initList); f({ 11, 23, 9 }); // T deduced as T, and initList\u0026#39;s type is std::initializer_list\u0026lt;int\u0026gt; More exceptions in C++14 C++14 permits to use auto as a function\u0026rsquo;s return type as well as in lambda parameter declarations. However, these uses of auto employ tamplate type deduction, not auto type deduction - so a braced initializer won\u0026rsquo;t imply the type of std::initializer_list automatically, and following statement won\u0026rsquo;t compile:\n1 2 3 4 5 6 7 8 9 10 11 12 // auto in return type auto createInitList() { return { 1, 2, 3 }; // error: can\u0026#39;t deduce type for { 1, 2, 3 } } // auto in a parameter type specification in a C++14 lambda std::vector\u0026lt;int\u0026gt; v; ... auto resetV = [\u0026amp;v](const auto\u0026amp; newValue) { v = newValue; }; // C++14 lambda, second auto is in parameter list ... resetV({ 1, 2, 3 }); // error: can\u0026#39;t deduce type for { 1, 2, 3 } ",
  "summary": "auto type deduction is usually the same as template type deduction, with an exception in the case of braced initializer. Also, in C++14, as a function return type or a lambda parameter, auto implies template type deduction instead of auto type deduction.\n",
  "date": "2018-07-03T10:07:13-04:00",
  "lastmod": "2018-07-03T10:07:13-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/07/understand-auto-type-deduction/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
