{
  "title": "[EMCpp]Item-1 Understand Template Type Deduction",
  "content": "There are three sets of rules for type deduction in modern C++: one for function templates, one for auto, and one for decltype. Without a solid understanding of how deduction operates, effective programming in modern C++ is all but impossible.\nSince type deduction for templates is the basis of that for auto, it\u0026rsquo;s important to truly understand the aspects of template type deduction that auto builds on: during template type deduction, there are three cases for parameter types:\npointer type or non-universal reference type universal reference type neither a pointer nor a reference (value type) Moreover, there\u0026rsquo;s a niche case worth knowing about, that arguments that are array or function names decay to pointers unless they\u0026rsquo;re used to initialize references.\nTo tell the difference, let\u0026rsquo;s think of a function template as looking like this:\n1 2 3 tempalte\u0026lt;typename T\u0026gt; void f(ParamType param); f(expr); // deduce T and ParamType from expr Case 1: ParamType is Reference or Pointer, but not a Universal Reference The rules in this case works like this:\nIf expr\u0026rsquo;s type is a reference, ignore the reference part. Then pattern-match expr\u0026rsquo;s type against ParamType to determine T. For example,\n1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename T\u0026gt; void f(T\u0026amp; param); // param is a reference int x = 27; // x is an int const int cx = x; // cx is a const int const int\u0026amp; rx = x; // rx is a refrence to x as a const int f(x); // T is int, param\u0026#39;s type is int\u0026amp; f(cx); // T is const int, param\u0026#39;s type is const int\u0026amp; f(rx); // T is const int, param\u0026#39;s type is const int\u0026amp; Note that even though rx\u0026rsquo;s type is a reference, T is deduced to be a non-reference, because rx\u0026rsquo;s reference-ness is ignored during type deduction.\n1 2 3 4 5 6 template\u0026lt;typename T\u0026gt; void f(const T\u0026amp; param); // param is now a ref-to-const, // so there\u0026#39;s no longer a need for const to be deduced as part of T f(x); // T is int, param\u0026#39;s type is const int\u0026amp; f(cx); // T is int, param\u0026#39;s type is const int\u0026amp; f(rx); // T is int, param\u0026#39;s type is const int\u0026amp; As before, rx\u0026rsquo;s reference-ness is ignored during type deduction.\n1 2 3 4 5 6 7 8 template\u0026lt;typename T\u0026gt; void f(T* param); // param is now a pointer int x = 27; // x is an int const int *px = \u0026amp;x; // px is a ptr to x as a const int f(\u0026amp;x); // T is int, param\u0026#39;s type is int* f(px); // T is const int, param\u0026#39;s type is const int* As shown above, when param were a pointer (or a pointer to const), things work essentially the same way.\nCase 2: ParamType is a Universal Reference Things are less obvious for templates taking universal reference paramters:\nIf expr is an lvalue, both T and ParamType are deduced to be lvalue references. If expr is an rvalue, the \u0026ldquo;normal\u0026rdquo; (i.e., case 1) rules apply. For example:\n1 2 3 4 5 6 7 8 9 10 11 template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); // param is now a universal reference int x = 27; // as before const int cx = x; // as before const int\u0026amp; rx = x; // as before f(x); // x is lvalue, so T is int\u0026amp;, param\u0026#39;s type is also int\u0026amp; f(cx); // x is lvalue, so T is const int\u0026amp;, param\u0026#39;s type is also const int\u0026amp; f(rx); // x is lvalue, so T is const int\u0026amp;, param\u0026#39;s type is also const int\u0026amp; f(27); // x is rvlaue, so T is int, param\u0026#39;s type is therefore int\u0026amp;\u0026amp; EMCpp Item24 explains why these examples play out the way they do.\nCase 3: ParamType is Neither a Pointer nor a Reference In this case, we\u0026rsquo;re dealing with pass-by-value. That means that param will be a new object, which motivates the rules below:\nAs before, if expr\u0026rsquo;s type is a reference, ignore the reference part If, after ignoring expr\u0026rsquo;s reference-ness, expr is const, ignore that, too. If it\u0026rsquo;s volatile, also ignore that (refer to EMCpp item 40 for volatile). 1 2 3 4 5 6 7 8 9 10 11 12 template\u0026lt;typename T\u0026gt; void f(T param); // param is now passed by value int x = 27; // as before const int cx = x; // as before const int\u0026amp; rx = x; // as before const char* const ptr = \u0026#34;Fun with pointers\u0026#34;; // ptr is const ptr to const obj. f(x); // T\u0026#39;s and param\u0026#39;s types are both int f(cx); // T\u0026#39;s and param\u0026#39;s types are both int f(rx); // T\u0026#39;s and param\u0026#39;s types are both int f(ptr); // T\u0026#39;s and param\u0026#39;s types are const char*, the constness of ptr is ignored. Array Arguments Even though they sometimes seems to be interchangeable, array types are, in fact, different from pointer types. We had such equivalence illusion because, in many contexts, an array decays into a pointer to its first element:\n1 2 const char name[] = \u0026#34;J.P. Briggs\u0026#34;; // name\u0026#39;s type is const char [13] const char * ptrToName = name; // array decays to pointer Array parameter declarations are treated as if they were pointer parameters, so void myFunc(int param[]); is equivalent to void myFunc(int* param);. Thus, the type of an array that\u0026rsquo;s passed to a template function by value is deduced to be a pointer type:\n1 2 3 4 template\u0026lt;typename T\u0026gt; void f(T param); f(name); // name is array, but T deduced as const char* Although functions can\u0026rsquo;t declare parameters that are truly arrays, they can declare parameters that are references to arrays. Thus,\n1 2 3 4 template\u0026lt;typename T\u0026gt; void f(T\u0026amp; param); // template with by-reference parameter f(name); // T is deduced as array type: const char [13], type of param is const char (\u0026amp;)[13] The actual type of the array includes the array size, so in this example, T is deduced to be const char[13], and the type of f\u0026rsquo;s parameter (a reference to this array) is const char (\u0026amp;)[13].\nUsing this ability to declare references to arrays enables creation of a template that deduces the number of elements that an array contains:\n1 2 3 4 5 6 7 // return size of an array as a compile-time constant. // array parameter has no name because we don\u0026#39;t care its name template\u0026lt;typename T, std::size_t N\u0026gt; constexpr std::size_t arraySize(T (\u0026amp;)[N]) noexcept { return N; } There are two points worth noting in this declaration:\nconstexpr, as explained in EMCpp 15, makes the function result available during compilation, which makes it possible to declare an array with the same number of elements as a second array whose size is computed from a braced initializer:\n1 2 3 int keyVals[] = { 1, 3, 7, 9, 11, 22, 35 }; // 7 elements int mappedVals[arraySize(keyVals)]; // 7 elements std::array\u0026lt;int, arraySize(keyVals)\u0026gt; values; // size == 7 noexcept, as explained in EMCpp 14, helps compilers generate better code.\nFunction Arguments Apart from arrays, function types can decay into function pointers, too. As a result:\n1 2 3 4 5 6 7 8 9 10 11 void someFunc(int, double); // someFunc is a function, type is void(int, double) template\u0026lt;typename T\u0026gt; void f1(T param); // in f1, param passed by value template\u0026lt;typename T\u0026gt; void f2(T\u0026amp; param); // in f2, param passed by ref f1(someFunc); // param deduced as ptr-to-func, type is void (*)(int, double) f2(someFunc); // param deduced as ref-to-func, type is void (\u0026amp;)(int, double) This rarely makes any difference in practice.\n",
  "summary": "There are three sets of rules for type deduction in modern C++: one for function templates, one for auto, and one for decltype. Without a solid understanding of how deduction operates, effective programming in modern C++ is all but impossible.\n",
  "date": "2018-07-02T22:44:34-04:00",
  "lastmod": "2018-07-02T22:44:34-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/07/understand-template-type-deduction/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
