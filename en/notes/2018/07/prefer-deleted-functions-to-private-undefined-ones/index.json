{
  "title": "[EMCpp]Item-11 Prefer Deleted Functions to Private Undefined Ones",
  "content": "Any function may be deleted, including non-member functions and template instantiations.\nTo prevent use of certain function from being called, there is a classic approach in C++98: declare that function private and not define them.\nHowever, the fact is that this C++98 practice is really an attempt to achieve what C++11\u0026rsquo;s deleted functions actually accomplish. As an emulation, it is not as good as the real thing: it doesn\u0026rsquo;t work outside classes, it doesn\u0026rsquo;t always work inside classes, and when it does work, it may not work until link-time.\nLink-time vs compile-time failure diagnostic In C++98 practice, declaring functions private prevents clients from calling them. Due absence of function definitions, linking will fail if member functions or friends of the class try to call them. Take the copy constructor in uncopyable basic_ios class for example:\n1 2 3 4 5 6 7 8 template \u0026lt;class charT, class traits = char_traits\u0026lt;charT\u0026gt; \u0026gt; class basic_ios : public ios_base { public: ... private: basic_ios(const basic_ios\u0026amp;); // not defined basic_ios\u0026amp; operator=(const basic_ios\u0026amp;); // not defined }; As a comparason, deleted functions may not be used in any way, so even code that\u0026rsquo;s in member and friend functions will fail to compile if it tries to copy basic_ios objects:\n1 2 3 4 5 6 7 8 9 template \u0026lt;class charT, class traits = char_traits\u0026lt;charT\u0026gt; \u0026gt; class basic_ios : public ios_base { public: ... basic_ios(const basic_ios\u0026amp;) = delete ; basic_ios\u0026amp; operator=(const basic_ios\u0026amp;) = delete; ... }; Note that by convertion, deleted functions are declared public instead of private, because C++ checks accessibility before deleted status. When client code tries to use a deleted private function, some compilers complain only about the function being private. If declaring those functions in public, we will get better error messages.\nDisable non-member functions Functions may be deleted outside classes, while private functions are always member functions inside some class. For example, we may use delete to prevent implicit numerical conversion into int for a non-member function isLucky, which takes in i\nnteger and returns whether it\u0026rsquo;s a lucky number:\n1 2 3 4 bool isLucky(int number); // original function bool isLucky(char) = delete; // reject chars bool isLucky(bool) = delete; // reject bools bool isLucky(double) = delete; // reject doubles and floats Disable special template instantiations Suppose we want to handle specail cases of void* and char* in the processProinter template, we may simply delete those instantiations:\n1 2 3 4 5 6 7 8 t emplate\u0026lt;typename T\u0026gt; void processProinter(T* ptr); template\u0026lt;\u0026gt; void processProinter\u0026lt;void*\u0026gt;(void*) = delete; template\u0026lt;\u0026gt; void processProinter\u0026lt;char*\u0026gt;(char*) = delete; Disable speacial member function template instanciation Since template specializations must be written at namespace scope, not class scope, we can\u0026rsquo;t adopt the C++98 convertion to disable specialization of a member function template from being called. Delete functions, however, won\u0026rsquo;t be restricted by class scope, so we can simply delete the specialization outside the class:\n1 2 3 4 5 6 7 8 9 10 11 class Widget { public: ... template\u0026lt;typename T\u0026gt; void processProinter(T* ptr) {...} ... }; template\u0026lt;\u0026gt; void Widget::processProinter\u0026lt;void\u0026gt;(void*) = delete; ",
  "summary": "Any function may be deleted, including non-member functions and template instantiations.\n",
  "date": "2018-07-16T21:22:57-04:00",
  "lastmod": "2018-07-16T21:22:57-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/07/prefer-deleted-functions-to-private-undefined-ones/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
