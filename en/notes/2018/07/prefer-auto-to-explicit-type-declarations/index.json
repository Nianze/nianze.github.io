{
  "title": "[EMCpp]Item-5 Prefer Auto to Explicit Type Declarations",
  "content": "Despite some pitfalls described in EMCpp item 2 and 6, auto variables are preferred for they must be initialized, are generally immune to type mismatches that can lead to portability or efficiency problems, can ease the process of refactoring, and typically require less typing than variables with explicitly specified types.\nAvoidance of Uninitialized variables auto variavbles have their type deduced from their initializer, so they must be initialized.\n1 2 3 int x1; // potentially unintialized auto x2; // error! initializer required auto x3 = 0; // fine, x3\u0026#39;s value is well-defined Avoidance of Syntactic Verbosity In order to express the type of the value pointed to by an iterator, without auto, we may write like this:\n1 2 3 4 5 6 7 8 template\u0026lt;typename It\u0026gt; void dwim(It b, It e) // \u0026#34;do what I mean\u0026#34;. for all elements in range from b to e { for (; b != e; ++b) { typename std::iterator_traits\u0026lt;It\u0026gt;::value_type currValue = *b; ... } } Thanks to auto, now we can declare a local variable whose value is that of a dereferenced iterator with ease:\n1 2 3 4 5 6 7 8 template\u0026lt;typename It\u0026gt; void dwim(It b, It e) { for (; b != e; ++b) { auto currValue = *b; ... } } Ability to Hold Closure Because auto uses type deduction, it can represent types known only to compilers, such as lambda expressions:\n1 2 3 4 5 // C++14 auto derefLess = // comparison func. for values pointed [](const auto\u0026amp; p1, // to by anything pointer-like const auto\u0026amp; p2) { return *p1 \u0026lt; *p2; }; or in C++11, a little more verbose:\n1 2 3 4 5 // C++11 doesn\u0026#39;t support auto for parameters to lambda, so more verbose. auto derefUPLess = // comparison func. for Wdigets pointed [](const std::unique_ptr\u0026lt;Widget\u0026gt;\u0026amp; p1, // to by std::unique_ptr const std::unique_ptr\u0026lt;Widget\u0026gt;\u0026amp; p2) { return *p1 \u0026lt; *p2; }; Without using auto, since lambda expressions yield closures, which are callable objects, we can store them in std::function objects:\n1 2 3 4 5 std::function\u0026lt;bool(const std::unique_ptr\u0026lt;Widget\u0026gt;\u0026amp;, bool(const std::unique_ptr\u0026lt;Widget\u0026gt;\u0026amp;)\u0026gt; derefUPLess = [](const std::unique_ptr\u0026lt;Widget\u0026gt;\u0026amp; p1, // comparison func. for Wdigets pointed const std::unique_ptr\u0026lt;Widget\u0026gt;\u0026amp; p2) // to by std::unique_ptr { return *p1 \u0026lt; *p2; }; As we can see, syntactic verbosity makes auto a preferred choice. Besides that, there are two more reasons to choose auto:\nstd::function object typically uses more memory than the auto-declared object1. invoking a closure via a std::function object is almost certain to be slower than calling it via an auto-declared object2. In summary, auto wins the competition between auto and std::function for holding a closure.\nAvoidance of Unexpected Implicit Conversions Consider this code:\n1 2 3 4 5 6 std::unordered_map\u0026lt;std::string, int\u0026gt; m; ... for (const std::pair\u0026lt;std::string, int\u0026gt;\u0026amp; p : m) { ... } This looks perfectly reasonable, but there\u0026rsquo;s a problem: the key part of a std::unorderd_map is const, so the type of std::pair in the hash table isn\u0026rsquo;t std::pair\u0026lt;std::string, int\u0026gt;, but std::pair\u0026lt;const std::string, int\u0026gt;. Since the constness hasn\u0026rsquo;t been declared for the variable p in the loop, compilers will create a temporary object of the type that p wants to bind to by coping each object in m, then binding the reference p to that temporary object, and finally destroy the temporary at the end of each loop iteration. This is almost certain to be an unwanted behavior - we probably intend to simply bind the reference p to each element in m directly.\nSuch unintentional type mismatches can be autoed away:\n1 2 3 4 for (auto\u0026amp; p : m) { ... } Avoidance of Explicit Type Revising during Refactoring auto types automatically change if the type of their initializing expression changes, and that means that some refactoring (e.g., change the return type of a function from int to long) are facilitated by the use of auto:\nif the results of calling the function are stored in auto variables, the calling code automatically updates itself the next time we compile if the results are stored in varibles explicitly declared to be int, we have to find all the call sites so that we can revise them. An auto-declared variable holding a closure has the same type as the closure, and uses only as much memory as the closure requires. The type of a std::function-declared variable holding a closure is an instantiation of the std::function template, and that has a fixed size for any given signature. When this size is not adequate for the closure, std::function constructor will allocate heap memory to store the closure - leading to typical result that std::function object uses more memory than the auto-declared object.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThis slowness comes from the implementation details of std::function, which restrict inlining and yield indirect function calls.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
  "summary": "Despite some pitfalls described in EMCpp item 2 and 6, auto variables are preferred for they must be initialized, are generally immune to type mismatches that can lead to portability or efficiency problems, can ease the process of refactoring, and typically require less typing than variables with explicitly specified types.\n",
  "date": "2018-07-07T13:33:06-04:00",
  "lastmod": "2018-07-07T13:33:06-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/07/prefer-auto-to-explicit-type-declarations/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
