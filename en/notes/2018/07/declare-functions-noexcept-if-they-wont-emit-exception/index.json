{
  "title": "[EMCpp]Item-14 Declare Functions Noexcept if They Won't Emit Exception",
  "content": "Most functions are exception-neutral, but for some, such as move operations, swap, memory deallocation functions, and destructors, noexcept is particularly valuable.\nMore optimizable For functions that won\u0026rsquo;t produce exceptions, we have C++98 style as well as C++11 style:\n1 2 int f(int x) throw(); // C++98 style int f(int x) noexcept; // C++11 style The difference:\nC++98: the call stack is unwound to f\u0026rsquo;s caller before program execution is terminated C++11: the call stack is possibly unwound before program execution is terminated The difference in possibly unwinding leads to large impact on code generation: optimizers need not keep the runtime stack in an unwindable state, and need not ensure that objects in a noexcept function are destroyed in the inverse order of construction, both of which optimization flexibility is lacked for throw(). In fact, throw has the same level of optimizability as functions with no exception specification.\nFor some functions, noexcept is even more desired. For example, calls to copy operations in C++98 will be replaced with calls to move operations in C++11, only if the move operation is declared noexcept. Similarly, swaps in the Standard Library are noexcpet sometimes dependends on whether uesr-defined swaps are noexcept. Following is the declarations for the Standard Library\u0026rsquo;s swaps for arrays and std::pair:\n1 2 3 4 5 6 7 8 9 10 template\u0026lt;class T, size_t N\u0026gt; void swap(T (\u0026amp;a)[N], T (\u0026amp;b)[N]) noexcept(noexcept(swap(*a, *b))); template\u0026lt;class T1, class T2\u0026gt; struct pair { ... void swap(pair\u0026amp; p) noexcept(noexcept(swap(first, p.first)) \u0026amp;\u0026amp; noexcept(swap(second, p.second))); ... }; These functions are conditionally noexcept: whether they are noexcept depends on whether the expression inside the noexcept clauses are noexcept. The fact that swapping higher-level data structures can generally be noexcept only if swapping their lower-level constituents is noexcept should be reasonable enough to offer noexcept swap functions whenever we can.\nException Neutral Functions noexcept is part of a function\u0026rsquo;s interface, so we should declare a function noexcept only if we are willing to commit to a noexcept implementation over the long term.\nHowever, most functions are exception-newtral: they throw no exceptions themselves, but functions they call might emit one. Such functions are never noexcept, because they may emit such \u0026ldquo;just passing through\u0026rdquo; exceptions, and thus they lack the noexcept designation on purpose.\nFor some other few functions, on the other hand, being noexcept is so important that, in C++11, they are implicitly noexcept: by default, all memory deallocation functions and destructors (both user-defined and compiler-generated) are noexcept.\nWide Contracts vs Narrow Contracts A function with a wide contract has no preconditions: they can be called regardless of the state of the program, with no constraints on the arguments that callers pass it, and never exhibit undefined behavior.\nFunctions withou wide contracts have narrow contract: if a precondition is violated, results are undefined.\nGenerally, library desingers reserve noexcept for functions with wide contracts, so that if a precondition in a narrow contract is violated, the program may throw a \u0026ldquo;precondition was violated\u0026rdquo; exception, instead of letting the program to terminate.\nIf we\u0026rsquo;re writing a function with a wide contract and we know it won\u0026rsquo;t emit exceptions, just declare it noexcept.\nBackward compatibility So much legacy code is not decalred with noexcpet even though they actually never emit exceptions. For the reason of backward compatibility, noexcept functions calling non-noexcept functions are permitted in C++, and compilers generally don\u0026rsquo;t issue warnings about it:\n1 2 3 4 5 6 7 8 9 void setup(); // legacy code defined elsewhere void cleanup(); // without declaring noexcept void doWork() noexcept { setup(); ... clean(); } ",
  "summary": "Most functions are exception-neutral, but for some, such as move operations, swap, memory deallocation functions, and destructors, noexcept is particularly valuable.\n",
  "date": "2018-07-20T19:50:39-04:00",
  "lastmod": "2018-07-20T19:50:39-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/07/declare-functions-noexcept-if-they-wont-emit-exception/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
