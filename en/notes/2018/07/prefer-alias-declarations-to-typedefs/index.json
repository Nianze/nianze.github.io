{
  "title": "[EMCpp]Item-9 Prefer Alias Declarations to Typedefs",
  "content": "Alias declaration support templatization, which avoids the \u0026ldquo;::type\u0026rdquo; suffix and \u0026ldquo;typename\u0026rdquo; prefix often required to refer typedefs.\nCompared with typedef, alias declarations have following advantages:\nEasier to understand 1 2 3 typedef void (*FP)(int, const std::string\u0026amp;); // same meaning as above using alias declaration using FP = void (*)(int, const std::string\u0026amp;); Support for template Alias declarations may be templatized (called alias templates), while typedefs cannot. For example, suppose we want to define a synonym for a linked list that uses a custom allocator MyAlloc:\n1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename T\u0026gt; using MyAllocList = std::list\u0026lt;T, MyAlloc\u0026lt;T\u0026gt;\u0026gt;; // client code MyAllocList\u0026lt;std::string\u0026gt; ls; template\u0026lt;typename T\u0026gt; class Widget { // Widget contains a MyAllocList\u0026lt;T\u0026gt; as a data member private: typename MyAllocList\u0026lt;T\u0026gt; list; } With a typedef, to support template, we need the trick to nest typedef inside templatized structs:\n1 2 3 4 5 6 7 template\u0026lt;typename T\u0026gt; struct MyAllocList { typedef std::list\u0026lt;T, MyAlloc\u0026lt;T\u0026gt;\u0026gt; type; }; // client code MyAllocList\u0026lt;Widget\u0026gt;::type lw; To make things worse, when using the typedef inside a template class, we have to precede the typedef name with typename, so that compilers get comfirmed that MyAllocList\u0026lt;T\u0026gt;::type refers to a type, instead of a data member named type inside MyAllocList:\n1 2 3 4 5 template\u0026lt;typename T\u0026gt; class Widget { private: typename MyAllocList\u0026lt;T\u0026gt;::type list; } Type traits supported by alias templates in C++14\nWhen we need to take template type parameters and create revised types from them(e.g., turn Widget into Widget\u0026amp;), we perform these kinds of transformations through type traits. Since type traits in C++11 are implemented as nested typedefs inside templatized structs, C++14 provides corresponding alias templates:\n1 2 3 4 5 6 7 8 std::remove_const\u0026lt;T\u0026gt;::type // C++11: const T -\u0026gt; T std::remove_const_t\u0026lt;T\u0026gt; // C++14 equivalent std::remove_reference\u0026lt;T\u0026gt;::type // C++11: T\u0026amp;/T\u0026amp;\u0026amp; -\u0026gt; T std::remove_reference_t\u0026lt;T\u0026gt; // C++14 equivalent std::add_lvalue_reference\u0026lt;T\u0026gt;::type // C++11: T -\u0026gt; T\u0026amp; std::add_lvalue_refernece_t\u0026lt;T\u0026gt; // C++14 equivalent Basically what C++14 adds is simply some code like this:\n1 2 3 4 5 6 template \u0026lt;class T\u0026gt; using remove_const_t = typename remove_const\u0026lt;T\u0026gt;::type; template \u0026lt;class T\u0026gt; using remove_reference_t = typename remove_reference\u0026lt;T\u0026gt;::type; template \u0026lt;class T\u0026gt; using add_lvalue_reference_t = typename add_lvalue_reference\u0026lt;T\u0026gt;::type; ",
  "summary": "Alias declaration support templatization, which avoids the \u0026ldquo;::type\u0026rdquo; suffix and \u0026ldquo;typename\u0026rdquo; prefix often required to refer typedefs.\n",
  "date": "2018-07-12T13:03:01-04:00",
  "lastmod": "2018-07-12T13:03:01-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/07/prefer-alias-declarations-to-typedefs/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
