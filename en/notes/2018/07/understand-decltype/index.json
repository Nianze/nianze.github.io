{
  "title": "[EMCpp]Item-3 Understand Decltype",
  "content": "decltype almost always yields the type of a variable or expression without any modifications. For lvalue expressions of type T other than names, decltype always reports a type of T\u0026amp;.\nThe primary use of decltype is declaring function templates where the function\u0026rsquo;s return type depends on its parameter types. For example, the indexing operator [] on a containedr of objects of type T typically return T\u0026amp;, but in the case of std::vector\u0026lt;bool\u0026gt;, operator[] returns a brand new object (refer to EMCpp item 6 for whys and hows). In order to let compiler deduce the return type, we can use decltype:\n1 2 3 4 5 6 7 // C++14 version template\u0026lt;typename Container, typename Index\u0026gt; decltype(auto) authAndAccess(Container\u0026amp;\u0026amp; c, Index i) { authenticateUser(); return std::forward\u0026lt;Container\u0026gt;(c)[i]; } A few points worth noting here:\nreturn type is decltype(auto)1 instead of auto. As EMCpp item 2 points out, compilers employ template type deduction for functions with an auto return type. If using auto, the reference-ness will be stripped off, so T\u0026amp;, which is the type returned by operator[] in most cases, will be deduced as T. This is not what we want.\nuniversal refrences for the first parameter is used here. As EMCpp item 24 explains, this makes the reference paramter c be able to bind to both lvalues and rvlues2. Following the exmpale of the Standard Library for index values, we stick with pass-by-value for i though.\nthe std::forward is applied to the universal reference in accord with EMCpp item 25\u0026rsquo;s admonition.\nin C++11, auto is not permitted as return types for non-lambda functions, so we need the trailing return type syntax to tell the compiler that the function\u0026rsquo;s return type will be declared following the parameter list (after the \u0026ldquo;-\u0026gt;\u0026rdquo;), which give us the advantage to use the function\u0026rsquo;s parameters (c and i here) in the specification of the return type:\n1 2 3 4 5 6 7 8 // C++11 version template\u0026lt;typename Container, typename Index\u0026gt; auto authAndAccess(Container\u0026amp;\u0026amp; c, Index i) -\u0026gt; decltype(std::forward\u0026lt;Container\u0026gt;(c)[i]) { authenticateUser(); return std::forward\u0026lt;Container\u0026gt;(c)[i]; } Exceptions As mentioned in the begining, decltype almost always produces the type we expect - it means that there are exceptions to the rule. We\u0026rsquo;re unlikely to encounter these exceptions unless we\u0026rsquo;re a heavy-duty library implementer.\nFor example, decltype generally ensures that the type induced for lvalue expressions more complicated than names is an lvalue reference. Since the type of most lvalue expressions inherently includes an lvalue reference qualifier (for example, functions returning lvalues always return lvalue references), this property seldom has any impact. However, a seemingly trivial change in the way we write a return statement can affect the deduced type for a function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 decltype(auto) f1() { int x = 0; ... return x; // decltype(x) is int, so f1 returns int } decltype(auto) f2() { int x = 0; ... return (x); // decltype((x)) is int\u0026amp;, so f1 returns int\u0026amp; } C++ defines the expression (x) to be an lvalue, which is also an expression more complicated than a variable name x, so decltype((x)) is int\u0026amp;, leading to different return types in f1 and f2. Moreover, f2 returns a reference to a local variable, which means undefined behavior that we don\u0026rsquo;t want.\nSummary The lesson we learn from the above example is to pay close attention when using decltype(auto). The techniques described in EMCpp item 4 may help ensure that the deduced type is what we expect.\nMeanwhile, don\u0026rsquo;t lose sight of the bigger picture: in most normal cases where decltype is applied to names, decltype does just what it sounds like: it reports that name\u0026rsquo;s declared type.\nThe use of decltype(auto) is not limited to function return types. We can use is for declaring variables. For example, given const Widget\u0026amp; type variable cw, auto myWidget1 = cw; will employ auto type deduction and deduce myWidget1 as type of Widget, while decltype(auto) myWidget2 = cw; uses decltype type deduction, leading to myWidget2\u0026rsquo;s type as const Widget\u0026amp;.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSupporting the use of rvalue is basically supporting such a function that a client might simply make a copy of an element in the temporary container. Otherwise, an rvalue container (a.k.a. a temporary object) would typically be destroyed at the end of the statement containing the call to authAndAccess, which means that a reference to an element in that container (typically what authAndAccess would return in the most cases) would dangle at the end of the statement.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
  "summary": "decltype almost always yields the type of a variable or expression without any modifications. For lvalue expressions of type T other than names, decltype always reports a type of T\u0026amp;.\n",
  "date": "2018-07-05T18:59:39-04:00",
  "lastmod": "2018-07-05T18:59:39-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/07/understand-decltype/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
