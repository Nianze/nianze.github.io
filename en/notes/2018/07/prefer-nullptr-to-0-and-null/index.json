{
  "title": "[EMCpp]Item-8 Prefer Nullptr to 0 and NULL",
  "content": "nullptr doean\u0026rsquo;t suffer from the overloading problem or the template deduction problem that 0 and NULL are susceptible to. It also improves code clarity.\nIn C++98, a null pointer can be represented by an int 0 or NULL1, which introduses some controdiction between the apparent meaning (mean to refer to a null pointer) and actual meaning (the representation is some kind of integer). Neither 0 nor NULL has a pointer type - it\u0026rsquo;s just that C++ will (reluctently) interpret them as a null pointer in the context where a pointer a pointer is wanted but can\u0026rsquo;t be found.\nThat\u0026rsquo;s why nullptr is introduced: its type is not integral, but std::nullptr_t2, which could be treated as a pointer of all types due to its ability to implicitly convert to all raw pointer types.\nCompared with 0 and NULL, the obvious advantages shown by nullptr is its better support for overloading and template, as well as its improved code clarity.\nOverloading 1 2 3 4 5 6 7 void f(int); void f(bool); void f(void*); f(0); // calls f(int) f(NULL); // might not compile, but typically calls f(int), never calls f(void*) f(nullptr); // calls f(void*) Template Inside a template, if an int or NULL (which is int-like type) is being passed to a function that requires a pointer, type errors occur:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // call these only then approriate mutix is locked int f1(std::shared_ptr\u0026lt;Widget\u0026gt; spw); int f2(std::unique_ptr\u0026lt;Widget\u0026gt; upw); bool f3(Widget* pw); template\u0026lt;typename FuncType, typename MuxType, typename PtrType\u0026gt; declType(auto) lockAndCall(FuncType func, // C++14 MuxType\u0026amp; mutex PtrType ptr) { using MuxGuard = std::lock_guard\u0026lt;std::mutex\u0026gt;; MuxGuard g(mutex); // lock mutex for func return func(ptr); // pass ptr (pointer type) to func } // unlock mutex std::mutex f1m, f2m, f3m; auto result1 = lockAndCall(f1, f1m, 0); // error auto result2 = lockAndCall(f2, f2m, NULL); // error auto result3 = lockAndCall(f3, f3m, nullptr); // fine In contrast, here, when nullptr is passed to lockAndCall, the type for ptr is deduced to be std::nullptr_t instead of previous int (or int-like one), and when ptr is passed to f3, there is an implicit conversion from std::nullptr_t to Widget*.\nCode clarity Using 0, the return type may not be obvious, is it an integral type or a pointer type?\n1 2 3 4 auto result = findRecord(/* args. */); if (result == 0) { ... } There\u0026rsquo;s no ambiguity when using nullptr:\n1 2 3 4 auto result = findRecord( /* args */ ); if (result == nullptr) { ... } There is some leeway regarding the implementaition of the type of NULL - possibly, NULL will be defined to be 0L as a long.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nstd::nullptr_t, techniquely, is not a pointer type. The type is in a circular definition: std::nullptr_t is defined to be the type of nullptr.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
  "summary": "nullptr doean\u0026rsquo;t suffer from the overloading problem or the template deduction problem that 0 and NULL are susceptible to. It also improves code clarity.\n",
  "date": "2018-07-11T18:03:51-04:00",
  "lastmod": "2018-07-11T18:03:51-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/07/prefer-nullptr-to-0-and-null/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
