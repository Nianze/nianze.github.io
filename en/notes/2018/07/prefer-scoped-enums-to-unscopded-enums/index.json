{
  "title": "[EMCpp]Item-10 Prefer Scoped enums to Unscopded enums",
  "content": "Enumerators of scoped enums are visible only within the enum, convert to other types only with a cast, and always support forward-declared because their default underlying type is int.\nScope Generally speaking, declaring a name inside curly braces limits the visibility of that name to the scope defined by the braces, with one exception: the C++98-style enums, which lead to enumerator names leaking into the scope containing their enum definition, and thus have an official term - unscoped enums.\n1 2 enum Color { black, white, red }; // black, white, red are in same scope as Color auto white = false; // error! white already declared in this scope As their new C++11 counterparts, by adding a class in declaration, scoped enums don\u0026rsquo;t leak names:\n1 2 3 4 enum class Color { black, white, red }; auto white = false; // fine. no other \u0026#34;whate\u0026#34; in scope Color c = white; // error auto c = Color::white; // fine, type of c is Color Implicit conversion The fact that scoped enums have strong typed enumerators results in their inability to implicitly convert to integral types (and, from there, to floating-point types), which behavior is otherwise permited in terms of unscoped enums:\n1 2 3 4 5 6 Color c = Color::red; std::vector\u0026lt;std::size_t\u0026gt; primeFactors(std:size_t x); // func. returning prime factors of x ... if (c \u0026lt; 14.5) { // error! can\u0026#39;t compare Color and double auto factors = primeFactors(c); // error! can\u0026#39;t pass Color to function expecting std::size_t } Instead, in order to convert typefrom Color to a different type, we need a cast:\n1 2 3 if (static_cast\u0026lt;double\u0026gt;(c) \u0026lt; 14.5 ) { // odd code, but valid auto factors = primeFactors(static_cast\u0026lt;std::size_t\u0026gt;(c)); } Forward declaration Technically speaking, both scoped and unscoped enums may be forward-declared, except that unscoped ones need a bit of additional work - by specifying the underlying type for unscoped enums1:\n1 enum Status: std::unit8_t; // fwd decl for unscoped enum; Since scoped enums have a default underlying type of int, forward declaration is always supported:\n1 2 enum class Status; // forward declaration void continueProcessing(Status s); // use of fwd-declared enum With the help of forward declaration, the header containing the declarations requires no recompilation if Status\u0026rsquo;s definition is revised. Furthermore, it is also possible that continueProcessing\u0026rsquo;s implementation need not be recompiled2.\nTwist There\u0026rsquo;s still some situation where unscoped enums may be useful: when referring to fields within C++11\u0026rsquo;s std::tuples. Suppose we have a tuple holding values for the name, email address, and reputation value for a user at a social networking website:\n1 2 3 4 using UserInfo = // type alias std::tuple\u0026lt;std::string // name std::string // email std::size_t\u0026gt; // reputation To get field value, using an unscoped enum to associate names with field numbers may be helpful:\n1 2 3 4 enum UserInfoFields { uiName, uiEmail, uiReputation }; UserInfo uInfo; ... auto val = std::get\u0026lt;uiEmail\u0026gt;(uInfo); // implicit conversion from UserInfoFields to std::size_t To mimic the similar behavior, using scoped enums is more verbose:\n1 2 3 enum class UserInfoFields { uiName, uiEmail, uiReputation }; ... auto val = std::get\u0026lt;static_cast\u0026lt;std::size_t\u0026gt;(UserInfoFields::uiEmail)\u0026gt;(uInfo); To save some typing, we might consider define a helper function, or in a more generalized form, a function template toUType that takes an arbitrary enumerator and return its value as a compile-time constant:\n1 2 3 4 5 6 template\u0026lt;typename E\u0026gt; constexpr typename std::underlying_type\u0026lt;E\u0026gt;::typename // see item 9 for info on type traits toUType(E enumerator) noexcept { return static_cast\u0026lt;typename std::underlying_type\u0026lt;E\u0026gt;::type\u0026gt;(enumerator); } In C++14, we may simplify the toUType to a sleeker form:\n1 2 3 4 5 template\u0026lt;typename E\u0026gt; constexpr auto toUType(E enumerator) noexcept { return static_cast\u0026lt;std::underlying_type_t\u0026lt;E\u0026gt;\u0026gt;(enumerator); } And then we access a field of the tuple like this:\n1 auto val = std::get\u0026lt;toUType(\u0026lt;UserInfoFields::uiEmail)\u0026gt;(uInfo); Still more to write than use of the unscoped enum, but it also avoids namespace pollution and inadvertent conversions involving enumerators, so those extra characters might still be a reasonable to pay for.\nSince there is no default underlying type for unscoped enums, to make it possible for compilers to select an underlying type for each enum prior to the enum being used, C++98 supports only enum definitions (when all enumerators are listed), while enum declarations are not allowed.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThis happens if Status is modified (e.g., add a new enumerator), but continueProcessing\u0026rsquo;s behavior is unaffected (e.g., the function doesn\u0026rsquo;t use the newly added enumerator).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
  "summary": "Enumerators of scoped enums are visible only within the enum, convert to other types only with a cast, and always support forward-declared because their default underlying type is int.\n",
  "date": "2018-07-14T13:33:33-04:00",
  "lastmod": "2018-07-14T13:33:33-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/07/prefer-scoped-enums-to-unscopded-enums/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
