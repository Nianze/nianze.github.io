{
  "title": "[EMCpp]Item-23 Understand std::Move and std::Forward",
  "content": "std::move performs an unconditional cast to an rvalue, while std::forward casts its argument to an rvalue only if that argument is bound to an rvalue.\nSome facts:\nNeither std::move nor std::forward do anything at runtime. Move request on const objects are treated as copy requests. std::move To make things concrete, a very basic implementation of std::move in C++11 looks like this:\n1 2 3 4 5 6 7 template\u0026lt;typename T\u0026gt; typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp; move(T\u0026amp;\u0026amp; param) { using ReturnType = typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp;; return static_cast\u0026lt;ReturnType\u0026gt;(param); } Or, a more elegant implementation in C++14:\n1 2 3 4 5 6 template\u0026lt;typename T\u0026gt; decltype\u0026lt;auto\u0026gt; move(T\u0026amp;\u0026amp; param) { using ReturnType = remove_reference_t\u0026lt;T\u0026gt;\u0026amp;\u0026amp;; return static_cast\u0026lt;ReturnType\u0026gt;(param); } Basically, std::move does nothing but cast its argument to an rvalue, and we might think it as rvalue_cast. Usually we want move operation on rvalues, so every time we see a move over some parameter, we know we want to perform move operation over the resulting rvalue. However, not all rvalues are candidates for moving, especailly those annotated by const - move requests on const objects are silentlly transformed into copy operation.\nstd::forward std::move unconditionally casts its argument to an rvalue, while std::forward conditionally do so: it casts to an rvalue only if its argument was initialized with an rvalue.\nThe most common scenario is a function template taking a universal reference parameter that is to be passed to another function:\n1 2 3 4 5 6 7 8 9 10 void process(const Widget\u0026amp; lvalArg); void process(Widget\u0026amp;\u0026amp; rvalArg); template\u0026lt;typename T\u0026gt; void logAndProcess(T\u0026amp;\u0026amp; param) // universal reference { auto now = std::chrono::system_clock::now(); makeLogEntry(\u0026#34;Calling \u0026#39;process\u0026#39;\u0026#34;, now); process(std::forward\u0026lt;T\u0026gt;(param)); } 1 2 3 Widget w; logAndProcess(w); // call with lvalue logAndProcess(std::move(w)); // call with rvalue In the code above, std::forward is able to tell whether param is initialized with an lvalue or an rvalue because that information is encoded in logAndProcess\u0026rsquo;s template parameter T, which is then passed to std::forward, which is able to recover the encoded information. For details, refer to EMCpp item 28.\nComparison Depending on the usecase scenario, we can tell when to use which:\nstd:move typically sets up a move std::forward just passes - forwards- an object to another function in a way that retains its original lvalueness or rvalueness. ",
  "summary": "std::move performs an unconditional cast to an rvalue, while std::forward casts its argument to an rvalue only if that argument is bound to an rvalue.\n",
  "date": "2018-08-07T17:57:26-04:00",
  "lastmod": "2018-08-07T17:57:26-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/08/understand-stdmove-and-stdforward/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
