{
  "title": "[EMCpp]Item-28 Understand Reference Collapsing",
  "content": "Reference collapsing occurs in four contexts: template instantiation, auto type generation, creation and use of typedefs and alias declarations, and decltype.\nThe core concept in this item: A universal reference isn\u0026rsquo;t a new kind of reference, it\u0026rsquo;s actually an rvalue reference in a context where two conditions are satisfied:\nType deduction distinguishes lvalues from rvalues. (Lvalues of type T are deduced to have type T\u0026amp;, while rvalues of type T yield T) Reference collapsing occurs. Specifically, if a reference to a reference is generated by compilers arises in one of the four context mentioned above, the references collapse to a single reference according this rule:\nif either of the original references is an lvalue reference, the result is an lvalue reference otherwise, it\u0026rsquo;s an rvalue reference Template instantiation Reference collapsing is a key part to make std::forward work. For example, given an possible implementation of std::forward and a function f:\n1 2 3 4 5 6 7 8 9 10 11 12 template\u0026lt;typename T\u0026gt; T\u0026amp;\u0026amp; forward(typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp; param) { return static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(param); } template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; Param) { ... someFunc(std::forward\u0026lt;T\u0026gt;(fParam)); } If we pass an lvalue of type Widget to function f, T will then be deduced as Widget\u0026amp;, and we get:\n1 2 3 4 Widget\u0026amp; \u0026amp;\u0026amp; forward(typename remove_reference\u0026lt;Widget\u0026amp;\u0026gt;::type\u0026amp; param) { return static_cast\u0026lt;Widget\u0026amp; \u0026amp;\u0026amp;\u0026gt;(param); } According to reference collapsing rule, we get:\n1 2 3 4 Widget\u0026amp; forward(Widget\u0026amp; param) { return static_cast\u0026lt;Widget\u0026amp;\u0026gt;(param); } If we pass to f an rvalue of type Widget, T will then be Widget, and we get:\n1 2 3 4 Widget \u0026amp;\u0026amp; forward(typename remove_reference\u0026lt;Widget\u0026gt;::type\u0026amp; param) { return static_cast\u0026lt;Widget \u0026amp;\u0026amp;\u0026gt;(param); } According to reference collapsing rule, we get:\n1 2 3 4 Widget\u0026amp;\u0026amp; forward(Widget\u0026amp; param) { return static_cast\u0026lt;Widget\u0026amp;\u0026amp;\u0026gt;(param); } Overall, an rvalue arguement Widget passed to f will be bound to the lvalue parameter fParam firstly, be casted into an rvalue, and then be forwarded to someFunc.\nauto type generation Type deduction for auto variables is essentially the same as deduction for templates.\n1 2 3 4 5 6 Widget widgetFactory(); Widget w; // w is lvalue auto\u0026amp;\u0026amp; w1 = w; // type deduces as Widget\u0026amp;, so Widget\u0026amp; \u0026amp;\u0026amp; w1 = w -collapsing-\u0026gt; Wiget\u0026amp; w1 = w auto\u0026amp;\u0026amp; w2 = widgetFactory(); // type deduces as Widget, so Widget\u0026amp;\u0026amp; w2 = widgetFactory(); typedefs and alias declarations 1 2 3 4 5 6 template\u0026lt;typename T\u0026gt; class Widget { public: typedefs T\u0026amp;\u0026amp; RvalueRefToT; ... } Given Widget\u0026lt;int\u0026amp;\u0026gt; w;, we get typedef int\u0026amp; \u0026amp;\u0026amp; RvalueRefToT;, which then collapses into typedef int\u0026amp; RvalueRefToT;. Interestingly, the name turns out to be misleading: the typedef actually refers to an lvalue reference to int now if instantiated with an lvalue reference type int\u0026amp;.\ndecltype Same logic as above to analyze.\n",
  "summary": "Reference collapsing occurs in four contexts: template instantiation, auto type generation, creation and use of typedefs and alias declarations, and decltype.\n",
  "date": "2018-08-17T19:46:25-04:00",
  "lastmod": "2018-08-17T19:46:25-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/08/understand-reference-collapsing/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
