{
  "title": "[EMCpp]Item-22 When Using Pimple Idiom, Define Special Member Functions in the Implementation File",
  "content": "For std::unique_ptr pImpl pointers, declare special member functions in the class header, but implement them in the implementation file.\nThe Pimpl Idiom decreases build times by reducing compilation dependeencies between class clients and class implementation. For example:\n1 2 3 4 5 6 7 8 9 // header file class Widget { public: Widget(); ... private: struct Impl; std::unique_ptr\u0026lt;Impl\u0026gt; pImpl; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // impl. file #include \u0026#34;Widget.h\u0026#34; #include \u0026#34;gadget.h\u0026#34; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; struct Widget::Impl { std::string name; std::vector\u0026lt;double\u0026gt; data; Gadget g1, g2, g3; }; Widget::Widget () : pImpl(std::make_unique\u0026lt;Impl\u0026gt;()) {} However, even though the code above compiles, client code below won\u0026rsquo;t compile:\n1 2 #include \u0026#34;Widget.h\u0026#34; Widget w; // error! The issue arises due to the code that\u0026rsquo;s generated when w goes out of scope and gets destroyed:\nSince there\u0026rsquo;s no user defined destructor, destructor for Widget is generated by compiler, inside which there is a call to the destructor for pImpl pImpl is a std::unique_ptr\u0026lt;Widget::Impl\u0026gt; using default deleter (a function that uses delete on the raw pointer inside the std::unique_ptr) prior to using delete, autogenerated implementation will have the default deleter employ C++11\u0026rsquo;s static_assert to ensure the raw pointer doesn\u0026rsquo;t point to an incomplete type here this static_assert fails, because autogenerated destructors are implicitly inline, and thus the definition of Widget::Impl along with its autogenerated destructor inside Widget.cpp hasn\u0026rsquo;t been seen by compilers To solve the problem, we need to let the compiler see the body of Widget\u0026rsquo;s destructor only inside the implementation file after Widget::Impl has been defined:\n1 2 3 4 5 6 7 8 9 10 // header file class Widget { public: Widget(); ~Widget(); // declaration only ... private: struct Impl; std::unique_ptr\u0026lt;Impl\u0026gt; pImpl; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // impl. file #include \u0026#34;Widget.h\u0026#34; #include \u0026#34;gadget.h\u0026#34; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; struct Widget::Impl { std::string name; std::vector\u0026lt;double\u0026gt; data; Gadget g1, g2, g3; }; Widget::Widget () : pImpl(std::make_unique\u0026lt;Impl\u0026gt;()) {} Widget::~Widget() {} To emphasize the fact that the compiler-generated destructor would do the right thing, we can also write like this:\n1 Widget::~Widget() = default; The same reasoning goes with move operation:\nthe compiler generated move assignment operator requires Impl to be complete because the object pointed to by pImpl needs to be destroyed before assignment the compiler generated move constructor requires Impl to be complete because compilers must be able to generate code to destroy pImpl in the event that an exception arises inside the move constructor (even it the constructor is noexcept) Once we added the move-related functions, compilers won\u0026rsquo;t generate copy operations for us. So to support a well-defined deep copy, we need to write our own version.\n1 2 3 4 5 6 7 8 9 10 11 12 class Widget { public: Widget(); ~Widget(); Widget(Widget\u0026amp;\u0026amp; rhs) noexcept; Widget\u0026amp; operator=(Widget\u0026amp;\u0026amp; rhs) noexcept; Widget(const Widget\u0026amp; rhs); Widgt\u0026amp; operator=(const Widget\u0026amp; rhs); private: struct Impl; std::unique_str\u0026lt;Impl\u0026gt; pImpl; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ... Widget::~Widget() = default; Widget::Widget(Widget\u0026amp;\u0026amp; rhs) noexcept = default; Widget\u0026amp; Widget::operator=(Widget\u0026amp;\u0026amp; rhs) noexcept = default; Widget::Widget(const Widget\u0026amp; rhs) : pImpl(nullptr) { if (rhs.pImpl) pImpl = std::make_unique\u0026lt;Impl\u0026gt;(*rhs.pImpl); } Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { if (!rhs.pImpl) pImpl.reset(); else if (!pImpl) pImpl = std::make_unique\u0026lt;Impl\u0026gt;(*rhs.pImpl); else *pImpl = *rhs.pImpl; return *this; } On the other hand, the above advice does not apply to std::shared_ptr, because in std::shared_ptr, the type of the deleter is not part of the type of the smart pointer, and pointed-to types need not be complete when compiler-generated special functions are employed:\n1 2 3 4 5 6 7 8 class Widget { public: Widget(); ... // no declaration for dtor or move operations private: struct Impl; std::shared_ptr\u0026lt;Impl\u0026gt; pImpl; }; 1 2 3 4 // client code compiles without problem Widget w1; auto w2(std::move(w1)); // move-construct w2 w1 = std::move(w2); // move-assign w1 ",
  "summary": "For std::unique_ptr pImpl pointers, declare special member functions in the class header, but implement them in the implementation file.\n",
  "date": "2018-08-05T23:46:08-04:00",
  "lastmod": "2018-08-05T23:46:08-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/08/prefer-make_unique-and-make_shared-to-direct-use-of-new/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
