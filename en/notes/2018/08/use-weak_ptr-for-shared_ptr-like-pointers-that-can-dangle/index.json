{
  "title": "[EMCpp]Item-20 Use Weak_ptr for Shared_ptr Like Pointers That Can Dangle",
  "content": "Potential use cases for std::weak_ptr include caching, observer lists, and the prevention of std::shared_ptr cycles.\nFrom an efficiency perspective, the std::weak_ptr is essentially the same as std::shared_ptr, except that they don\u0026rsquo;t participate in the shared ownership of objects and hence don\u0026rsquo;t affect the pointed-to object\u0026rsquo;s reference count. However, they do manipulate a second reference count in the control block (weak count), so they actually do all the same operations such as construction, destruction, and assignment involve atomic reference count manipulations.\nAs a fact, std::weak_ptr isn\u0026rsquo;t a standalone smart pointer, but an augmentation of std::shared_ptr:\n1 2 3 4 5 6 auto spw = std::make_shared\u0026lt;Widget\u0026gt;(); // reference count (RC) is 1 after spw is constructed ... std::weak_ptr\u0026lt;Widget\u0026gt; wpw(spw); // RC remains 1 ... spw = nullptr; // RC becomes 0, Widget gets destroyed, wpw dangles if (wpw.exipred()) ... // true Usually, the purpose of creating a std::weak_ptr is to check the dangling std::weak_ptr (when the related control block has zero-value reference count), and if it hasn\u0026rsquo;t expired, we may access the object it points to. Separating the check and the dereference would introduce a race condition, so we need an atomic operation to check and access the object at the same time. There are two ways to do this:\n1 2 auto spw1 = wpw.lock(); // spw1 type is shared_ptr\u0026lt;Widget\u0026gt;; if wpw\u0026#39;s expired, spw1 is null std::shared_ptr\u0026lt;Widget\u0026gt; spw2(wpw); // if wpw\u0026#39;s expired, throw std::bad_weak_ptr There are at least three use cases for std::weak_ptr.\nCaching Given a factory function returning std::unique_ptr:\n1 std::unique_ptr\u0026lt;const Widget\u0026gt; loadWidget(WidgetID id); We might consider wrap a cache layer on top of loadWidget due to considerations such as expensive database I/O cost or frequent queries from clients. A quick-and-dirty implementation using std::weak_ptr may fit the requirement1:\n1 2 3 4 5 6 7 8 9 10 11 std::shared_ptr\u0026lt;const Widget\u0026gt; fastLoadWidget(WidgetID id) { static std::unordered_map\u0026lt;WidgetID, std::weak_ptr\u0026lt;const Widget\u0026gt;\u0026gt; cache; auto objPtr = cache[id].lock(); if (!objPtr) { objPtr = loadWidget(id); cache[id] = objPtr; } return objPtr; } Observer list In the Observer design pattern, there are two components:\nsubjects: whose state may change observers: who will be notified when state changes occur Each subject may contain a data member holding pointers to its observers to issue state change notifications. Since subjects only cares if an observer gets destroyed (to cancel subsequent notifications) and needn\u0026rsquo;t control the lifetime of their observers, a reasonable design, therefore, is to let each subject hold a container of std::weak_ptrs to its observers, and check if a pointer dangles before using it.\nCycling prevention In strictly hierarchal data structures such as trees, child nodes are typially owned only by their parents. When a parent node is destroyed, child nodes are destroyed, too. Links from parents to children are generally best represented by std::unique_ptr, while back-links from children to parents can be safely implemented as raw pointers2.\nIn other pointer-based non-strict-hierarchical data structure, however, forward-links may be best implemented in terms of std::shared_ptr, and to prevent cycles, which will lead to resource leak3, back-link should use std::weak_ptr.\nA potential refinement is to remove the expired cache, since right now the cache accumulate std::weak_ptr corresponding to Widgets that are no longer in use (and have therefore been destroyed).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nChildren have a shorter lifetime than their parent node, so there\u0026rsquo;s no risk of a child node dereferencing a dangling parent pointer.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTwo std::shared_ptrs point to each other wil prevent both from being destroyed: even if both object are unreachable from other program data structures, each will have a reference count of one.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
  "summary": "Potential use cases for std::weak_ptr include caching, observer lists, and the prevention of std::shared_ptr cycles.\n",
  "date": "2018-08-01T18:44:19-04:00",
  "lastmod": "2018-08-01T18:44:19-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/08/use-weak_ptr-for-shared_ptr-like-pointers-that-can-dangle/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
