{
  "title": "[EMCpp]Item-24 Distinguish Universal References From Rvalue References",
  "content": "If a function template parameter has type T\u0026amp;\u0026amp; for a deduced type T, or if an object is declared using auto\u0026amp;\u0026amp;, the parameter or object is a universal reference.\nT\u0026amp;\u0026amp; has two different meanings: one is for rvalue reference, another is for universal reference. Universal references are called \u0026ldquo;universal\u0026rdquo;, because they can bind to virtually anything:\nbind to rvalues (behave like rvalue references T\u0026amp;\u0026amp;) bind to lvalues (behave like lvalue references T\u0026amp;) bind to objects that is const or non-const, volatile or non-volatile, or both const and volatile Universal refenrences must company with a special form (i.e., the form of \u0026ldquo;T\u0026amp;\u0026amp;\u0026rdquo;) after the occurrence of type deduction, and typically arise in two contexts: the most common case is function template parameters, while another context is auto declarations:\n1 2 3 4 5 6 7 template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); // param is a universal reference auto\u0026amp;\u0026amp; var2 = var1; // var2 is a universal reference Widget w; f(w); // lvalue passed to f; param\u0026#39;s type is Widget\u0026amp;, act as an lvalue ref. f(std::move(w)); // rvalue passed to f; param\u0026#39;s type is Widget\u0026amp;\u0026amp;, act as an rvalue ref. If there\u0026rsquo;s no type deduction, or if the type deduction form is incorrect (not in form of \u0026ldquo;T\u0026amp;\u0026amp;\u0026rdquo;), then there\u0026rsquo;s no universal references:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void f(Widget\u0026amp;\u0026amp; param); // no type deduction; param is an rvalue reference Widget\u0026amp;\u0026amp; var1 = Widget(); // no type deduction; param is an rvalue reference template\u0026lt;typename T\u0026gt; void f(std::vector\u0026lt;T\u0026gt;\u0026amp;\u0026amp; param); // not in precise form of T\u0026amp;\u0026amp;, param here is an rvalue ref. template\u0026lt;typename T\u0026gt; void f(const T\u0026amp;\u0026amp; param); // not in precise form of T\u0026amp;\u0026amp;, param here is an rvalue ref. template\u0026lt;typename T, class Allocator = allocator\u0026lt;T\u0026gt;\u0026gt; // from C++ standards class vector { public: void push_back(T\u0026amp;\u0026amp; x); // no type deduction here; x is rvalue reference; ... // a particular vector instantiation must have occurred prior to any call to this function } template\u0026lt;typename T, class Allocator = allocator\u0026lt;T\u0026gt;\u0026gt; // from C++ standards class vector { public: template\u0026lt;class... Args\u0026gt; void emplace_back(Args\u0026amp;\u0026amp;... args); // universal reference! because: ... // 1. in correct form of \u0026#34;T\u0026amp;\u0026amp;\u0026#34;; 2. type parameter Args must be deduced each time emplace_back is called } // this function can time pretty much any function execution. more information is in EMCpp item 30 auto timeFuncInvocation = // C++14 [] (auto\u0026amp;\u0026amp; func, auto\u0026amp;\u0026amp;... param) // func is a universal reference that can be bound to any callable object, lvaue or rvalue { // param is zero or more universal references (i.e., a universal reference parameter pack) that can be bound to any number of objects of arbitrary types // start timer; std::forward\u0026lt;decltype(func)\u0026gt;(func)( // invoke func on params std::forward\u0026lt;decltype(params)\u0026gt;(params)... ); // stop timer and record elapsed time; }; In fact, the foundation of univeral references is a lie (an \u0026ldquo;abstraction\u0026rdquo;), with underlying truth being known as reference collapsing discussed in EMCpp Item 28. Distinguishing between rvalue references and universal references will help us read source code more accurately.\n",
  "summary": "If a function template parameter has type T\u0026amp;\u0026amp; for a deduced type T, or if an object is declared using auto\u0026amp;\u0026amp;, the parameter or object is a universal reference.\n",
  "date": "2018-08-08T18:56:09-04:00",
  "lastmod": "2018-08-08T18:56:09-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/08/distinguish-universal-references-from-rvalue-references/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
