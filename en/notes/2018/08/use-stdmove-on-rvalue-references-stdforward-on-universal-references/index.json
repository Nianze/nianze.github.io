{
  "title": "[EMCpp]Item-25 Use std::move on Rvalue References, std::forward on Universal References",
  "content": "But don\u0026rsquo;t apply std::move or std::forward to local objects if they would otherwise be eligible for the return value optimization.\nNormal cases When forwarding them to other functions, rvalue references, which is always bound to rvalues, should be unconditionally cast to rvalues (via std::move), while universal references, which is sometimes bound be rvalues, should be conditionally cast to rvalues (via std::forward):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Widget { public: Widget(Widget\u0026amp;\u0026amp; rhs) // rhs is rvalue reference : name(std::move(rhs.name)), p(std::move(rhs.p)) {...} template\u0026lt;typename T\u0026gt; void setName(T\u0026amp;\u0026amp; newName) // newName is rvalue reference { name = std::forward\u0026lt;T\u0026gt;(newName); } ... private: std::string name; std::shared_ptr\u0026lt;SomeDataStructure\u0026gt; p; }; What if You may wonder, what will happen if we exchange std::forward ans std::move:\napplying std::forward on rvalue references can exhibit the proper behavior, but the source code is wordy, error-prone1, and unidiomatic:\n1 2 3 4 Widget::Widget(Widget\u0026amp;\u0026amp; rhs) : name(std::forward\u0026lt;std::string\u0026gt;(rhs.name)), p(std::forward\u0026lt;std::shared_ptr\u0026lt;SomeDataStructure\u0026gt;\u0026gt;(rhs.p)) {...} using std::move on universal refenreces can have the effect of unexpectedly modifying lvalues (e.g., local variables):\n1 2 3 4 5 6 7 8 9 template\u0026lt;typename T\u0026gt; void Widget::setName(T\u0026amp;\u0026amp; newName) { name = std::move(newName); } // compiles, but is bad! std::string getWidgetName(); // factory function Widget w; auto n = getWidgetName(); // n is local variable w.setName(n); // moves n into w ... // n\u0026#39;s value now unkown! Another alternative is to replace the template taking a universal reference with a pair of functions overloaded on lvalue references and rvalue references:\n1 2 3 4 5 6 7 8 class Widget { public: void setName(const std::string\u0026amp; newName) // set from const lvalue { name = newName; } void setName(std::string\u0026amp;\u0026amp; newName) // set from rvalue { name = std::move(newName); } ... }; The cost we pay for this replacement is:\nMore source code to write and maintain (two functions instead of a single template)\nLess efficient in some cases such as this2:\n1 w.setName(\u0026#34;John Smith\u0026#34;); Poor scalability of the design if more parameters come (each of which can be an lvalue or rvalue):\n1 2 tempalte\u0026lt;class T, class... Args\u0026gt; shared_ptr\u0026lt;T\u0026gt; make_shared(Args\u0026amp;\u0026amp;... args); // can\u0026#39;t overload on lvalues and rvalues on args. universal reference is used and std::forward is applyied Other usage Moreove, sometimes we want to apply std::move or std::forward to only the final use of the reference when an rvalue reference or a universal reference will be used more than once in a single function:\n1 2 3 4 5 6 7 template\u0026lt;typename T\u0026gt; void setSignText(T\u0026amp;\u0026amp; text) // text is a universal reference { sign.setText(text); // use text, but do not modify it auto now = std::chrono::system_clock::now(); signHistory.add(now, std::forward\u0026lt;T\u0026gt;(text)); // conditionally cast to rvalue } The same logic applies to std::move, except that in rare cases, we want to call std::move_if_noexcept instead of std::move (refer to EMCpp item 14).\nIf a function returns be value, and the returning object is bound to an rvalue refernece or a universal reference, we also want to apply std::move or std::forward to support potential move construction and get more efficient:\n1 2 3 4 5 6 7 8 9 10 11 12 Matric operator+(Matric\u0026amp;\u0026amp; lhs, const Matrix\u0026amp; rhs) { lhs += rhs; return std::move(lhs); // move lhs into return value } template\u0026lt;typename T\u0026gt; Fraction reduceAndCopy(T\u0026amp;\u0026amp; frac) { frac.reduce(); return std::forward\u0026lt;T\u0026gt;(frac); // move rvalue into return value; copy lvalue } When not to According to Standardization Committee, there\u0026rsquo;s a kind of optimizatoin called return value optimization (RVO):\nthe “copying” version of makeWidget can avoid the need to copy the local variable w by constructing it in the memory alloted for the function’s return value\nDue to this optimization, we should not use std::move on a local object being returnd from a function that\u0026rsquo;s returning by value so that we won\u0026rsquo;t precluding the RVO that compilers will do for the return value.\nThe type we pass to std::forward should be a non-reference, according to the convention for encoding that the argument being passed is an rvalue (see EMCpp Item 28).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWith the universal reference version, there\u0026rsquo;s only one call to std::string assignment operator for w.name, since the string literal would be passed to this function as a const char* pointer; the overloaded versions entail execution of one std::string constructor (to create a temporary), one std::string move assignment operator (to move newName into w.name), and one std::string destructor (to destroy the temporary), which is almost certainly more expensive.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
  "summary": "But don\u0026rsquo;t apply std::move or std::forward to local objects if they would otherwise be eligible for the return value optimization.\n",
  "date": "2018-08-11T15:26:53-04:00",
  "lastmod": "2018-08-11T15:26:53-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/08/use-stdmove-on-rvalue-references-stdforward-on-universal-references/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
