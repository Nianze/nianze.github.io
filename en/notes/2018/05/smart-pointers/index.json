{
  "title": "[MECpp]Item-28 Smart Pointers",
  "content": "Smart pointers are designed to look, act, and feel like built-in pointers, but to offer greater functionality.\nAdvantages of smart pointers With the help of smart pointers, we gain control over the following aspects of pointer behavior:\nConstruction and destrucrtion (default value, reference counting, etc) Copying and assignment (deep copy, not allowed to copy, etc) Dereferencing (lazy fetching, etc) Using smart pointer in client perspective Consider a distributed system in which some objects are local and some are remote. We can use smart pointer to manage the local and remote objects handling in order to offer such an illusion that all objects appear to be located in the same place.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 template\u0026lt;class T\u0026gt; // template for smart ptrs class DBPtr { // to obj. in a distributed DB public: DBPtr(T *realPtr = 0); // create a smart ptr to a DB obj given a local dumb pointer DBPtr(DataBaseID id); // create a smart ptr to a DB obj given its unique DB identifier ... // other smart ptr functions }; class Tuple { // class for database tuples public: ... void displayEditDialog(); // present a graphical dialog box allowing a user to edit the typle bool isValid() const; // return whether *this passes validity check }; // class template for making log entries whenever a T object is modified template\u0026lt;class T\u0026gt; class LogEntry { public: LogEntry(const T\u0026amp; objectToBeModified); ~LogEntry(); }; void editTuple(DBPtr\u0026lt;Tuple\u0026gt;\u0026amp; pt) { LogEnty\u0026lt;Tuple\u0026gt; entry(*pt); // make log entry for this editing operation // repeatedly display edit dialog until valid values are provided do { pt-\u0026gt;displayEditDialog(); } while (pt-\u0026gt;isValid() == false) } The tuple to ber edited inside editTuple may be physically located on a remote machine, but the programmer writing editTuple need not be converned with such matters. Wrapped by objects, all kinds of tuples are accessed through smart pointers, which act just like built-in pointers (except for how they\u0026rsquo;re declared).\nNotice the use of LogEntry object here is to take the advantage of LogEntry\u0026rsquo;s constructor and destructor to begin and end the log entry, which is more robust in the face of exceptions than explicitly calling functions (MECpp item 9).\nIn a word, clients of smart pointers are supposed to be able to treat them as dumb pointers.\nConstruction, assignment, and destruction of smart pointers Construction of a smart pointer is usually straightforward: locate an object to point to, then make the smart pointer\u0026rsquo;s internal dumb pointer point there. If no object can be located, set the internal pointer to 0 or signal an error (by throwing an exception).\nHowever, the issue of ownership makes it complicated to implement a smart pointer\u0026rsquo;s copy constructor, assignment operator(s), and destructor: depending on wheter a smart pointer owns the object it points to, should it delete the object when the smart pointer itself is destroyed?\nif we just copied the internal dumb pointer in copy constructor and call delete in destructor, we end up with two smart pointers pointing to the same object, resulting to multiple deletes, which is undefined behavior.\nif we create a new copy of what was pointed to by calling new in the copy constructor, we may have to face an unacceptable performance hit for the creation (and later destruction) of the new object. Further more, we wouldn\u0026rsquo;t know what type of object to create, because a smart pointer of type T might point to an object of a type derived from T. Virtual constructors can help solve this problem, but it seems inappropriate to require their use in a general-purpose smart pointer class.\nThe problem would vanish if we prohibit copying and assignment, but a more flexible solution was adopted by the auto_ptr template from the standard C++ library: object ownership is transferred when an auto_ptr is copied or assigned:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 template\u0026lt;class T\u0026gt; class auto_ptr { public: auto_ptr(T *ptr = 0): pointee(ptr) {} auto_ptr(auto_ptr\u0026lt;T\u0026gt;\u0026amp; rhs); // copy constructor auto_ptr\u0026lt;T\u0026gt;\u0026amp; operator=(auto_ptr\u0026lt;T\u0026gt;\u0026amp; rhs); // assignment operator ~auto_ptr\u0026lt;T\u0026gt;() { delete pointee; } private: T *pointee; }; template\u0026lt;class T\u0026gt; auto_ptr\u0026lt;T\u0026gt;::auto_ptr(auto_ptr\u0026lt;T\u0026gt;\u0026amp; rhs) { pointee = rhs.pointee; rhs.pointee = 0; } template\u0026lt;class T\u0026gt; auto_ptr\u0026lt;T\u0026gt;\u0026amp; auto_ptr\u0026lt;T\u0026gt;::operator=(auto_ptr\u0026lt;T\u0026gt;\u0026amp; rhs) { if (this == \u0026amp;rhs) return *this; delete pointee; pointee = rhs.pointee; rhs.pointee = 0; return *this; } For this design, there are three points woth noting:\n1. Pass by reference to const Because object ownership is transferred when auto_ptr\u0026rsquo;s copy constructor is called, passing auto_ptrs by value is often a very bad idea:\n1 2 3 4 5 6 7 8 9 void printTreeNode(ostream\u0026amp; s, auto_ptr\u0026lt;TreeNode\u0026gt; p) { s \u0026lt;\u0026lt; *p; } int main() { auto_ptr\u0026lt;TreeNode\u0026gt; ptn(new TreeNode); ... printTreeNode(cout, ptn); // pass auto_ptr by value } When printTreeNode\u0026rsquo;s parameter p is initialized by calling auto_ptr\u0026rsquo;s copy constructor, ownership of the object pointed to by ptn is transferred to p. After printTreeNode finishes execution, p goes out of scope and its destructor deletes what it points to, so ptn no longer points to anything (its underlying dumb pointer is null). This is rarely what we want to do.\nInstead, pass-by-reference-to-const:\n1 2 3 // this function behaves much more intuitively void printTreeNode(ostream\u0026amp; s, const auto_ptr\u0026lt;TreeNode\u0026gt;\u0026amp; p) { s \u0026lt;\u0026lt; *p; } Since this is pass by reference, no constructor is called to initialize p, and ptn retains ownership of the object it points after function execution.\n2. Unconventional copy constructor and assignment operator Normally the copy constructor and assignment operator take const parameters during the copy or the assignment. However, auto_ptr objects are modified if they are copied or are the source of an assignment, so we don\u0026rsquo;t declare const here for the copy constructor and assignment operator in auto_ptr.\n3. No ownership testing in desturctor An auto_ptr always owns what it points to, so there is no need for the ownership test in destructor. However, a smart pointers that employs reference counting (MECpp item 29) must adjust a reference count before detrmining whether it has the right to delete what it points to, so their destructor often looks like this:\n1 2 3 4 5 6 7 tempalte\u0026lt;class T\u0026gt; SmartPtr\u0026lt;T\u0026gt;::~SmartPtr() { if (*this owns *pointee) { delete pointee; } } Implementing the dereferencing operators operator* 1 2 3 4 5 6 template\u0026lt;class T\u0026gt; T\u0026amp; SmartPtr\u0026lt;T\u0026gt;::operator*() const { perform \u0026#34;smart pointer\u0026#34; processing; return *pointee;\t} A few things woth noting:\nThe \u0026ldquo;smart pointer\u0026rdquo; processing does whatever is needed to initialize or otherwise make pointee valid. For example, if lazy fetching is being used (MECpp item 17), the process may conjure up a new object for pointee to point to. The operator* returns a reference to the pointed-to object, instead of an object. This is for concerns of both correctness and efficiency. Correctness: if returning an object, this is possible for slicing problem - see MECpp item 13 - where a T object is returned instead of an actual derived class object that is expected. Efficiency: there is no need to construcrt a temporary object (MECpp 19), so returning a reference is more efficient. The result of dereferencing a null pointer is undefined, so we are free to do anything we want if operator* is invoked with a null smart pointer. (i.e., throw an exception, call abort, etc) operator-\u0026gt; When we call operator-\u0026gt; in the statement pt-\u0026gt;displayEditDialog();, the compilers treat it as:\n1 (pt.operator-\u0026gt;())-\u0026gt;displayEditDialog(); This means it must be legal to apply the member-selection operator(-\u0026gt;) to whatever operator-\u0026gt; returns, leading to only two options:\na dumb pointer to an object another smart pointer object Most of the time we want to return an ordinary dumb pointer, so the implementation for operator-\u0026gt; is:\n1 2 3 4 5 6 template\u0026lt;class T\u0026gt; T* SmartPtr::operator-\u0026gt;() const { perform \u0026#34;smart pointer\u0026#34; processing return pointee; } Note that since this function returns a pointer, virtual function calls via operator-\u0026gt; will behave the way they\u0026rsquo;re supposed to.\nTesting smart pointers for nullness So far we can not do the following operation to find out if a smart pointer is null:\n1 2 3 4 5 SmartPtr\u0026lt;TreeNode\u0026gt; ptn; ... if (ptn == 0) ... // error! if (ptn) ... // error! if (!ptn) ... // error! If we want to make smart pointer act like dumb pointers when testing for nullness, an additional isNull member function will not be ideal solution. We may be attempted to provide an implicit conversion operator: operator void*(), but this will also introduce the draback of letting function calls succeed that most programmers would expect to fail (see MECpp item 5). In particular, it allows comparisons of smart pointers of completely different types:\n1 2 3 4 SmartPtr\u0026lt;Apple\u0026gt; pa; SmartPtr\u0026lt;Orange\u0026gt; po; ... if (pa == po) ... // this compiles! This compiles because both smart pointers can be implicitly converted into void* pointers, and there is a built-in comparison function for built-in pointers. Similarly, even if we advocate conversion to const void* or bool, neither of these variations eliminates the problem of allowing mixed-type comparisons. There is simply too much conversion freedom in this wild solution.\nThere is a middle middle ground that allows us to offer a reasonable syntactic form for testing for nullness while minimizing the chances of accidentally comparing smart pointers of of different types. That is to overload operator! to return true if and only if the smart pointer on which it\u0026rsquo;s invoked is null:\n1 2 3 4 5 6 template\u0026lt;class T\u0026gt; class SmartPtr { public: ... bool operator!() const; // returns true if and only if the smart ptr is null }; This will lead to:\n1 2 3 if (!ptn) ... // fine if (ptn == 0) ... // still an error if (ptn) ... // still an error And the only risk for mixed-type comparisons is statements such as this:\n1 2 ... if (!pa == !po) ... // this still compiles Fortunately, programmers usually don\u0026rsquo;t write code like this.\nConverting smart pointers to dumb pointers When a dump pointer is expected for some lagacy libraries (say normalize(Tuple *pt);), we can not simply call the library function with a smart pointer-to-Tuple, because there is no way to convert a DBPtr\u0026lt;Tuple\u0026gt; to a Tuple*. We can make it work by doing this:\n1 normalize(\u0026amp;*pt); // gross, but legal but apparently this is not elegant.\nA dangerous solution will be to add to the smart pointer-to-T template an implicit conversion operator to a dumb pointer-to-T:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 template\u0026lt;class T\u0026gt; class DBPtr{ public:\t... operator T*() { return pointee; } ... }; DBPtr\u0026lt;Tuple\u0026gt; pt; ... normalize(pt); // this now works if (pt == 0) ... // fine, too if (pt) ... // fine, too if (!pt) ... // fine, too However, as stated in MECpp item 5, there\u0026rsquo;s dark side to such conversion function: it\u0026rsquo;s so easy for clients to get access to dumb pointers that they bypass all the smart behavior (such as reference-counting ability) our pointer-like objects designed to provide, which will almost certainly lead to disaster (such as bookkeeping errors that corrupt the reference-counting data structures):\n1 2 3 4 5 void processTuple(DBPtr\u0026lt;Tuple\u0026gt;\u0026amp; pt) { Tuple *rawTuplePtr = pt; // convert DBPtr\u0026lt;Tuple\u0026gt; to Tuple* use rawTuplePtr to modify the tuple; } Besides, even we provide such implicit conversion operator, our smart pointer will never be truly interchangeable with the dumb pointer: the conversion from a smart pointer to a dumb pointer is a user-defined conversion, and compilers are forbidden from applying more than one user-defined conversion at a time. Following example shows this difference, where conversion from DBPtr\u0026lt;Tuple\u0026gt; to TupleAccessors calls for two user-defined conversions (1. DBTpr\u0026lt;Tuple\u0026gt; -\u0026gt; Tuple*; 2. Tuple* -\u0026gt; TupleAccessors), which are prohibited by the language:\n1 2 3 4 5 6 7 8 9 10 11 12 class TupleAccessors { public: TupleAccessors(const Tuple *pt); // this ctor also acts as a type-conversion operator ... }; TupleAccessors merge(const TupleAccessors\u0026amp; ta1, const TupleAccessors\u0026amp; ta2); ... Tuple *pt1, *pt2; merge(pt1, pt2); // fine, both pointers are converted to TupleAccessors objects ... DBPtr\u0026lt;Tuple\u0026gt; smart_pt1, smart_pt2; merge(smart_pt1, smart_pt2); // error! no way to convert smart_pt1 and smart_pt2 to TupleAccessors implicitly Moreover, implicit conversion functino makes it possible to let evil statement compile, which will almost certainly break our program later1:\n1 2 3 DBPtr\u0026lt;Tuple\u0026gt; pt = new Tuple; ... delete pt; // this compiles All in all, keep in mind the bottom line: don\u0026rsquo;t provide implicit conversion operators to dumb pointers unless there is a compelling reason to do so.\nSmart pointers and inheritance-based type conversions Given the following public inheritance hierarchy:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class MusicProduct { public: MusicProduct(const string\u0026amp; title); virtual void play() const = 0; virtual void displayTitle() const = 0; }; class Cassette: public MusicProduct { public: Cassette(const string\u0026amp; title); virtual void play() const; vitual void displayTitle() const; ... }; class CD: public MusicProduct { public: CD(const string\u0026amp; title); virtual void play() const; virtual void displayTitle() const; ... }; It is expected that the virtual function will work properly with dumb pointers:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void displayAndPlay(const MusicProduct* pmp, int numTimes) { for (int i = 1; i \u0026lt;= numTimes; ++i) { pmp-\u0026gt;displayTitle(); pmp-\u0026gt;play(); } } Cassette *funMusic = new Cassette(\u0026#34;Alapalooza\u0026#34;); CD *nightmareMusic = new CD(\u0026#34;Disco Hits of the 70s\u0026#34;); displayAndPlay(funMusic, 10); displayAndPlay(nightmareMusic, 0); However, as far as compilers are converned, SmartPtr\u0026lt;CD\u0026gt;, SmartPtr\u0026lt;Cassette\u0026gt;, and SmartPtr\u0026lt;MusicProduct\u0026gt; are three seperate classes without any relationship to one another, so if we pass an object of type SmartPtr\u0026lt;CD\u0026gt; into a function with signature void displayAndPlay(const SmartPtr\u0026lt;MusicProduct\u0026gt;, int), there will be error.\nManually adding implicit conversion operator A naive solution: adding into each smart pointer class an implicit type conversion operator. Take SmartPtr\u0026lt;Cassette\u0026gt; for example:\n1 2 3 4 5 6 class SmartPtr\u0026lt;Cassette\u0026gt; { public: operator SmartPtr\u0026lt;MusicProduct\u0026gt;() { return SmartPtr\u0026lt;MusicProduct\u0026gt;(pointee); } ... }; Yet there are two drawbacks in this design:\nmanually adding the necessary implicit type conversion operators specializes the SmartPtr class instantiations, which defeats the purpose of templates too many conversion operators to add - given a deep inheritance hierarchy, we must provide a conversion operator for each base class from that object directly or indirectly inherits (again, compilers are prohibited from employing more than one user-defined type conversion function at a time.) Generating conversion operators via member templates The right way to take is to take advantage of member function templates (or just member templates):\n1 2 3 4 5 6 7 8 9 10 11 12 13 template\u0026lt;class T\u0026gt; class SmartPtr { public: SmartPtr(T* realPtr = 0); T* operator-\u0026gt;() const; T* operator*() const; template\u0026lt;class newType\u0026gt; // template function for operator SmartPtr\u0026lt;newType\u0026gt;() // implicit conversion ops. { return SmartPtr\u0026lt;newType\u0026gt;(pointee); } }; Here\u0026rsquo;s what happens:\nCompiler needs to convert a smart pointer-to-T object into a smart pointer-to-base-class-of-T Compiler checks the class definition for SmartPtr\u0026lt;T\u0026gt; to see if the requisite conversion operator is declared -\u0026gt; it is not Compiler then checks to see if there\u0026rsquo;s a member function template it can instantiate that would perform the wanted conversion -\u0026gt; it finds a template Compiler instantiates the template with newType bound to the base class of T Given this instantiated member function, compiler finds it legal to pass the dumb pointer pointee to the constructor for the smart pointer-to-base-of-T, because T-type pointee is legal to be converted into a pointer to its (public or protected) base classes The code compiles -\u0026gt; the implicit conversion from smart pointer-to-T to smart pointer-to-base-of-T succeeds Note that this implicit conversion will succeed for any legal implicit conversion between pointer types: if (and only if) a dumb pointer type T1* can be implicitly converted to another pointer type T2*, we can implicitly convert a smart pointer-to-T1 to a smart pointer-to-T2.\nHowever, there\u0026rsquo;s still a drawback: suppose following augmented MusicProduct hierarchy:\n┌──────────────┐ │ MusicProduct │ └──────────────┘ ↗ ↖ ┌──────────┐ ┌────┐ │ Cassette │ │ CD │ └──────────┘ └────┘ ↑ ┌───────────┐ │ CasSingle │ └───────────┘ 1 2 3 4 5 6 7 8 template\u0026lt;class T\u0026gt; // as above, including member tempate class SmartPtr {...}; void displayAndPlay(const SmartPtr\u0026lt;MusicProduct\u0026gt;\u0026amp; pmp, int howMany); void displayAndPaly(const SmartPtr\u0026lt;Cassette\u0026gt;\u0026amp; pc, int howMany); SamrtPtr\u0026lt;CasSingle\u0026gt; dumbMusic(new CasSingle(\u0026#34;Achy Breaky Heart\u0026#34;)); displayAndPlay(dumbMusic, 1); // error! When invoking displayAndPlay with a SmartPtr\u0026lt;CasSingle\u0026gt;, according to the inheritance hierarchy, we may expect the SmartPtr\u0026lt;Cassette\u0026gt; function to be chosen, because CasSingle inherits directly from Casssette and only indirectly from MusicProduct. However, it will only work in the case of dumb pointers. For our smart pointers, as far as C++ compilers are concerned, both calls to conversion functions here are equally good (the conversion from SmartPtr\u0026lt;CasSingle\u0026gt; to SmartPtr\u0026lt;Cassette\u0026gt; is no better than the conversion to SmartPtr\u0026lt;MusicProduct\u0026gt;), leading to an error of ambiguous call to displayAndPlay. The best we can do, then, is to use casts (MECpp item 2) in this ambiguous case.\nSmart pointers and const To mimic the flexibility of constness in terms of smart pointers, we use follwoing ways to create four combinations of const and non-const objects and pointers:\n1 2 3 4 5 CD goodCD(\u0026#34;Flood\u0026#34;); SmartPtr\u0026lt;CD\u0026gt; p; // non-const object, non-const pointer SmartPtr\u0026lt;const CD\u0026gt; p; // const object, non-const pointer const SmartPtr\u0026lt;CD\u0026gt; p = \u0026amp;goodCD; // non-const object, const pointer const SmartPtr\u0026lt;const CD\u0026gt; p = \u0026amp;goodCD; // const object, const pointer Moreover, we can use the member templates technique shown above for automatically generating the implicit type conversion operators from SmartPtr\u0026lt;CD\u0026gt; to SmartPtr\u0026lt;const CD\u0026gt; - this technique works anytime the corresponding conversion for dumb pointers would work， and conversions involving const are no exception.\nIt is possible that, after delete pt;, pt\u0026rsquo;s destructor (or some true owner of pt) will invoke delete pt; for a second time, and double deletion yields undefined behavior.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
  "summary": "Smart pointers are designed to look, act, and feel like built-in pointers, but to offer greater functionality.\n",
  "date": "2018-05-05T16:38:03-04:00",
  "lastmod": "2018-05-05T16:38:03-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/05/smart-pointers/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
