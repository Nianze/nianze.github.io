{
  "title": "[MECpp]Item-31 Making Functions Virtual With Respect to More Than One Object",
  "content": "A virtual function call is termed a \u0026ldquo;message dispatch.\u0026rdquo; A call that acts virtual on multiple parameters is called multiple dispatch, which is not directly supported in C++. Several resolutions exist, but none is without its disadvantages.\nFor example, considering we are writing a video game involving space ships, space stations, and asteroids:\n1 2 3 4 class GameObject {...}; class SpaceShip: public GameObject {...}; class SpaceStation: public GameObject {...}; class Asteroid: public GameObjecct {...}; When one GameObject collides with another, we call a function depending on both their dynamic types:\n1 2 3 4 5 6 7 8 9 void checkForCollision(GameObject\u0026amp; object1, GameObject\u0026amp; object2) { if (theyJustCollided(object1, object2)) { processCollision(object1, object2); } else { ... } } Now comes the double dispatch: since collisions betwenn different GameObject effects the environment differently, we want processCollision to act virtual on both object1 and object2, but C++ only offers virtual support for one parameter, like object1.processCollision(object2). We must come up with some approaches ourselves instead of relyin on compilers.\nUsing Virtual Function and RTTI We need double dispatch, so we can use virtual functions for first half of what we need, and use chains of if-then-elses for rest half:\n1 2 3 4 5 6 7 8 9 10 11 class GameObject { public: virtual void collide(GameObject\u0026amp; otherObject) = 0; ... }; class SpaceShip: public GameObject { public: virtual void collide(GameObject\u0026amp; otherObject); ... }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // if colliding with an object of unknown type // throw an exception of this type: class CollisionWithUnknownObject { public: CollisionWithUnknownObject(GameObject\u0026amp; whatWeHit); ... }; void SpaceShip::collide(GameObject\u0026amp; otherObject) { const type_info\u0026amp; objectType = typeid(otherObject); if (objectType == typeid(SpaceShip)) { SpaceShip\u0026amp; ss = static_cast\u0026lt;SpaceShip\u0026amp;\u0026gt;(otherObject); process a SpaceShip-SpaceShip collision; } else if (objectType == typeid(SpaceStation)) { SpaceStation\u0026amp; ss = static_cast\u0026lt;SpaceStation\u0026amp;\u0026gt;(otherObject); process a SpaceShip-SpaceStation collision; } else if (objectType == typeid(Asteroid)) { Asteroid\u0026amp; a = static_cast\u0026lt;Asteroid\u0026amp;\u0026gt;(otherObject); process a SpaceShip-Asteroid collision; } else { throw CollisionWithUnknownObject(otherObject); } } The danger in this design: each collide function must be aware of each of its sibling classes, so if a new type of object is added to the game, we must update each RTTI-based if-then-else chain in the proram that might encounter the new object, which in essence is unmaintainable in the long run. We added a final else clause where control winds up if we hit an unnknown object, throwing an exception to callers in the hope that they handle the error better than we can (but since we are running into something we didn\u0026rsquo;t know existed, they almost can\u0026rsquo;t do anything more satisfying.)\nUsing Virtual Functions Only We can also implement double-dispatching as two separate virtual function calls:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // forward declarations class SpaceShip; class SpaceStation; class Asteroid; class GameObject { public: virtual void collide(GameObject\u0026amp; otherObject) = 0; virtual void collide(SpaceShip\u0026amp; otherObject) = 0; virtual void collide(SpaceStation\u0026amp; otherObject) = 0; virtual void collide(Asteroid\u0026amp; otherObject) = 0; ... }; class SpaceShip: public GameObject { public: virtual void collide(GameObject\u0026amp; otherObject); virtual void collide(SpaceShip\u0026amp; otherObject); virtual void collide(SpaceStation\u0026amp; otherObject); virtual void collide(Asteroid\u0026amp; otherObject); ... }; 1 2 3 4 void SpaceShip::collide(GameObject\u0026amp; otherObject) { otherObject.collide(*this); } Note that this implementation is not a resursive call: being inside a member function of the class Spaceship, the static type of *this is of type SpaceShip, so the call is routed to the collide(SpaceShip\u0026amp;) instead of going back to collide(GameObject\u0026amp;). All the collide functions are virtual, so finally this call will resolve to the implementation of collide corresponding to the real type of otherObject, where both types are known. So the implementation is simply:\n1 2 3 4 5 6 7 8 9 10 11 12 void SpaceShip::collide(SpaceShip\u0026amp; otherObject) { process a SpaceShip-SpaceShip collision; } void SpaceShip::collide(SpaceStation\u0026amp; otherObject) { process a SpaceShip-SpaceStation collision; } void Spaceship::collide(SpaceStation\u0026amp; otherObject) { process a SpaceShip-Asteroid collision; } There\u0026rsquo;s no RTTI, no need to throw unexpected object types. Still, there\u0026rsquo;s the same old flaw: each class must know about its siblings. Even worth, the way in which the code must be updated in the case of adding new classes is difficult to extend: if we add a new class, say class Satellite: public GameObject, to our game, we\u0026rsquo;d have to add a new collide function to each of the existing classes in the program, rather than just another else clause in one function before.\nNow let\u0026rsquo;s do a small sum-up:\nVirtual function approach is safer than the RTTI strategy, but it constrains the extensibility of the system to match that of our ability to edit header files RTTI makes no recompilation demands, but it generally leads unmaintainable software. The best recourse is to modify the design to eliminate the need for double-dispatching. Emulating Virtual Function Tables Actually, we can build our own virtual function tables, similar to how compilers implement virtual functions by creating an array of function pointers (the vtbl) and then indexing into that array when a virtual function is called, except that this customized version support double-dispatching. Moreover, the virtual function tables is more efficient than the RTTI-based code (indexing into an array and following a function pointer vs running through a series of if-then-else tests), and we isolate the use of RTTI to a single location where the array of function pointers is initialized.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class GameObject { public: virtual void collide(GameObject\u0026amp; otherObject) = 0; ... }; class SpaceShip: public GameObject { public: virtual void collide(GameObject\u0026amp; otherObject); virtual void hitSpaceShip(GameObject\u0026amp; spaceShip); virtual void hitSpaceStation(GameObject\u0026amp; spaceStation); virtual void hitAsteroid(GameObject\u0026amp; asteroid); ... private: typedef void (SpaceShip::*HitFunctionPtr)(GameObject\u0026amp;); static HitFunctionPtr lookup(const GameObject\u0026amp; whatWeHit); typedef map\u0026lt;string, HitFunctionPtr\u0026gt; HitMap; static HitMap * initializeCollisionMap(); ... }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 SpaceShip::HitMap * SpaceShip::initializeCollisionMap() { HitMap *phm = newHitMap; (*phm)[\u0026#34;SpaceShip\u0026#34;] = \u0026amp;hitSpaceShip; (*phm)[\u0026#34;SpaceStation\u0026#34;] = \u0026amp;hitSpaceStation; (*phm)[\u0026#34;Asteroid\u0026#34;] = \u0026amp;hitAsteroid; return phm; } SpaceShip::HitFunctionPtr SpaceShip::lookup(const GameObject\u0026amp; whatWeHit) { static auto_ptr\u0026lt;HitMap\u0026gt; collisionMap(initializeCollisionMap()); HitMap::iterator mapEntry = collisionMap.find(typeid(whatWeHit).name()); if (mapEntry == collisionMap-\u0026gt;end()) return 0; return (*mapEntry).second; } void SpaceShip::collide(GameObject\u0026amp; otherObject) { HitFunctionPtr hfp = lookup(otherObject); if (hfp) { (this-\u0026gt;*htp)(otherObject); } else { throw CollisionWithUnknownObject(otherObject); } } // Each of the `dynamic_cast` will throw a `bad_cast` exception if the cast fails // they should never fail, though. void SpaceShip::hitSpaceShip(GameObject\u0026amp; spaceShip) { SpaceShip\u0026amp; otherShip = dynamic_cast\u0026lt;SpaceShip\u0026amp;\u0026gt;(spaceShip); process a SpaceShip-SpaceShip collision; } void SpaceShip::hitSpaceStation(GameObject\u0026amp; spaceStation) { SpaceStation\u0026amp; Station = dynamic_cast\u0026lt;SpaceStation\u0026amp;\u0026gt;(spaceStation) process a SpaceShip-SpaceStation collision; } void Spaceship::hitAsteroid(GameObject\u0026amp; asteroid) { Asteroid\u0026amp; theAsteroid = dynamic_cast\u0026lt;Asteroid\u0026gt;(asteroid) process a SpaceShip-Asteroid collision; } Note that there\u0026rsquo;s another design which seems doable but is actually error-prone:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class SpaceShip: public GameObject { public: virtual void collide(GameObject\u0026amp; otherObject); virtual void hitSpaceShip(SpaceShip\u0026amp; otherObject); virtual void hitSpaceStation(SpaceStation\u0026amp; otherObject); virtual void hitAsteroid(Asteroid\u0026amp; otherObject); ... }; SpaceShip::HitMap * SpaceShip::initializeCollisionMap() { HitMap *phm = newHitMap; (*phm)[\u0026#34;SpaceShip\u0026#34;] = reinterpret_cast\u0026lt;HitFunctionPtr\u0026gt;(\u0026amp;hitSpaceShip); (*phm)[\u0026#34;SpaceStation\u0026#34;] = reinterpret_cast\u0026lt;HitFunctionPtr\u0026gt;(\u0026amp;hitSpaceStation); (*phm)[\u0026#34;Asteroid\u0026#34;] = reinterpret_cast\u0026lt;HitFunctionPtr\u0026gt;(\u0026amp;hitAsteroid); return phm; } Here we tell the compiler that hitSpaceShip, hitSpaceStation, and hitAsteroid are functions expecting a GameObject argument, which is not true. hitSpaceShip expects a SpaceShip, hitSpaceStation expects a SpaceStation, and hitAsteroid expects an Asteroid. All these functions are declared as pass-by-reference, which in fact is implemented by passing a pointer to an object, so ideally compilers will pass the declared type of the parameter(say hitSpaceShip for function hitSpaceShip) in the function being called. However, due to the object layout of classes under an inheritance path, after the cast above, it is possible that the wrong address (say GameObject) is passed into the function, because inside a SpaceShip object there are both a derived class part as well as a base class part, each having a different address (for detailed discussion, refer to More Effective C++ Item 31-Initializing Emulated Virtual Function Talbes).\nUsing Non-Member Collision-Processing Functions Still, similar to pure virtual functions based approach, there is one remaining problem: because the associative array contains pointers to member functions, once a new type of GameObject is added to the game, every class definition needs to be updated and recompiled, even if that class does not care about the new type of object.\nTo solve this problem, we change the associative array so that it contains pointers to non-member functions. This update also helps us address a design question before: a collision between objects of types A and B should be handles by neither A nor B (depending on whichever is the left-hand argument to processCollision) but instead in some neutral location outside both classes.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026#34;SpaceShip.h\u0026#34; #include \u0026#34;SpaceStation.h\u0026#34; #include \u0026#34;Asteroid.h\u0026#34; namespace { // primary collision-processing functions void shipStation(GameObject\u0026amp; spaceShip, GameObject\u0026amp; spaceStation); void shipAsteroid(GameObject\u0026amp; spaceShip, GameObject\u0026amp; asteroid); void asteroidStation(GameObject\u0026amp; asteroid, GameObject\u0026amp; spaceStation); // secondary collision-processing functions that just implement symmetry void stationShip(GameObject\u0026amp; spaceStation, GameObject\u0026amp; spaceShip) { shipStation(spaceShip, spaceStation); } void asteroidShip(GameObject\u0026amp; asteroid, GameObject\u0026amp; spaceShip) { shipAsteroid(spaceShip, asteroid); } void stationAsteroid(GameObject\u0026amp; spaceStation, GameObject\u0026amp; asteroid) { asteroidStation(asteroid, spaceStation); } ... typedef void (*HitFunctionPtr)(GameObject\u0026amp;, GameObject\u0026amp;); typedef map\u0026lt; pair\u0026lt;string, string\u0026gt;, HitFunctionPtr \u0026gt; HitMap; pair\u0026lt;string, string\u0026gt; makeStringPair(const char *s1, const char *s2); HitMap * initializeCollisionMap(const string\u0026amp; class1, const string\u0026amp; class2); HitFunctionPtr lookup(const string\u0026amp; class1, const string\u0026amp; class2); } // end of unnamed namespace void processCollision(GameObject\u0026amp; object1, GameObject\u0026amp; object2) { HitFunctionPtr phf = lookup(typeid(object1).name(), typeid(object2).name()); if (phf) phf(object1, object2); else throw UnknownCollision(object1, object2); } namespace { pair\u0026lt;string, string\u0026gt; makeStringPair(const char *s1, const char *s2) { return pair\u0026lt;stirng, string\u0026gt;(s1, s2); } HitMap * initializeCollisionMap() { HitMap *phm = new HitMap; (*phm)[makeStringPair(\u0026#34;Spaceship\u0026#34;, \u0026#34;Asteroid\u0026#34;)] = \u0026amp;shipAsteroid; (*phm)[makeStringPair(\u0026#34;Spaceship\u0026#34;, \u0026#34;SpaceStation\u0026#34;)] = \u0026amp;shipStation; ... return phm; } HitFunctionPtr lookup(const string\u0026amp; class1, const string\u0026amp; class2) { static auto_ptr\u0026lt;HitMap\u0026gt; collisionMap(initializeCollisionMap()); HitMap::iterator mapEntry = collisionMap-\u0026gt;find(make_pair(class1, class2)); if (mapEntry == collisionMap-\u0026gt;end()) return 0; return (*mapEntry).second; } } // end namespace Note that makeStringPair, initializeColllisionMap, and lookup were declared inside an unnamed namespace, therefore each must also be implemented within the same namespace.\nNow we\u0026rsquo;ve solved the problem: if there are new classes to the hierarchy, it requires only the addition of more map insertions in initializeCollisionMap and the declarations of the new collision-processing functions in the unnamed namespace associated with the implementation of processCollision.\nHowever, as uaual, there\u0026rsquo;s still a disadvantage in this design: these non-member functions will not support inheritance-based parameter conversions such as how double-virtual-function-call mechanism does.\nFor example, suppose the concrete classes CommercialShip and MilitaryShip inherit from the newly abstract class SpaceShip (according to the guidance of MECpp item 33). If a MilitaryShip object and an Asteroid collided, we\u0026rsquo;d expect void shipAsteroid(GameObject\u0026amp;, GameObject\u0026amp;) to be called. However, in fact, an UnknownCollision would be thrown, because lookup would be asked to find a function corresponding to the type names MilitaryShip and Asteroid, and no such function would be found in collisionMap - after all, lookup has no way of knowing that MilitaryShip can be treated like a SpaceShip.\nModifying Emulated Virtual Function Talbes Dynamically If we\u0026rsquo;d like to add, remove, or change collision-processing functions as the game proceeds, the static collisionMap will not meet this requirement. In this case, we can turn the concept of a static map into a class that offers member functions allowing us to modify the contents of the map dynamically:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class CollisionMap { public: typedef void (*HitFunctionPtr)(GameObject\u0026amp;, GameObject\u0026amp;); void addEntry(const string\u0026amp; type1, const String\u0026amp; type2, HitFunctionPtr collisionFunction, bool symmetric = true); void removeEntry(const string\u0026amp; type1, const string\u0026amp; type2); HitFunctionPtr lookup(const string\u0026amp; type1, const string\u0026amp; type2) // return a reference to the one and only map static CollisionMap\u0026amp; theCollisionMap(); private: // private to prevent the creation of multiple maps CollisionMap(); CollisionMap(const CollisionMap\u0026amp;); }; Clients wishing to add an entry to the map simply do the following step:\n1 2 void shipAsteroid(GameObject\u0026amp; spaceShip, GameObject\u0026amp; asteroid); CollisionMap::theCollisionMap().addEntry(\u0026#34;SpaceShip\u0026#34;, \u0026#34;Asteroid\u0026#34;, \u0026amp;shipAsteroid); We must take care to ensure that these map entries are added to the map before any collisions occurs. One way is to have constructors in GameObject subclasses check to make sure the appropriate mappings had been added each time an object was created, but then we have to pay a small performance penalty at runtime. An alternative would be to create a RegisterCollisionFunction class:\n1 2 3 4 5 6 7 8 9 10 class RegisterCollisionFunction { public: RegisterCollisionFunction(const string\u0026amp; type1, const string\u0026amp; type2, CollisionMap::HitFunctionPtr collisionFunction, bool symmetric = true) { CollisionMap::theCollisionMap().addEntry(type1, type2, collisionFunction, symmetric); } }; Clients then use global objects of this type to automatically register the functions before main is invoked to insure the map is initialized properly before any collision occurs:\n1 2 3 4 5 6 7 8 RegisterCollisionFunction cf1(\u0026#34;SpaceShip\u0026#34;, \u0026#34;Asteroid\u0026#34;, \u0026amp;shipAsteroid); RegisterCollisionFunction cf2(\u0026#34;SpaceShip\u0026#34;, \u0026#39;SpaceStation\u0026#39;, \u0026amp;shipStation); ... int main(int argc, char * argv[]) { ... } If, later, a new derived class Satellite: public GameObject {...}; is added, and one or more new collision-processing functions are written (say, void satelliteShip(GameObject\u0026amp;, GameObject\u0026amp;), and void satelliteAsteroid(GameObject\u0026amp;,GameObject\u0026amp;), etc), we can simply add them to the map without disturbing existing code:\n1 2 RegisterCollisionFunction cf4(\u0026#34;Satellite\u0026#34;, \u0026#34;SpaceShip\u0026#34;, \u0026amp;satelliteShip); RegisterCollisionFunction cf5(\u0026#34;Satellite\u0026#34;, \u0026#34;Asteroid\u0026#34;, \u0026amp;satelliteAsteroid); Overall, this makes it easy to provide data for a map-based implementation, but it doesn\u0026rsquo;t change the fact that there\u0026rsquo;s no perfect way to implement multiple dispatch.\n",
  "summary": "A virtual function call is termed a \u0026ldquo;message dispatch.\u0026rdquo; A call that acts virtual on multiple parameters is called multiple dispatch, which is not directly supported in C++. Several resolutions exist, but none is without its disadvantages.\n",
  "date": "2018-05-11T00:00:00Z",
  "lastmod": "2018-05-11T00:00:00Z",
  "permalink": "https://nianze.github.io/en/notes/2018/05/making-functions-virtual-with-respect-to-more-than-one-object/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
