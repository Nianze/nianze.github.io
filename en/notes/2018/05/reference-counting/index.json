{
  "title": "[MECpp]Item-29 Reference Counting",
  "content": "Reference counting is technique that allows multiple objects with the same value to share a sinple representation of that value.\nConsider a customized naive version of class String;: its assignment operator is implemented in a naive way:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class String { public: String(const char *value = \u0026#34;\u0026#34;); String\u0026amp; operator=(const String\u0026amp; rhs); ... private: char *data; }; String\u0026amp; String::operator=(const String\u0026amp; rhs) { if (this == \u0026amp;rhs) return *this; delete[] data; data = new char[strlen(rhs.data)+1]; strcpy(data, rhs.data); return *this; } When we write statement a = b = c = d = e = \u0026quot;Hello\u0026quot;; where a, b, c, d and e are all String type, we get five objects, each with the same value \u0026ldquo;Hello\u0026rdquo;:\n┌───┐ ┌───────┐ ┌───┐ ┌───────┐ │ a │ --\u0026gt; │ Hello │ │ b │ --\u0026gt; │ Hello │ └───┘ └───────┘ └───┘ └───────┘ ┌───┐ ┌───────┐ ┌───┐ ┌───────┐ │ c │ --\u0026gt; │ Hello │ │ d │ --\u0026gt; │ Hello │ └───┘ └───────┘ └───┘ └───────┘ ┌───┐ ┌───────┐ │ e │ --\u0026gt; │ Hello │ └───┘ └───────┘ Ideally, we\u0026rsquo;d like to change the picture to look like this:\n┌───┐ │ a ├──┐ └───┘ | ┌───┐ | │ c ├──┤ └───┘ | ┌───┐ | ┌───────┐ │ e ├──┼─\u0026gt;│ Hello │ └───┘ | └───────┘ ┌───┐ | │ e ├──┤ └───┘ │ ┌───┐ │ │ e ├──┘ └───┘ In practice, we need to keep track of how many objects are sharing - refering to- a value to make sure the best time to destroy or modify the value \u0026ldquo;Hello\u0026rdquo;, so we need to add reference count into the picuture:\n┌───┐ │ a ├──┐ └───┘ | ┌───┐ | │ c ├──┤ └───┘ | ┌───┐ | ┌───┐ ┌───────┐ │ c ├──┼─\u0026gt;│ 5 ├───\u0026gt;│ Hello │ └───┘ | └───┘ └───────┘ ┌───┐ | │ d ├──┤ └───┘ │ ┌───┐ │ │ e ├──┘ └───┘ Implementing Reference Counting From the picture above, we can see we need one reference count per string value, instead of one per string object. This implies a decoupling between values and reference counts, leading to our first design: nesting a StringValue struct in the private part of String class, so that all the members of String class get full access to this inner data structure, while everybody else get denied (except friends of the class).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class String { public: ... private: struct StringValue { // holds a reference count and a string value size_t refCount; char *data; StringValue(const char *initValue); ~StringValue(); } StringValue *value; // value of this String }; String::StringValue::StringValue(const char *initValue) : refCount(1) { data = new char[strlen(initValue)+1]; strcpy(data, initValue); } String::StringValue::~StringValue() { delete [] data; } The primary purpose of StringValue is to provide a place to associate a particular value with a count of the number of String objects sharing that value, so there\u0026rsquo;s need to define copy constructor or assignment operator for this inner struct, and we provide the manipulation of the refCount field in String class:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class String { public: String(const char *initValue = \u0026#34;\u0026#34;); String(const String\u0026amp; rhs); ~String(); String\u0026amp; operator=(const String\u0026amp; rhs); ... }; String::String(const char *initValue) : value(new StringValue(initValue)) {} String::String(const String\u0026amp; rhs) : value(rhs.value) { ++value-\u0026gt;refCount; } String::~String() { if (--value-\u0026gt;refCount == 0) delete value; } String\u0026amp; String::operator=(const String\u0026amp; rhs) { if (value == rhs.value) { return *this; } if (--value-\u0026gt;refCount == 0) { // destroy *this\u0026#39;s value delete value; // if no one else is using it } value = rhs.value; ++value-\u0026gt;refCount; return *this; } Copy-on-write Now comes the troublesome one: an array-bracket operator([]), which allows individual characters within strings to be read and written:\n1 2 3 4 5 6 class String { public: const char\u0026amp; operator[](int index) const; // for const Strings char\u0026amp; operator[](int index); // for non-const Strings ... }; It\u0026rsquo;s straightforward to implement the const version, because it\u0026rsquo;s a read-only operation:\n1 2 3 4 const char\u0026amp; String::operator[](int index) const { return value-\u0026gt;data[index]; // here\u0026#39;s no sanity checking on index, just like C++ tradition; easy to add though } However, since non-const version of operator[] might be called to write a character, the implementation must consider more scenario to avoid modifying the value of other String objects that happen to be sharing the same StringValue object - since there\u0026rsquo;s no way for C++ compilers to tell us whether a particular use of operator[] is for a read or a write, we must be pessimistic and assume all calls to the non-const operator[] are for writes (Proxy classes casn help us differentiate reads from writes, see MECpp item 30.)\n1 2 3 4 5 6 7 8 9 10 char\u0026amp; String::operator[](int index) { // if sharing a value with other String obj. // break off a separate copy of the value if (value-\u0026gt;refCount \u0026gt; 1) { --value-\u0026gt;refCount; value = new StringValue(value-\u0026gt;data); } return value-\u0026gt;data[index]; } This technique - to share a value with other objects until we have to write on our own copy of the value - is the well-knwon copy-on-write, which is a specific example of lazy evaluation (MECpp item 17), which is a more general approach to efficiency.\nPointers, References, and Copy-on-write Consider this code:\n1 2 3 String s1 = \u0026#34;Hello\u0026#34;; char *p = \u0026amp;s1[1]; Stirng s2 = s1; The data structure looks like this:\n┌───┐ │s1 ├──┐ ┌───┐ ┌───────┐ └───┘ ├─\u0026gt;│ 2 ├───\u0026gt;│ Hello │ ┌───┐ │ └───┘ └───────┘ │s2 ├──┘ ↑ └───┘ p Now there is a dangerous situation, where pointer p modifies both s1 and s2:\n1 *p = \u0026#39;x\u0026#39;; // modifies both s1 and s2 To eliminate the problem, we add a flag to each StringValue object indicating whether that object is shareable. Initially, the flag is set to true (indicating shareable), but turn it off whenever the non-const operator[] is invoked on the value represented by that object (once the flag is set to false, it stays that way forever).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class String { public: struct StirngValue { size_t refCount; bool shareable; // add this line char *data; ... }; ... }; String::StringValue::StringValue(const char *initValue) : refCount(1), shareable(true) // add this line { data = new char[strlen(initValue) + 1]; strcpy(data, initValue); } String::String(const String\u0026amp; rhs) { if (rhs.value-\u0026gt;shareable) { // add this checking value = rhs.value; ++value-\u0026gt;refCount; } else { value = new StringValue(rhs.value-\u0026gt;data); } } char\u0026amp; String::operator[](int index) { if (value-\u0026gt;refCount \u0026gt; 1) { --value-\u0026gt;refCount; value = new StringValue(value-\u0026gt;data); } value-\u0026gt;shareable = false; // add this return value-\u0026gt;data[index]; } A Reference-Counting Base class Reference counting is useful for more than just strings, so it\u0026rsquo;s good practice to separate reference counting code in a context-independent manner. This leads us to the design of a base class RCObject. Any class wishing to take advantage of automatic reference counting may inherit from this class. Basically, for general purpose usage, RCObject class should include\nthe reference count, as well as functions for incrementing and decrementing that count. the code for destroying a value when it is no longer in use (count == 0) a field that keeps track of whether this value is shareable, as well as functions to query this flag and set it to false 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class RCObject { public: RCObject(); RCObject(const RCObject\u0026amp; rhs); RCObject\u0026amp; operator=(const RCObject\u0026amp; rhs); virtual ~RCObject() = 0; // virtual shows this class is designed as a base class; pure virtual so that this class should be used only as a base class void addReference(); void removeReference(); void markUnshareable(); bool isShareable() const; bool isShared() const; private: size_t refCount; bool shareable; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 RCObject::RCObject() : refCount(0), shareable(true) {} RCObject::RCObject(const RCObject\u0026amp;) : refCount(0), shareable(true) {} RCObject\u0026amp; RCObject::operator=(const RCObject\u0026amp;) { return *this; } RCObject::~RCObject() {} // pure virtual dtor still need to be impl. see MECpp item 33 void RCObject::addReference() { ++refCount; } void RCObject::removeReference() { if(--refCount == 0) delete this; } void RCObject::markUnshareable() { shareable = false; } bool RCObject::isShareable() const { return shareable; } bool RCObject::isShared() const { return refCount \u0026gt; 1; } In this design, there are a few things worth noting:\nThe refCount is set to 0 in both constructors to simplifies the set up process for the creaters of RCObjects when they set refCount to 1 themselves Copy constructor sets refCount to 0, because this function is meant to create a new object representing a value, which is always unshared and referenced only by their creator (who will set up refCount properly later). The assignment operator is unlikely to be called, since RCObject is a base class for a shared value object, which means in a reference counting system, it is usually the object pointing to these base-class objects that are assigned to one another, with only refCount being modified as a result. We don\u0026rsquo;t declare assignment operator private, because there\u0026rsquo;s a chance that someone does have a reason to allow assignment of reference-counted values(e.g., change the string value stored inside StringValue in the example above), so we adopt this \u0026ldquo;do nothing\u0026rdquo; implementation, which is exactly the right thing to do, because the assignment of value objects doesn\u0026rsquo;t affect the reference count of objects pointing to either lhs or rhs of assignment operation: this base-class level assignment is meant to change lhs\u0026rsquo;s value, meaning all the objects pointing to lhs now pointing to a new value. Here we use delete this; for removeReference, which is safe only if we know that *this is a heap object. In order to ensure this, we might need technichs discussed in MECpp item 27 to restrict RCObject to be created only on the heap1. Now taking advantage of this new reference-counting base class, we modify StringValue to inherit its reference counting capabilities from RCObject:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class String { private: struct StringValue: public RCObject { char *data; StringValue(const char *initValue); ~StringValue(); }; ... }; String::StringValue::StringValue(const char *initValue) { data = new char[strlen(initValue) + 1]; strcpy(data, initValue); } String::StringValue::~StringValue() { delete [] data; } After this change, RCObject now provide the manipulation ability of the refCount field, instead of StringValue.\nAutomating Reference Count Manipulations The RCObject class only gives us a place to store a reference count, as well as the member functions to manipulate the refCount field. However, the calls to these functions must still be mannually inserted in other classes: String copy constructor and assignment operator need to call addReference and removeReference on StringValue objects, which is not good practice for reuse.\nTo remove such manual works, we introduce smart pointer for help:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // template class for smart pointers-to-T object. T must // support the RCObject interface, typically by inheriting from RCObject template\u0026lt;class T\u0026gt; class RCPtr { public: RCPtr(T* realPtr = 0); RCPtr(const RCPtr\u0026amp; rhs); ~RCPtr(); RCPtr\u0026amp; operator=(const RCPtr\u0026amp; rhs); T* operator-\u0026gt;() const; T\u0026amp; operator*() const; private: T *pointee; // dumb pointer this object is emulating void init(); // common init. code }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 template\u0026lt;class T\u0026gt; RCPtr\u0026lt;T\u0026gt;::RCPtr(T* realPtr): pointee(realPtr) { init(); } template\u0026lt;class T\u0026gt; RCPtr\u0026lt;T\u0026gt;::RCPtr(const RCPtr\u0026amp; rhs): pointee(rhs.pointee) { init(); } template\u0026lt;class T\u0026gt; void RCPtr\u0026lt;T\u0026gt;::init() { if (pointee == 0) { return; } if (pointee-\u0026gt;isShareable() == false) { pointee = new T(*pointee); } pointee-\u0026gt;addReference(); // always add a new reference to the value } template\u0026lt;class T\u0026gt; RCPtr\u0026lt;T\u0026gt;\u0026amp; RCPtr\u0026lt;T\u0026gt;::operator=(const RCPtr\u0026amp; rhs) { if (pointee != rhs.pointee) T *oldPointee = pointee; pointee = rhs.pointee; init(); // if possible, share it; else make own copy if (oldPointee) { oldPointee-\u0026gt;removeReference(); } } return *this; } template\u0026lt;class T\u0026gt; RCPtr\u0026lt;T\u0026gt;::~RCPtr() { if (pointee) pointee-\u0026gt;removeReference(); } template\u0026lt;class T\u0026gt; T* RCPtr::operator-\u0026gt;() const { return pointee; } template\u0026lt;class T\u0026gt; T\u0026amp; RCPtr::operator*() const { return *pointee; } There are three assumptions in this implementation:\nT has a deep-copying constructor, because pointee = new T(*pointee); will call T\u0026rsquo;s copy constructor. In the example above, String::StringValue lack such a user-defined copy constructor, and compiler generated default copy constructor will not copy char* string data points to, so we need to add a customized version of copy constructor: 1 2 3 4 5 String::StringValue::StirngValue(const StringValue\u0026amp; rhs) { data = new char(strlen(rhs.data) + 1); strcpy(data, rhs.data); } For the same statement calling T\u0026rsquo;s copy constructor, we assume the type of *pointee is T rather than T\u0026rsquo;s derived class. If, however, chances are poinee might point to T\u0026rsquo;s derived class instances, we need to use a virtual copy constructor. T should prove all the functionality that RCObject does, either or not by inheriting from RCObject. Puting Everyting Together ┌──────────┐ ┌──────────┐ │ RCObject │ │ String │ │ class │ │ object │ └──────────┘ │ │ ↑ public inheritance │ ┌─────┐ │ ┌───────────┐ ┌────────────┐ │ │RCPtr├──┼────────\u0026gt;│StringValue├────────\u0026gt;| Heap Memory| │ └─────┘ │ pointer │ object | pointer └────────────┘ └──────────┘ └───────────┘ The class declaration looks like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 template\u0026lt;class T\u0026gt; class RCPtr { public: RCPtr(T* realPtr = 0); RCPtr(const RCPtr\u0026amp; rhs); RCPtr\u0026amp; operator=(const RCPtr\u0026amp; rhs); ~RCPtr(); T* operator-\u0026gt;() const; T\u0026amp; operator*() const; private: T *pointee; void init(); }; class RCObject { public: RCObjet(); RCObject(const RCObject\u0026amp; rhs); RCObject\u0026amp; operator=(const RCOBject\u0026amp; rhs); virtual ~RCObject() = 0; void addReference(); void removeReference(); void markUnshareable(); bool isShareable() const; bool isShared() const; private: size_t refCount; bool shareable; }; class String { public: String(const char *value = \u0026#34;\u0026#34;); const char\u0026amp; operator[](int index) const; char\u0026amp; operator[](int index); private: // class representing string value struct StringValue: public RCObject { char *data; StringValue(const char *initValue); StringValue(const StringValue\u0026amp; rhs); void init(const char *initValue); ~StringValue(); }; RCPtr\u0026lt;StringValue\u0026gt; value; It is worth to note that we don\u0026rsquo;t need the copy constructor or assignment operator for String anymore: compiler-generated copy constructor for Stirng will automatically call the copy constructor for Stirng\u0026rsquo;s RCPtr member, and the copy constructor for that class will perform all the necessary manipulations of the StringValue object, including its reference count, and the same goes for assignment and destruction. That\u0026rsquo;s why it is called smart pointer.\nNow here is all the implementation:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 RCObject::RCObject() : refCount(0), shareable(true) {} RCObject::RCObject(const RCObject\u0026amp;) : refCount(0), shareable(true) {} RCObject\u0026amp; RCObject::operator=(const RCObject\u0026amp;) { return *this; } RCObject::~RCObject() {} void RCObject::addReference() { ++refCount; } void RCObject::removeReference() { if (--refCount == 0) delete this; } void RCObject::markUnshareable() { shareable = false; } bool RCObject::isShareable() const { return shareable; } bool RCObject::isShared() const { return refCount \u0026gt; 1; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 template\u0026lt;class T\u0026gt; void RCPtr\u0026lt;T\u0026gt;::init() { if (pointee == 0) { return; } if (pointee-\u0026gt;isShareable() == false) { pointee = new T(*pointee); } pointee-\u0026gt;addReference(); } template\u0026lt;class T\u0026gt; RCPtr\u0026lt;T\u0026gt;::RCPtr(T* realPtr): pointee(realPtr) { init(); } template\u0026lt;class T\u0026gt; RCPtr\u0026lt;T\u0026gt;::RCPtr(const RCPtr\u0026amp; rhs): pointee(rhs.pointee) { init(); } template\u0026lt;class T\u0026gt; RCPtr\u0026lt;T\u0026gt;\u0026amp; RCPtr\u0026lt;T\u0026gt;::operator=(const RCPtr\u0026amp; rhs) { if (pointee != rhs.pointee) T *oldPointee = pointee; pointee = rhs.pointee; init(); // if possible, share it; else make own copy if (oldPointee) { oldPointee-\u0026gt;removeReference(); } } return *this; } template\u0026lt;class T\u0026gt; RCPtr\u0026lt;T\u0026gt;::~RCPtr() { if (pointee) pointee-\u0026gt;removeReference(); } template\u0026lt;class T\u0026gt; T* RCPtr::operator-\u0026gt;() const { return pointee; } template\u0026lt;class T\u0026gt; T\u0026amp; RCPtr::operator*() const { return *pointee; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void String::StringValue::init(const char *initValue) // ctor and deep copy ctor share this same init function { data = new char[strlen(initValue) + 1]; strcpy(data, initValue); } String::StringValue::StringValue(const char *initValue) { init(initValue); } String::StringValue::StringValue(const StringValue\u0026amp; rhs) { init(rhs.data); } String::StringValue::~StringValue() { delete [] data; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 String::String(const char *initValue) : value(new StringValue(initValue)) {} const char\u0026amp; String::operator[](int index) const { return value-\u0026gt;data[index]; } char\u0026amp; String::operator[](int index) { if (value-\u0026gt;isShared()) { value = new StirngValue(value-\u0026gt;data); } value-\u0026gt;markUnshareable(); return value-\u0026gt;data[index]; } Adding Refenrence Counting to Existing Classes Given some class Widget that\u0026rsquo;s in a library we can\u0026rsquo;t modify, and suppose we want to apply the benefits of reference counting to Widget without being able to inherit Widget from RCObject, we solve the problem with an additional level of indirection by adding a new class CountHolder, which does three jobs:\nHold the reference Inherit from RCObject Contain a pointer to a Widget The only thing left to do is just an equivalent smart pointer as RCPtr, and we call it RCIPtr, where \u0026ldquo;I\u0026rdquo; stands for \u0026ldquo;indirect\u0026rdquo;. Thus, we get someting like this:\n┌──────────┐ ┌──────────┐ │ RCObject │ │ RCWidget │ │ class │ │ object │ └──────────┘ │ ┌──────┐ │ ↑ public inheritance │ |RCIPtr| │ ┌───────────┐ ┌─────────────┐ │ |Object├─┼────────\u0026gt;│CountHolder├────────\u0026gt;|Widget Object| │ └──────┘ │ pointer │ object | pointer └─────────────┘ └──────────┘ └───────────┘ Since here CountHolder is just an implementation detial of RCIPtr, we can simply nested it inside RCIPtr, just as how StringValue relates with String.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 template\u0026lt;class T\u0026gt; class RCIPtr { public: RCIPtr(T* realPtr = 0); RCIPtr(const RCIPtr\u0026amp; rhs); ~RCIPtr(); RCIPtr\u0026amp; operator=(const RCIPtr\u0026amp; rhs); T* operator-\u0026gt;() const; T\u0026amp; operator*() const; RCObject\u0026amp; getRCObject(); // give clients access { return *counter; } // isShared, etc. private: struct CountHolder: public RCObject { ~CountHolder() { delete pointee; } T *pointee; }; CountHolder *counter; void init(); }; template\u0026lt;class T\u0026gt; void RCIPtr\u0026lt;T\u0026gt;::init() { if (counter-\u0026gt;iShareable() == false) { T *oldValue = counter-\u0026gt;pointee; counter = new CountHolder; counter-\u0026gt;pointee = oldValue ? new T(*oldValue) : 0; } counter-\u0026gt;addReference(); } template\u0026lt;class T\u0026gt; RCIPtr\u0026lt;T\u0026gt;::RCIPtr(T* realPtr) : counter(new CountHolder) { counter-\u0026gt;ponitee = realPtr; init(); } template\u0026lt;class T\u0026gt; RCIPtr\u0026lt;T\u0026gt;::RCIPtr(const RCIPtr\u0026amp; rhs) : counter(rhs.counter) { init(); } template\u0026lt;class T\u0026gt; RCIPtr\u0026lt;T\u0026gt;::~RCIPtr() { counter-\u0026gt;removeReference(); } template\u0026lt;class T\u0026gt; RCIPtr\u0026lt;T\u0026gt;\u0026amp; RCIPtr\u0026lt;T\u0026gt;::operator=(const RCIPtr\u0026amp; rhs) { if (counter != rhs.counter) { counter-\u0026gt;removeReference(); counter = rhs.counter; init(); } return *this; } template\u0026lt;class T\u0026gt; T* RCIPtr\u0026lt;T\u0026gt;::operator-\u0026gt;() const { return counter-\u0026gt;pointee; } template\u0026lt;class T\u0026gt; T\u0026amp; RCIPtr\u0026lt;T\u0026gt;::operator*() const { return *(counter-\u0026gt;pointee); } Then, for a library class Widget with following interface:\n1 2 3 4 5 6 7 8 9 10 11 class Widget { public: Widget(int size); Widget(const Widget\u0026amp; rhs); ~Widget(); Widge\u0026amp; operator=(const Widget\u0026amp; rhs); void doThis(); int showThat() const; }; We can implementing wrapper RCWidget by simply forwarding the call through underlying RCIPtr to a Widgetobject:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class RCWidget { public: RCWidget(int size): value(new Widget(size)) {} void doThis() { if (value.getRCObject().isShared()) { value = new Widget(*value); } value-\u0026gt;doThis(); } int showThat() const { return value-\u0026gt;showThat(); } private: RCIPtr\u0026lt;Widget\u0026gt; value; }; As with Stirng class, there\u0026rsquo;s no need to write copy constructor, assignment operator, or destructor, because the default versions do the right thing.\nIn this example, we guarantee the value objects should be created only via new by declaring StringValue as private in String, so only String can create StringValue objects and the auther of the String class is able to ensure all such objects are allocated via new.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
  "summary": "Reference counting is technique that allows multiple objects with the same value to share a sinple representation of that value.\n",
  "date": "2018-05-07T00:00:00Z",
  "lastmod": "2018-05-07T00:00:00Z",
  "permalink": "https://nianze.github.io/en/notes/2018/05/reference-counting/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
