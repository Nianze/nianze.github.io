{
  "title": "[MECpp]Item-33 Make Non-Leaf Classes Abstract",
  "content": "The general rule: non-leaf classes should be abstract. This will yields dividends in the form of increased reliability, robustness, comprehensibility, and extensibility throughout our software.\nRedesign concrete base classes to abstract ones If we have two concrete classes C1 and C2 and we\u0026rsquo;d like C2 to publicly inherit from C1, we should transform that two-class hierarchy into a three-class hierarchy by creating a new class A and having both C1 and C2 publicly inherit from it:\ninitial idea | the transformed hierarchy ┌─────────┐ | ┌─────┐ │ C1 │ | │ A │ └─────────┘ | └─────┘ ↑ | public inheritance ↗ ↖ public inheritance ┌─────────┐ | ┌────┐ ┌────┐ │ C1 │ | │ C1 │ │ C2 │ └─────────┘ | └────┘ └────┘ For example, we create a software dealing with animals, with two kinds of animals - lizards and chickens - require special handling:\n┌──────────┐ │ Animal │ └──────────┘ public inheritance ↗ ↖ public inheritance ┌────────┐ ┌─────────┐ │ Lizard │ │ Chicken │ └────────┘ └─────────┘ The Animal class embodies the features shared by all the creatures, and the Lizerd and Chicken classes specialize Animal in their own ways:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Animal { public: Animal\u0026amp; operator=(const Animal\u0026amp; rhs); ... }; class Lizard: public Animal { public: Lizard\u0026amp; operator=(const Lizard\u0026amp; rhs); ... }; class Chicken: public Animal { public: Chicken\u0026amp; operator=(const Chicken\u0026amp; rhs); ... }; Now consider what happens for assignment operation:\n1 2 3 4 5 6 Lizard liz1; Lizard liz2; Animal *pAni1 = \u0026amp;liz1; Animal *pAni2 = \u0026amp;liz2; ... *pAni1 = *pAni2; The two problems here:\npartial assignment: only Animal members in liz1 get updated from liz2, while the liz1\u0026rsquo;s Lizard members remain unchanged. it\u0026rsquo;s not uncommon for programmers to make assignments to objects via pointers. Solution 1: virtual functions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Animal { public: virtual Animal\u0026amp; operator=(const Animal\u0026amp; rhs); ... }; class Lizard: public Animal { public: virtual Lizard\u0026amp; operator=(const Animal\u0026amp; rhs); ... }; class Chicken: public Animal { public: virtual Chicken\u0026amp; operator=(const Animal\u0026amp; rhs); ... }; We can customize the return value of the virtual assignment operators here, but the rules of C++ force us to declare identical parameter types for a virtual function in every class in which it is declared, leading to the problem that the assignment operator for the Lizard and Chicken must be prepared to accept any kind of Animal object on the right-hand side of an assignment:\n1 2 3 4 5 6 7 8 9 Lizard liz; Chicken chick; Animal *pAni1 = \u0026amp;liz; Animal *pAni2 = \u0026amp;chick; ... *pAni1 = *pAni2; // assign a chicken to a lizard! By making Animal\u0026rsquo;s assignment operator virtual, we opened the door to such mixed-type operations. To only allow the same type assignment in virtual assignment operation, we have to make distinctions the types at runtime:\n1 2 3 4 5 6 Lizard\u0026amp; Lizard::operator=(const Animal\u0026amp; rhs) { // make sure rhs is really a lizard const Lizard\u0026amp; rhs_liz = dynamic_cast\u0026lt;const Lizard\u0026amp;\u0026gt;(rhs); ... // proceed with a normal assignment of rhs_liz to *this } In this case, we have to worry about std::bad_cast exceptions thrown by dynamic_cast when rhs is not a Lizard, while paying for extra runtime check cost for valid assignment cases, as well as the harder to maintain code.\nSolution 2: adding another function If we don\u0026rsquo;t want to pay for the complexity or cost of a dynamic_cast in the case of valid assignment, we add to Lizard the conventional assignment operator:\n1 2 3 4 5 6 7 8 9 10 11 class Lizard: public Animal { public: virtual Lizard\u0026amp; operator=(const Animal\u0026amp; rhs); Lizard\u0026amp; operator=(const Lizard\u0026amp; rhs); // add this ... }; Lizard\u0026amp; Lizard::operator=(const Animal\u0026amp; rhs) { return operator=(dynamic_cast\u0026lt;const Lizard\u0026amp;\u0026gt;(rhs)); } 1 2 3 4 5 6 7 8 Lizard liz1, liz2; ... liz1 = liz2; // calls operator= taking a const Lizard\u0026amp; Animal *pAni1 = \u0026amp;liz1; Animal *pAni2 = \u0026amp;liz2; ... *pAni1 = *pAni2; // calls operator= taking a const Animal\u0026amp; Still, clients of Lizard and Chicken have to be prepared to catch bad_cast exceptions and do something sensible with them each time they perform an assignment, which most programmers are unwilling to do.\nSolution 3: making partial assignment illegal The easiest way to prevent partial assignments is to make Animal::operator= private so that *pAni1 = *pAni2; is illegal (which calls private Animal::operator=), but this naive solution has 2 problems:\nAnimal is a concrete class. A private operator= makes also it illegal to make assignments between Animal objects: animal1 = animal2;\nAssignment operator in derived classes are responsible for calling assignment operators in their base classes, but a private Animal::operator= makes it impossible to implement the Lizard::operator= and Chicken::operator= correctly to assign the Animal part of *this:\n1 2 3 4 5 6 Lizard\u0026amp; Lizard::operator=(const Lizard\u0026amp; rhs) { if (this == \u0026amp;rhs) return *this; Animal::operator=(rhs); // can\u0026#39;t call private Animal::operator= ... } Declaring Animal::operator= as protected will solve the latter problem, but the first one still remains.\nSolution 4: redesign the inheritance hierarchy Because our orignimal design for the system presupposed that Animal objects were necessary, we can not abstract Animal class. Instead, we create a new class - AbstractAnimal that consists of the common features of Animal, Lizard, and Chicken, and we make that class abstract by making its destructor a pure virtual function1:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class AbstractAnimal { protected: AbstractAnimal\u0026amp; operator=(const AbstractAnimal\u0026amp; rhs); public: virtual ~AbstractAnimal() = 0; // still need to impl. the destructor even it\u0026#39;s a pure virtual function ... }; class Animal: public AbstractAnimal { public: Animal\u0026amp; operator=(const Animal\u0026amp; rhs); ... }; class Lizard: public AbstractAnimal { public: Lizard\u0026amp; operator=(const Lizard\u0026amp; rhs); ... }; class Chicken: public AbstractAnimal { public: Chicken\u0026amp; operator=(const Chicken\u0026amp; rhs); }; This design gives us everything:\nhomogeneous assignments ar allowed for lizards, chickens, and animals; partial assignments and heterogeneous assignments are prohibited derived class assignment operators may call the assignment operator in the base class non of the code written in terms of the Animal, Lizard, or Chicken requires modification - they behave as they did before AbstractAnimal was introduced - though the code does need to be recompiled In reality when facing constraints If we want wot create a concrete class that inherits from a concrete class in a thirt-party libraries to which we have only read access, what are we to do?\nThen there are only unappealing options:\nDerive the concrete class from the existing concrete class, and put up with the assignment-related problems, and watch out for the array-related pitfalls (MECpp item 3).\nTry to find an abstract class higher in the library hierarchy that does most of what we need, then inherit from that class.\nImplement the new class in terms of the library class we\u0026rsquo;d like to inherit from: having an object of the library class as a data member, then reimplement the library class\u0026rsquo;s interface in the new class - this requires to update the class each time the library vendor updates our dependent library classes, and we also give up the ability to redefine virtual functions declared in the library class (we can\u0026rsquo;t redefine virtual functions unless we inherit them):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Window { public: virtual void resize(int newWidth, int newHeight); virtual void repaint() const; int width() const; int height() const; }; class SpecialWindow { // class we wanted to have inherit from Window public: ... int width() const { return w.width(); } // pass through nonvirtual functions int height() const { return w.height(); } virtual void resize(int newWidth, int newHeight); // new impl. of \u0026#34;inherited\u0026#34; virtual functions virtual void repaint() const; private: Window w; }; Use the concrete class that\u0026rsquo;s in the library and modify the software so that the class suffices. Write non-member functions to proved the extra functionality we\u0026rsquo;d like to add to the class, but can\u0026rsquo;t - the result may not be as clear, as efficient, as maintainable, or as extensible as we\u0026rsquo;d like.\nDeclaring a function pure virtual doesn\u0026rsquo;t mean it has no implementation, it means: 1. the current class is abstract, and 2 any concrete class inheriting from the current class must declare the function as a \u0026ldquo;normal\u0026rdquo; virtual function (i.e., without the \u0026ldquo;=0\u0026rdquo;).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
  "summary": "The general rule: non-leaf classes should be abstract. This will yields dividends in the form of increased reliability, robustness, comprehensibility, and extensibility throughout our software.\n",
  "date": "2018-05-21T18:27:39-04:00",
  "lastmod": "2018-05-21T18:27:39-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/05/make-non-leaf-classes-abstract/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
