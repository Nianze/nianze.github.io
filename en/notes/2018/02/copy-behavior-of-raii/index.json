{
  "title": "Item-14 Copy behavior in resource-managing classes",
  "content": "Copying an RAII object entails copying the resource it manages, so the copying behavior of the resource determines the copying behavior of the RAII object.\nWe can use auto_ptr and tr1::shared_ptr to manage heap-based resources, as introduced in item 13. However, not all resources are heap-based, and for such resources, we need to create our own resource-managing classes to deal with a general question:\nwhat should happen when an RAII object is copied?\nMostly, there are 4 possibal choices:\n1. Prohibit copying In some cases, it makes no sense to allow RAII objects to be copied, so we should prohibit it. As explained in item 6, we declare the copying operations private without definition. A good example is class Mutex, which is synchronization primitives and comes with two functions lock and unlock:\n1 2 3 void lock(Mutex *pm); // lock mutex pointed to by pm void unlock(Mutex *pm); // unlock the mutex We should not forget to unlock a Mutex we\u0026rsquo;ve locked, and it rarely makes sense to have \u0026ldquo;copies\u0026rdquo; of synchronization privitives, so we can create an uncopyable class to manage the locks:\n1 2 3 4 5 6 7 8 9 10 11 class Lock: private Uncopyable { // prohibit copying, see item 6 public: explicit Lock(Mutex *pm) : mutexPtr(pm) { lock(mutexPtr); } // acquire resource ~Lock() { unlock(mutexPtr); } // release resource private: Mutex *mutexPtr; }; And we can use Lock in the conventional RAII fashion:\n1 2 3 4 5 6 7 8 9 10 11 12 Mutex m; // define the mutex ... { // create block to define critical section Lock ml(\u0026amp;m); // lock the mutex ... // perform critical section operations // Lock ml2(ml); this is prohibited behavior! } // automatically unlock mutex at end of block 2. Reference-count the underlying resource Sometimes it\u0026rsquo;s desirable to hold on to a resource until the last object using it has been destroyed. We could implement reference-counting copying behavior by containing a tr1::shared_ptr data member, but in some cases we may have to customize the behavior when the reference count goes to zero, for the default behavior is to call delete.\nThe way we customize tr1::shared_ptr is to specify a \u0026ldquo;deleter\u0026rdquo; - a function or function object to be called when the reference count goes to zero (auto_ptr does not give us this privilege), which is an optional second parameter to the tr1::shared_ptr constructor:\n1 2 3 4 5 6 7 8 9 10 11 class Lock { public: explicit Lock(Mutex *pm); // init shared_ptr with the Mutex : mutexPtr(pm, unlock) // to point to and the unlock func as the deleter { lock(mutexPtr.get()); // see item 15 for info on \u0026#34;get\u0026#34; } private: std::tr1::shared_ptr\u0026lt;Mutex\u0026gt; mutexPtr; // use shared_ptr instead of raw pointer }; Since a class\u0026rsquo;s destructor (both user-defined ones and compilter-generated ones) automatically invokes the destructors of the class\u0026rsquo;s non-static data members, there\u0026rsquo;s no need to declare a destructor for class Lock explicitly (item 5). We simply rely on the default compilter-generated behavior, and that\u0026rsquo;s enough.\n3. Copy the underlying resource Sometimes we want to copy the resource-managing object as well as the resource it wraps, - that is to say, we want the resourse-managing object to perform a \u0026ldquo;deep copy\u0026rdquo;. A good example is the standard string type: in sompe implementation, a string type object consists of a pointer to heap memory, where the charactors making up the string are stored, and a copy is made of both the pointer and the memory it points to when such an object get copied.\n4. Transfer owenership of the underlying resource On rere occasions, we wish only one RAII object refers to a raw resource and the ownership of the resource is transfered from the copied object to the copying object, as is the meaning of \u0026ldquo;copy\u0026rdquo; used by auto_ptr.\nIn this situation, we may have to write our own version of copying functions (copy constructor and copy assignment operator), since the default compiler-generated ones may not do what we want. In some cases, we\u0026rsquo;ll also want to support generalized versions of copying functions, which is discussed in item 45.\n",
  "summary": "Copying an RAII object entails copying the resource it manages, so the copying behavior of the resource determines the copying behavior of the RAII object.\n",
  "date": "2018-02-02T13:27:32-05:00",
  "lastmod": "2018-02-02T13:27:32-05:00",
  "permalink": "https://nianze.github.io/en/notes/2018/02/copy-behavior-of-raii/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
