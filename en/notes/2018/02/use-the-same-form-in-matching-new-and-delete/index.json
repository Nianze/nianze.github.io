{
  "title": "Item-16 Use the same form in corresponding uses of new and delete",
  "content": "If you use [] in a new expression, use [] in the corresponding delete expression; If not, no [] in the matching delete expression.\nWhen employing a new expression, two things happen:\nmembory is allocated (via the function operator new, item 49, 51) one or more constructors are called for that memory When a delete is used, two other things happen:\none or more destructors are called for the memory The memory is deallocated (via the function operator delete, item 51) The fact is that the memory layout for single objects is generally different from the memory layout for arrays, and the memory for an array usually includes extra area for the size of the array (making it easier for delete to know how many destructor to call) while memory for a single object lacks this information:\nMemory type Memory layout Array |n|Object|Object|Object|\u0026hellip;| Single object |Object| When we use delete on a pointer, delete [] will assumes an array is pointed to, otherwise it assumes a single object. Let\u0026rsquo;s see what will happen if the uses of new and delete is not matching:\n1 2 std::string *stringPtr1 = new std::string; std::string *stringPtr2 = new std::string[100]; delete [] stringPtr1;\nThe result is undefined. delete will read some memory and interpret what it read as an array size, then start invoking the destructors, and it\u0026rsquo;s probably not holding the objects of the type it\u0026rsquo;s busy destructing at this point.\ndelete stringPtr2;\nIt\u0026rsquo;s undefined behavior too. It\u0026rsquo;s easy to see the expression would lead to too few destructors being called. Furthermore, it\u0026rsquo;s also undefined for built-in types (which lack destructors), too.\nThe rule is particularly important to bear in mind when writing a class containing a pointer to dynamically allocated memory and also offering multiple constructors, for we must be careful to use the same form of new in all the constructors to initialize the pointer member. After all, there\u0026rsquo;s only one form of delete in the destructor.\nThe rule is also noteworthy for typedef-inclined:\n1 2 3 4 5 typedef std::string AddressLines[4]; // a person\u0026#39;s address has 4 lines std::string *pal = new AddressLines; // return type is string*, just like \u0026#34;new string[4]\u0026#34; would delete pal; // undefined! delete [] pal; // fine, array form of delete is the matched version To avoid such confusion, abstain from typedefs for array types. Try using string and vector from the standard C++ library (item 54) - those templates reduce the need for dynamically allocated arrays to nearly zero: for example, we may define AddressLines as type vector\u0026lt;string\u0026gt;.\n",
  "summary": "If you use [] in a new expression, use [] in the corresponding delete expression; If not, no [] in the matching delete expression.\n",
  "date": "2018-02-04T00:00:00Z",
  "lastmod": "2018-02-04T00:00:00Z",
  "permalink": "https://nianze.github.io/en/notes/2018/02/use-the-same-form-in-matching-new-and-delete/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
