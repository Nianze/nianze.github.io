{
  "title": "Item-25 Consider support for a non-throwing swap",
  "content": "When std::swap would be inefficient for your type,provide a non-throwing swap member function, a non-member swap calling the member, and possibly a specialized std::swap for the case of classes (not templates).\nswap, since its introduction into STL, is useful for exception-safe programming (item 29) and a common mechanism for coping with the possibility of assignment to self (item 11). Due to its importance, it should be implemented properly, which is exactly what this item explores about.\nCustomization By default, swapping is accomplished via the standard swap algorithm:\n1 2 3 4 5 6 7 8 9 namesapce std { template\u0026lt;typename T\u0026gt; // typical implementation of std::swap void swap(T\u0026amp; a, T\u0026amp; b) // swaps a\u0026#39;s and b\u0026#39;s values { T temp(a); a = b; b = temp; } } As long as our types support copying (via copy constructor and copy assignment operator), the default swap implementation will work. However, for some types, none of these copies are really necessary. For example: there\u0026rsquo;s a common design manifestation called \u0026ldquo;pimpl idiom\u0026rdquo; (\u0026ldquo;pointer to implementation\u0026rdquo;, item 31) that consisting primarily of a pointer to another type that contains the real data:\n1 2 3 4 5 6 7 8 class WidgetImpl { // class for Widget data public: ... private: int a, b, c; std::vector\u0026lt;double\u0026gt; v; // possibly lots of data: ... // expensive to copy }; 1 2 3 4 5 6 7 8 9 10 11 12 13 class Widget { // class using the pimpl idiom public: Widget(const Widgtet\u0026amp; rhs); Widget\u0026amp; operator=(const Widget\u0026amp; rhs) //to copy a Widget, { // copy its WidgetImpl object. ... // for details on operator=, see item 10, 11, 12 *pImpl = *(rhs.pImpl); ... } ... private: WidgetImpl *pImpl; // ptr to object with real data }; To swap the value of two Widget objects, all we need to do is swap their pImpl pointers instead of copying three Widgets as well as three underlying WidgetImpl objects. In order to let default swap know this information, we need to specialize std::swap for Widget:\nnamespace std {\ntemplate\u0026lt;\u0026gt; // a specialized version of std::swap\nvoid swap(Widget\u0026amp; a, Widget\u0026amp; b) // for when T is Widget\n{\nswap(a.pImpl, b.pImpl); // won\u0026rsquo;t compile here\n}\n}\nThe template\u0026lt;\u0026gt; at the begining says that this is a total template specialization for std::swap, and the \u0026lt;Widget\u0026gt; after the name of the function says that the specialization is for when T is Widget, so compilter knows that when the general swap template is applied to Widgets, this is the implementation to use - although we are not allowed to alter the contents of the std namespace, it is totally fine to specialize standard templates (like swap) for our own types (such as Widget).\nHowever, this implementation won\u0026rsquo;t compile, because we can\u0026rsquo;t access the private pImpl pointers inside a and b. To solve the problem, we declare a public member function called swap that does the actual swapping, then specialize std::swap to call the member function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Widget { // same as above except for the addition of the swap mem func public: ... void swap(Widget\u0026amp; other) { using std::swap; // use the std::swap swap(pImple, other.pImpl); // to swap Widgets, swap their pImpl pointers } ... }; namespace std { template\u0026lt;\u0026gt; // revised version of std::swap void swap\u0026lt;Widget\u0026gt;(Widget\u0026amp; a, Widget\u0026amp; b) { a.swap(b); // to swap Wiidgets, call their swap mem func } } This implementation will compile and be consistent with the STL container. However, if the Widget and WidgetImpl were class template instead of classes (so that we could parameterize the type of the data stored in WidgetImpl), things get more complicated:\n1 2 3 4 5 template\u0026lt;typename T\u0026gt; class WidgetImpl {...}; template\u0026lt;typename T\u0026gt; class Widget {...}; It is still easy to put a swap member function inside Widget the same way as before, but there\u0026rsquo;s a trouble with the specialization for std::swap:\n1 2 3 4 5 6 7 namespace std { template\u0026lt;typename T\u0026gt; void swap\u0026lt;Widget\u0026lt;T\u0026gt;\u0026gt;(Widget\u0026lt;T\u0026gt;\u0026amp; a, Widget\u0026lt;T\u0026gt;\u0026amp; b) // illegal code! { a.swap(b); } } Apparently we\u0026rsquo;re partially specializing a function template std::swap here, and the problem is that, although C++ allows partial specialization of class templates, it doesn\u0026rsquo;t allow it for function templates (though some compilers may erroneously accept it).\nThe usual approach to \u0026ldquo;partially specialize\u0026rdquo; a function template is to add an overload like this:\n1 2 3 4 5 6 7 namespace std { template\u0026lt;typename T\u0026gt; // an overloading of std::swap void swap(Widget\u0026lt;T\u0026gt;\u0026amp; a, Widget\u0026lt;T\u0026gt;\u0026amp; b) // note the lack of \u0026#34;\u0026lt;...\u0026gt;\u0026#34; { // after \u0026#34;swap\u0026#34; a.swap(b); } } However, rather than overloading a common function template, what we do here is overloading a function template std::swap in the special std namesapce, where it\u0026rsquo;s not allowed to add new templates or classes or functions or anything else into it (the contens of std are determined solely by the C++ standardization committee). Even though programs that cross the line will almost certainly compile and run, their behavior is undefined.\nThus in this case, not to declare the non-member function to be a specialization or overloading of std::swap, we just make a normal non-member swap function in Widget-related namespace:\n1 2 3 4 5 6 7 8 9 10 11 namespace WidgetStuff { ... // templatized WidgetImpl, etc. template\u0026lt;typename T\u0026gt; class Widget {...}; // including the swap member function ... template\u0026lt;typename T\u0026gt; // non-member swap function void swap(Widget\u0026lt;T\u0026gt;\u0026amp; a, Widget\u0026lt;T\u0026gt;\u0026amp; b) // not part of the std namespace { a.swap(b); } } The name lookup rules in C++ (specifically the rules known as argument-dependent lookup or Koenig lookup) will guarantee the Widget-specific version of swap in WidgetStuff will be invoked if any code calls swap on two Widget objects.\nUsage Let\u0026rsquo;s look from a client\u0026rsquo;s point of view and see how to use the swap. Ideally, we want to call a T-specific version of swap if there is one, but to fall back on the general version in std if there\u0026rsquo;s not. To fulfill this idea:\n1 2 3 4 5 6 7 8 template\u0026lt;typename T\u0026gt; void doSomething(T\u0026amp; obj1, T\u0026amp; obj2) { using std::swap; // make std::swap available in this function ... swap(obj1, obj2); // call the best swap for obejcts of type T ... } When compilers see the call to swap, they search for the best swap to invoke - according to C++\u0026rsquo;s name lookup rules, it follows the order below:\nFind any T-specific swap at global scope or in the same namespace as the type T (if T is Widget in the namespace WidgetStuff, compilers will find swap in WidgetStuff defined above) If no T-specific swap exists, compilers will use swap in std, thanks to the using declaration that makes std::swap visible in this function. If there\u0026rsquo;s a T-specific specialization of std::swap, use the specialized version If not, use the general swap template function. One thing worth noting is to not qualify the call like this:\n1 std::swap(obj1, obj2); // the wrong way to call swap here we force compilers to consider only the swap in std (including any template specializations), thus eliminating the possibility of getting a more appropriate T-specific version defined elsewhere. Alas, some misguided programmers (or even some standard library) do qualify calls to swap in this way. To make code work as efficiently as possible, we\u0026rsquo;d better totally specialize std::swap for our classes.\nSummary We\u0026rsquo;ve discussed the default swap, member swaps, non-member swaps, specializations of std::swap, and calls to swap. Below is a good practice on implementing and using customized swap:\nIf the default implementation of swap offers acceptable efficiency for our class or class template, nothing needs to be done to specialize the default std::swap. If not (for class or template using some variation of the pimpl idiom): offer a public swap member function that efficiently swaps the value of two objects of our type. This function should never throw an exception1 offer a non-member swap in the same namespace as the class or template2. Have it call the swap member function if it\u0026rsquo;s a class (not a class template), specialize std::swap for the class. Have it also call the swap member function One of most useful applications of swap is to help classes and class templates offer the strong exception-safety guarantee (See 29 for details). Generally speaking, efficiency and non-exception are two swap characteristics that always go hand in hand, because highly efficient swaps are almost always based on operations on built-in types (such as the pointers underlying the pimpl idiom), and operations on built-in types never throw exceptions.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThe non-exception constraint can\u0026rsquo;t apply to the non-member version, because the default version of swap is based on copy construction and copy assignment, and generally both copy functions are allowed to throw exceptions.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
  "summary": "When std::swap would be inefficient for your type,provide a non-throwing swap member function, a non-member swap calling the member, and possibly a specialized std::swap for the case of classes (not templates).\n",
  "date": "2018-02-13T19:11:15-05:00",
  "lastmod": "2018-02-13T19:11:15-05:00",
  "permalink": "https://nianze.github.io/en/notes/2018/02/support-for-a-non-throwing-swap/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
