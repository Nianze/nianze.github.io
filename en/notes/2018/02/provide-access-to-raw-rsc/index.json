{
  "title": "Item-15 Provide access to raw resource in resource-managing classes",
  "content": "Each RAII class should offer a way to get at the resource it manages.\nFrom time to time, some APIs require access to raw resources, so it is a good habit to design the resource-managing classes in such a way that it provides access to raw resources. For example, suppose there\u0026rsquo;s a function we\u0026rsquo;d like to use with Investment objects, which is managed by smart pointer:\n1 2 3 int daysHeld(const Investment *pi); // return number of days investment has been held std::tr1::shared_ptr\u0026lt;Investment\u0026gt; pInv(createInvestment()); // item 13 Since dayHeld wants a raw Investment* pointer, if passing an object of type tr1::shared_ptr\u0026lt;Investment\u0026gt;, the code won\u0026rsquo;t compile:\n1 ind days = daysHeld(pInv); // error We need to find a way to get the access to the raw resources, and generally there are two ways:\nImplicit conversion (convenient for clients) Explicit conversion (generally preferred) Implicit conversion Pointer dereferencing operators (operator-\u0026gt; and operator*) are implicit conversion to the underlying raw pointers, which is virtually provided by all smart pointer classes. Suppose there\u0026rsquo;s a member function bool isTaxFree() inside the class Investment, and we can access the member function like this:\n1 2 3 bool taxable1 = !(pInv-\u0026gt;isTaxFree()); // access resource via operator-\u0026gt; bool taxable2 = !((*pInv).isTaxFree()); // access resource via operator* When it is necessary to get at the raw resource inside an RAII object, another way of conversion is through an implicit conversion function. Consider following RAII class for fonts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 FontHandle getFont(); // from C API void releaseFont(FontHandle fh); // from the same C API class Font { // self-defined RAII class public: explicit Font(FontHanlde fh) // acquire resource : f(fh) // use pass-by-value because the C API does {} ~Font() { releaseFont(f); } // release resource operator FontHandle() const {return f;} // implicit conversion function private: FontHandle f; // the raw font resource }; This makes calling into the following C API easy and natural:\n1 2 3 4 5 6 void changeFontSize(FontHandle f, int newSize); // the C API Font f(getFont()); int newFontSize; ... changeFontSize(f, newFontSize); // implicitly convert Font to FontHandle However, the downsize is that implicit conversions increase the chance of errors - a FontHandle may be created when a Font is really intended:\n1 2 3 4 Font f1(getFont()); ... FontHandle f2 = f1; // meant to copy a Font object but implicitly converted f1 into // FontHandle, and copied the underlying resource Explicit conversion In order to avoid unintended implicit conversion, an explicit conversion function like get is a preferable path. We can exchange the implicit convertion function to following explicit one:\n1 2 3 4 5 6 7 8 class Font { ... FontHandle get() const { return f; } // explicit conversion function ... }; ... // and use it like this: changeFontSize(f.get(), newFontSize); // explicitly convert Font to FontHandle Both explicit conversion and implicit conversion make sense, and the preference depends on the specific task and the circumstances in which the RAII class performs, as long as one adheres to item 18\u0026rsquo;s advice: to make interfaces easy to use correctly and hard to use incorrectly.\n",
  "summary": "Each RAII class should offer a way to get at the resource it manages.\n",
  "date": "2018-02-03T00:00:00Z",
  "lastmod": "2018-02-03T00:00:00Z",
  "permalink": "https://nianze.github.io/en/notes/2018/02/provide-access-to-raw-rsc/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
