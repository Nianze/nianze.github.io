{
  "title": "Item-20 Perfer pass-by-reference-to-const to pass-by-value",
  "content": "Pass by reference-to-const is typically more efficient than pass by value and avoids the slicing problem.\nPass-by-value can be an expensive operation. For example, consider the following class hierarchy:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Person { public: Person(); // parameters omitted for simplisity virtual ~Person(); // item 7 explains why virtual ... private: std::string name; std::string address; }; class Student:public Person { public: Student(); // parameters omitted for simplisity ~Student(); ... private: std::string schoolName; std::string schoolAddress; }; Now consider what will happen if we call a function validateStudent, which takes a Student argument (by value) and returns whether it is a real student:\n1 2 3 bool validateStudent(Student s); // pass a Student object by value Student plato; bool platoIsOK = validateStudent(plato); // call the function A Student object has two string object within it, while its base class Person contains two additional string type data members. So the parameter-passing cost of this function is one call to the Student copy constructor matched with two string copy constructor, and one call to the base class Person\u0026rsquo;s copy constructor, which also entails two more string construction. When the Student object is destroyed, each constructor call is matched by a destructor call. Overall, the cost of passing a Student by value is six constructors and six destructors.\nIt would be nice is there were a way to bypass all those constructions and destructions. The answer is: pass by reference-to-const:\n1 bool validateStudent(const Student\u0026amp; s); Since no new objects are being created, there\u0026rsquo;s no constructor or destructor call. The const in the revised parameter declaration is important, for it guarantees that the callers would not worry about validateStudent making changes to the Student they passed in (when passing by value, validateStudent would be able to modify only a copy of the Student they passed in, so the callers know they are shielded from any changes the function might make to the Student).\nApart from efficiency, passing parameters by reference also avoids the slicing problem: when a derived class object is passed (by value) as a base class object, the base class copy constructor is called, and the extra features in derived class object are \u0026ldquo;sliced\u0026rdquo; off. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 class Window { public: ... std::string name() const; // return name of window virtual void display() const; // draw window and contents }; class windowWiScroBars: public Window { public: ... virtual void display() const; }; Below is a bad example if you want to write a function to print out a window\u0026rsquo;s name and then display the window:\n1 2 3 4 5 void printNameAndDisplay(Window w) { std::cout \u0026lt;\u0026lt; w.name(); w.displey(); } When you call this functiona with a WindowWithScrollBars object:\n1 2 WindowWithScrollBars wwsb; printNameAndDisplay(wwsb); Since it is passed by value, the parameter w will be constructed as a Window object. Regardless of the type of object passed to the function, inside printNameAndDisplay, w will act like an object of class Window (it is an object of class Window after all), and all the specialized information that made wwsb act like a WindowWithScrollBars object will be sliced off.\nHowever, if we revised the function declaration like this:\n1 2 3 4 5 void printNameAndDisplay(const Window\u0026amp; w) // fine, parameter won\u0026#39;t be sliced { std::cout \u0026lt;\u0026lt; w.name(); w.display(); } Now w will act like whatever kind of window is actually passed in.\nException In general, the only types for which we can reasonably assume that pass-by-value is inexpensive are:\nbuilt-in types STL iterator function object types Under the hood of the C++ compiler, a reference is implemented as pointers, so passing by reference usually means passing a pointer. This is why for built-in types (e.g., an int), it\u0026rsquo;s more efficient to pass it by value than by reference. Also, iterators and function objects in the STL are more efficient to copy and are not subject to the slicing problem because they are designed to be passed by value (this is an example where rules change depending on which part of C++ we are using, see item 0).\nOn the other hand, we can not conclude that all small types are necessarily good pass-by-value candidate:\nthe user-defined types, despite being small in terms of size, may have expensive copy constructors, such as most STL containers that contain little more than a pointer but leading to copying everything they point to when applying copying operation.\neven if the copy constructors are inexpensive, compilers may treat user-defined small types differently with buiilt-in types: for example, some compilters refuse to put objects consisting of only a double into a register, even though they will happily place naked doubles there, so we can be better off passing such objects by reference, for compilers will certainly put pointers (the implementation of references) into registers.\na type that is small now may be bigger in a future release, for its internal implementation may change; things can even change when we switch to a different C++ implementation, for example, some implementations of the standard library\u0026rsquo;s string type are seven times as big as others.\nIn summary, for everything else other than built-in types and STL iterator and function object types, follow the advice and prefer pass-by-reference-to-const over pass-by-value.\n",
  "summary": "Pass by reference-to-const is typically more efficient than pass by value and avoids the slicing problem.\n",
  "date": "2018-02-08T16:26:33-05:00",
  "lastmod": "2018-02-08T16:26:33-05:00",
  "permalink": "https://nianze.github.io/en/notes/2018/02/perfer-pass-by-reference-to-const/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
