{
  "title": "Item-23 Prefer non-member non-friend function to member function",
  "content": "Prefer non-member non-friend functions to member functions for better encapsulation, packaging flexibility, and functional extensibility.\nSuppose there\u0026rsquo;s a class representing web browsers containing following three functions:\n1 2 3 4 5 6 7 8 class WebBrowser { public: ... void clearCache(); void clearHistory(); void removeCookies(); ... }; Clients may want to perform these three actions together, so WebBrowser might offer two ways to achieve the goal:\nAdd a member function 1 2 3 4 5 6 class WebBrowser { public: ... void clearEverything(); // calls clearCache(), clearHistory(), and removeCookies() ... }; Add a non-member non-friend function 1 2 3 4 5 6 void clearBrowser(WebBrowser\u0026amp; wb) { wb.clearCache(); wb.clearHistory(); wb.removeCookies(); } As the title suggests, the non-member approach is better, and below is the reasons:\nEncapsulation If something is encapsulated, it\u0026rsquo;s hidden from view. The more something is encapsulated, the fewer things can see it, the fewer impact clients get affected by potential change, and the greater flexibility we have to change the inmplementation.\nAs a coarse-grained measure of how much code can see a piese of data, we can count the number of functions that can access that data: the more functions that can access it, the less encapsulated the data.\nAccording to item 22, data members should all be private, so the number of functions that can access them is the number of member functions of the class plus the number of friend functions. Thus, given a member function clearEverything() (which can access not only the private data of a class, but also private functions, enums, typedefs, etc) and a non-member non-friend function clearBrower(), the latter yields greater encapsulation.\nTwo more things worth noting are:\nFriend functions have the same access to a class\u0026rsquo;s private members, hence the same impact on encapsulation. So from an encapsulation point of view, the choice is between member functions and non-member non-friend functions. (BTW, under the view point of implicit type conversion, item 24, the choice is between member and non-member functions) A function being a non-member of one class can still be a member of another class. For example, clearBrowser() could be declared as a static member function in some utility class. As long as it is not part of (or a friend of) WebBrowser, it doens\u0026rsquo;t affect the encapsulation of WebBrowser\u0026rsquo;s private members. Packaging flexibility In C++, rather than declared in a class, a more natural approach would be to make clearBrowser() a non-member function in the same namespace as WebBrowser:\n1 2 3 4 5 namespace WebBrowserStuff { class WebBrowser {...}; void clearBrowser {...}; ... } Unlike classes, namespace can be spread across multiple source file. For convenience functions like \u0026lsquo;clearBrowser\u0026rsquo;, this is important, because clients will generally be interested in only some of the convenience functions, and there\u0026rsquo;s no reason for them to compile all of the functions including those they don\u0026rsquo;t need. A straight forward way to separate convenience functions by their functionalities is to declare them in different header files:\n1 2 3 4 5 6 // header \u0026#34;webbrowser.h\u0026#34; - header for class WebBrowser itself // as well as \u0026#34;core\u0026#34; WebBrowser-related functionality namespace WebBrowserStuff { class WebBrowser {...}; ... // \u0026#34;core\u0026#34; related functionality, e.g.: non-member functions almost all clients need } 1 2 3 4 // header \u0026#34;webbrowserbookmarks.h\u0026#34; namespace WebBrowserStuff { ... // bookmark-related convenience functions } 1 2 3 4 // header \u0026#34;webbrowsercookies.h\u0026#34; namespace WebBrowserStuff { ... // cookie-related convenience functions } This is exactly how the standard C++ library is organized: there are dozens of headers (e.g.: \u0026lt;vector\u0026gt;, \u0026lt;algorithm\u0026gt;, \u0026lt;memory\u0026gt;, etc.), each declaring some of the functionality in std. This allows clients to be compilation dependent only on the parts of the system they actually use (item 31 shows other ways to reduce compilation dependencies).\nOn the other side, partitioning is not possible for member functions, because a class must be defined in its entirety.\nExtensibility Putting all convenience functions in multiple header files but one namespace also means that clients can easily extend the set of convenience functions. All they have to do is add more non-member non-friend functions to the namespace, which is another feature classes can\u0026rsquo;t offer, because class definitions are closed to extension by clients. Even though clients can derive new classes, the derived classes have no access to private members in the base class, so such \u0026ldquo;extended functionality\u0026rdquo; has second-class status. Besides, as item 7 explains, not all classes are designed to be base classes.\n",
  "summary": "Prefer non-member non-friend functions to member functions for better encapsulation, packaging flexibility, and functional extensibility.\n",
  "date": "2018-02-11T21:33:28-05:00",
  "lastmod": "2018-02-11T21:33:28-05:00",
  "permalink": "https://nianze.github.io/en/notes/2018/02/prefer-non-member-non-friend-function-to-member-function/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
