{
  "title": "Item-24 Declare non-member functions when type conversions should apply to all parameters",
  "content": "If we need type conversions on all parameters to a function including the one pointed to by the this pointer, the function must be a non-member.\nHaving classes support implicit type conversions is generally a bad idea. One good and common exception to the rule is when creating numerical types, for example, we want to allow implicit conversions from integers to user-defined rationals type:\n1 2 3 4 5 6 7 8 9 class Rational { public: Rational(int numerator = 0, // ctor is deliberately not explicit, int denominator = 1); // allowing implicit int-to-Rational conversion int numerator() const; // accessor for numerator int denominator() const; // accessor for denominator, see item 22 private: ... }; We\u0026rsquo;d like to support arithmetic operation of multiplication, and one way is to declare it as a member function of Rational:\n1 2 3 4 5 class Rational { public: ... const Rational operator*(const Rational\u0026amp; rhs) const; // return const: item 3; taking a reference-to-const as argument: item 20, 21 }; This design is fine to multiply rationals with rationals:\n1 2 3 4 5 Rational oneEighth(1, 8); Rational oneHalf(1, 2); Rational result = oneHalf * oneEighth; // fine result = result * oneEighth; // fine However, for mixed-mode operations, where Rationals is multiplied with ints, there will be a potential error:\n1 2 result = oneHalf * 2; // fine result = 2 * oneHalf; // error! This problem is clearer for analysis when we rewrite the last two examples in their equivalent functional form:\n1 2 result = oneHalf.operator*(2); // fine result = 2.operator*(oneHalf); // error! For the first statement:\nthe object oneHalf is an instance of a class that contains an operator* taking a Rational as its argument. Compilers know we\u0026rsquo;re passing an int and that the function requires a Rational, and they also know they can conjure up a suitable Rational by implicit type conversion - calling the Rational constructor with the int we provided, so compilers will happily call that function as if it had been written like this:\n1 2 const Rational temp(2); // create a temporary Rational object from 2 result = oneHalf * temp; // same as oneHalf.operator*(temp); Of course, compilers are allowed to do this implicit type conversion only because a non-explicit constructor is involved. If we add keyword explicit before the constructor above, neither of the two mixed-type multiplication statements would compile.\nNow for the second statement:\nit turns out that parameters are eligible for implicit type conversion only if they are listed in the parameter list. The implicit parameter pointed to by this, which is also the obejct on which the member function is invoked, is never eligible for implicit conversions. Back to the second statement, int type 2 does not have associated class containing a function operator* taking a Rational type object as its argument, nor is 2 listed in the parameter list for an implicit type conversion to Rational. That is the cause of compilation failure.\nIn fact, when compilers fail to find a matching member function, they will also look for non-member operator*s (i.e., ones at namespace or global scope) that can be called like this:\n1 result = operator*(2, oneHalf); And this is exactly what we want if we\u0026rsquo;d like to support mixed-mode arithmetic: make opeartor* a non-member function, thus allowing compilers to perform implicit type conversions on all arguments:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Rational { ... // contains no operator* }; const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) // now a non-member function { return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); } Rational oneForth(1, 4); Rational result; result = oneForth * 2; // fine result = 2 * oneForth; // it works now Now comes anoter worry: should operator* be made a friend of the Rational class?\nIn this case, the answer is no, because operator* can be implemented entirely through Rational\u0026rsquo;s public interface. This leads to an important observation:\nThe opposite of a member function is a non-member function, not a frient function.\nThere\u0026rsquo;s some misunderstanding that if a function is related to a class and should not be a member (due, for example, to type conversions on all arguments), it should be a friend. This reasoning turns out to be flawed. The basic rule is to avoid friend functions whenever we can.\nP.S.: This item contains the truth, but it is not the whole truth. When we cross the line from Object-Oriented C++ into Template C++ (item 1), and make Rational a class template instead of a class, refer to item 46 for some new issues to consider, new ways to solve them, and new design implications.\n",
  "summary": "If we need type conversions on all parameters to a function including the one pointed to by the this pointer, the function must be a non-member.\n",
  "date": "2018-02-12T22:47:20-05:00",
  "lastmod": "2018-02-12T22:47:20-05:00",
  "permalink": "https://nianze.github.io/en/notes/2018/02/when-to-declare-non-member-functions/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
