{
  "title": "Item-26 Postpone variable definitions as long as possible",
  "content": "Postponing variable definitions as long as possible increases program clarity and improves progranm efficiency.\nAfter defining a variable of a type with a constructor or destructor, there\u0026rsquo;s a cost of construction when control reaches a variable\u0026rsquo;s definition, and a cost of destruction when the variable goes out of scope. If the variable is unused, the cost is wasted, which is the case we want to avoid.\nNobody declares unused variables on purpose, but chances are we may still encounter them unexpectedly: suppose there\u0026rsquo;s a function that returns an encrypted version of a password as long as the password is long enough and may throw an exception of type logic_error (defined in standard C++ library, item 54) if the passwod is too short:\n1 2 3 4 5 6 7 8 9 10 std::string encryptPassword(const std::string\u0026amp; password) { using namespace std; string encrypted; // definition is too soon if (password.length() \u0026lt; MinimumPasswordLength) { throw logic_error(\u0026#34;Password is too short\u0026#34;); } ... // do whatever is necessary to place an encrypted version of password in encrypted return encrypted; } Apparently, the object encrypted is unused if an exception is thrown, and we still have to pay the cost of construction and destruction of encrypted.\nA better solution is to postpone encrypted\u0026rsquo;s definition until we know we\u0026rsquo;ll need it:\n1 2 3 4 5 6 7 8 9 10 11 12 std::string encryptPassword(const std::string\u0026amp; password) { using namespace std; if (password.length() \u0026lt; MinimumPasswordLength) { throw logic_error(\u0026#34;Password is too short\u0026#34;); } string encrypted; // postpones encrypted\u0026#39;s definition until it\u0026#39;s truly necessary ... // do whatever is necessary to place an encrypted version of password in encrypted return encrypted; } This code still isn\u0026rsquo;t as tight as it might be, because encrypted is defined without any initialization arguments, leading to its default constructor getting called and an extra aassignment operation being used later. As item 4 suggests,\ndefault-constructing an object and then assigning to it is less efficient than initializing it with the value we really want it to have.\nSuppose the hard part of encryptPassword is performed in this function:\n1 void encrypt(std::string\u0026amp; s); // encrypts s in place Then we\u0026rsquo;d better skip the pointless and potentially expensive default construction, directly initializing encrypted with password until right before we have to use the variable:\n1 2 3 4 5 6 7 8 9 10 11 12 std::string encryptPassword(const std::string\u0026amp; password) { using namespace std; if (password.length() \u0026lt; MinimumPasswordLength) { throw logic_error(\u0026#34;Password is too short\u0026#34;); } string encrypted(password); // define and initialize via copy constructor right before we have to use it encrypt(encrypted); return encrypted; } This gives us certain benifits:\nwe avoid constructing and destructing unneeded obejcts we avoid unnecessary default constructions we help document the purpose of variables by initializing them in contexts in which their meaning is clear Loop If a variable is used only inside a loop, should we define it outside the loop and make an assignment to it on each loop iteration, or to define the variable inside the loopï¼Ÿ\n1 2 3 4 5 6 7 // Approach A: define outside loop Widget w; for (int i = 0; i \u0026lt; n; ++i) { w = some value dependent on i; ... } 1 2 3 4 5 6 // Approach B: define inside loop for (int i = 0; i \u0026lt; n; ++i) { Widget w(some value dependent on i); ... } Let\u0026rsquo;s see the costs of the two approaches above:\nApproach A: 1 constructor + 1 destructor + n assignments Approach B: n constructor + n destructors Since Approach A makes the name w visible in a larger scope than Approach B, which is contrary to program comprehensibility and maintainability, generally we choose Approach B as default, unless we know that\nassignment is less expensive than a constructor-destructor pair we\u0026rsquo;re dealing with a performance-sensitive part of our code ",
  "summary": "Postponing variable definitions as long as possible increases program clarity and improves progranm efficiency.\n",
  "date": "2018-02-14T10:50:18-05:00",
  "lastmod": "2018-02-14T10:50:18-05:00",
  "permalink": "https://nianze.github.io/en/notes/2018/02/postpone-variable-definitions/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
