{
  "title": "[MECpp]Item-7 Never Overload '&&', '||', or ','",
  "content": "If we don\u0026rsquo;t have a good reason for overloading an operator, don\u0026rsquo;t overload it. In the case of \u0026amp;\u0026amp;, ||, and ,, it\u0026rsquo;s difficult to have a good reason: we can\u0026rsquo;t make them behave the way they\u0026rsquo;re supposed to.\nOverloading operator\u0026amp;\u0026amp; and operator|| C++ employs short-circuit evaluation of boolean expressions: once the truth or falsehood of an expression has been determined, evaluation of the expression ceases, even if somem parts of the expression haven\u0026rsquo;t yet been examined.\nThe operators associated with short-circuit evaluation are || and \u0026amp;\u0026amp;, which C++ allows us to customize for user-defined types. However, once we overloading the functions operator\u0026amp;\u0026amp; and operator|| (at the global scope or on a per-class basis), we are replacing short-circuit semantics with function call semantics, ending up changing the rules of the game quite radically. For example, after we overload operator\u0026amp;\u0026amp;, the following code:\n1 if (expression1 \u0026amp;\u0026amp; expression2) ... looks to compilers like one of these:\n1 2 3 if (expression1.operator\u0026amp;\u0026amp;(expression2)) ... // when operator\u0026amp;\u0026amp; is a member function if (operator\u0026amp;\u0026amp;(expression1, expression2)) ... // when operator\u0026amp;\u0026amp; is a global function In two crucial ways, the funciton call semantics differ from short-circuit semantics:\nwhen a funciton all is made, all parameters must be evaluated. Thus there is no short circuit. the order of evaluation of parameters to a function all is undefined, so there is no way of knowing whether expression1 or expression2 will be evaluated first. As a result, overloaded \u0026amp;\u0026amp; or || will never offer programmers the behavior they both exprect and have come to depend on. So do not overload \u0026amp;\u0026amp; or ||.\nOverloading operator, The comma operator is used for expressions, and we\u0026rsquo;re most likely to run across it in the update part of a for loop:\n1 2 3 4 5 6 7 8 9 10 11 void reverse(char s[]) { for (int i = 0, j = strlen(s)-1; i \u0026lt; j; ++i, --j) // the comma operator { int c = s[i]; s[i] = s[j]; s[j] = c; } } An expression containing a comma is evaluated by first evaluating the part of the expression to the left of the comma, then evaluating the expression to the right of the comma; the result of the overall comma expression is the value of the expression on the right. So the result for ++i, --j is the value returned from --j.\nUnfortunately, when writing our own comma operator, we can\u0026rsquo;t mimic this behavior for the same reason as the case in overriding || and \u0026amp;\u0026amp;:\nif we write operator, as a non-member function, then both operands around , will be passed as arguments in a function call, and there\u0026rsquo;s no way to control over the order in which a funciton\u0026rsquo;s arguments are evaluated. if we write operator, as a member function, we still can\u0026rsquo;t rely on the left-hand operand to the comma being evaluated first, because compilers are not constrained to do thing that way. Limits on operator overloading According to C++, following operators can\u0026rsquo;t be overloaded:\n. .* :: ?: new delete sizeof typeid static_cast dynamic_cast const_cast reinterpret_cast We can overload these:\noperator new operator delete operator new[] operator delete[] + - * / % ^ \u0026amp; | ~ ! \u0026lt; \u0026gt; += -= *= /= %= ^= \u0026amp; ` \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026gt;\u0026gt;= \u0026lt;\u0026lt;= == != \u0026lt;= \u0026gt;= -\u0026gt;* -\u0026gt; ++ -- , \u0026amp;\u0026amp; || () [] Just because we can overload there operators is no reason to run off and do it. The purpose of operator overloading is to make programs easier to read, write, and understand. If we don\u0026rsquo;t have a good reason for overloading an operator, don\u0026rsquo;t overload it, as is the case for \u0026amp;\u0026amp;, ||, and ,.\n",
  "summary": "If we don\u0026rsquo;t have a good reason for overloading an operator, don\u0026rsquo;t overload it. In the case of \u0026amp;\u0026amp;, ||, and ,, it\u0026rsquo;s difficult to have a good reason: we can\u0026rsquo;t make them behave the way they\u0026rsquo;re supposed to.\n",
  "date": "2018-03-29T11:18:24-04:00",
  "lastmod": "2018-03-29T11:18:24-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/03/never-overload-and-or-comma-operator/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
