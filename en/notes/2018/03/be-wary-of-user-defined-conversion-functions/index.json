{
  "title": "[MECpp]Item-5 Be Wary of User Defined Conversion Functions",
  "content": "Implicit type conversions usually lead to more harm than good, so don\u0026rsquo;t provide conversion functions unless we\u0026rsquo;re sure we want them.\nThere are two kinds of functions allowing compilers to perform implicit type conversions:\nimplicit type conversion operators non-explicit single-argument constructors Implicit type conversion operators 1 2 3 4 5 class Rational { public: ... operator double() const; // converts Rational to double }; This implicit type conversion function will be automatically invoked in contexts like this:\n1 2 3 Rational r(1, 2); // r has a value 1/2 double d = 0.5 * r; // converts r to a double, then do multiplication count \u0026lt;\u0026lt; r; // will print a floating point number instead of 1/2 if lacking difinition of operator\u0026lt;\u0026lt; Suppose we forget to write an operator\u0026lt;\u0026lt; for Rational objects, and expect the attempt to print r would fail due to the lack of appropriate operator\u0026lt;\u0026lt; to call. However, in the lack of operator\u0026lt;\u0026lt;, compilers are happy to find an acceptable sequence of implicit type conversions they could apply to make the call succeed. In this case, they will discover they could make the call succeed by implicitly converting r to a double by calling Rational::operator double, leading to wrong (often unexpected) function being called.\nSolution: replace the implicit type conversion operators with equivalent functions that don\u0026rsquo;t have the syntactically magic names, just like the explicit member function c_str in string type from standard C++ library (MECpp item 35):\n1 2 3 4 5 class Rational { public: ... double asDouble() const; // converts Rational to double }; 1 2 3 4 Rational r(1, 2); cout \u0026lt;\u0026lt; r; // error! no operator\u0026lt;\u0026lt; for Rationals cout \u0026lt;\u0026lt; r.asDouble(); // fine, prints r as a double Single-argument constructor 1 2 3 4 5 6 7 8 9 template\u0026lt;class T\u0026gt; class Array { public: Array(int lowBound, int highBound); // specify a range of array indices, ineligible for type-conversion Array(int size); // specify the number of elements in the array, can be used as a type conversion function T\u0026amp; operator[](int index); ... }; The problem of implicit type conversion occurs in following condition:\n1 2 3 4 5 6 7 8 9 10 11 bool operator==(const Array\u0026lt;int\u0026gt;\u0026amp; lhs, const Array\u0026lt;int\u0026gt;\u0026amp; rhs); Array\u0026lt;int\u0026gt; a(10); Array\u0026lt;int\u0026gt; b(10); ... for (int i = 0; i \u0026lt; 10; ++i) { // oops! \u0026#34;a\u0026#34; should be \u0026#34;a[i]\u0026#34; if (a == b[i]) { .... } else { ... } } Here, we mistakenly omitted the subscripting syntax when typing a. We expect this will cause compilers complaining, but they will not:\nCompilers see a call to operator== taking type Array\u0026lt;int\u0026gt; (for a) and int (for b[i]), and fail to find the corresponding function\nThere\u0026rsquo;s a operator== taking two Array\u0026lt;int\u0026gt; type arguments, and compilers are able to convert the int into an Array\u0026lt;int\u0026gt; object by calling Array\u0026lt;int\u0026gt; constructor that taking a single int as an argument, ending up with something like this1:\n1 2 3 for (int i = 0; i \u0026lt; 10; ++i) { if (a == static_cast\u0026lt; Array\u0026lt;int\u0026gt; \u0026gt;(b[i])) ... } Each iteration through the loop compares the contents of a with the contents of a temporary array of size b[i] (whose contents are presumably undefined and will be created and destroyed in every loop, see MECpp item 19), which is both unwanted and tremendously inefficient behavior.\nThere are two solutions: use keyword explicit or creating proxy classes.\nSolution 1: Keyword explicit 1 2 3 4 5 6 7 template\u0026lt;class T\u0026gt; class Array { public: ... explicit Array(int size); // use \u0026#34;explicit\u0026#34; to prevent implicit type conversion ... }; Solution 2: Proxy classes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template\u0026lt;class T\u0026gt; class Array { public: class ArraySize { public: ArraySize(int numElements): theSize(numElements) {} int size() const { return theSize; } private: int theSize; }; Array(int lowBound, int highBound); Array(ArraySize size); // new declaration ... }; 1 2 3 4 5 Array\u0026lt;int\u0026gt; a(10); // convert 10 to a temp. ArraySize object, then feed that temp. object to Array\u0026lt;int\u0026gt; ctor. for (int i = 0; i \u0026lt; 10; ++i) { if (a == b[i]) ... // error now! } One of the rules governing implicit type conversions is that no sequence of conversions is allowed to contain more than one user-defined conversion (i.e., a call to a single-argument constructor or an implicit type conversion operator). The above class difinition adopting a general technique called proxy classes takes advantage of this rule, ending up with ideal behavior that the object constructions we want to allow are legal, but the implicit conversions we don\u0026rsquo;t want to allow are illegal (compilers in one implicit conversion can\u0026rsquo;t call two user-defined conversions, one from int to ArraySize and one from ArraySize to Array\u0026lt;int\u0026gt;).\nProxy objects can give us control over aspects of software\u0026rsquo;s behavior that is otherswise beyond our grasp. For more detail, refer to MECpp item 30.\nThe space separating the two \u0026ldquo;\u0026gt;\u0026rdquo; characters has its purpose: without it, the statement will be like static_cast\u0026lt;Array\u0026lt;int\u0026gt;\u0026gt;(b[i]), and some C++ compilers parsing \u0026ldquo;\u0026raquo;\u0026rdquo; as a single token, ending up with a syntax error.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
  "summary": "Implicit type conversions usually lead to more harm than good, so don\u0026rsquo;t provide conversion functions unless we\u0026rsquo;re sure we want them.\n",
  "date": "2018-03-27T18:53:56-04:00",
  "lastmod": "2018-03-27T18:53:56-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/03/be-wary-of-user-defined-conversion-functions/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
