{
  "title": "Item-41 Understand inplicit interfaces and compile time polymorphism",
  "content": "Classes support explicit interfaces based on function signatures, as well as runtime polymorphism through virtual functions; templates support implicit interfaces based on valid expressions, as well as compile-time polymorphism through template instantiation and function overloading resolution.\nInterface and Polymorphism in OOP The world of object-oriented programming revolves around explicit interfaces and runtime polymorphism. For example:\n1 2 3 4 5 6 7 8 9 10 class Widget { public: Widget(); virtual ~Widget(); virtual std::size_t size() const; virtual void normalize(); void swap(Widget\u0026amp; other); // see item 25 ... }; 1 2 3 4 5 6 7 8 void doProcessing(Widget\u0026amp; w) { if (w.size() \u0026gt; 10 \u0026amp;\u0026amp; w != someNastyWidget){ Widget temp(w); temp.normalize(); temp.swap(w); } } Regarding the w in doProcessing, we could conclude:\nexplicit interface: w is of type Widget, so it must support the Widget interface, which is an explicit interface, because it is explicitly visible in the source code (e.g., the .h file for Widget) runtime polymorphism: w\u0026rsquo;s call to some of its virtual member functions exhibits runtime polymorphism, because the specific function to call will be determined at runtime based on w\u0026rsquo;s dynamic type (item 37) Specifically, the explicit interface of Widget consists of its function signatures: a constructor, a destructor, and the functions size, normalize, and swap, along with the parameter types, return types, and constnesses of these functions, as well as compilter-generated copy constructor and copy assignment operator (item 5). Potentially, it could also include typedefs, and data members.\nInterface and Polymorphism in templates and generic programming In the world of templates and generic programming, the explicit interfaces and runtime polymorphism continue to exist, but we also have to consider implicit interfaces and compile-time polymorphism. As a comparison, let\u0026rsquo;s take a look at the template version of doProcessing:\n1 2 3 4 5 6 7 8 9 template\u0026lt;typename T\u0026gt; void doProcessing(T\u0026amp; w) { if (w.size() \u0026gt; 10 \u0026amp;\u0026amp; w != someNasyWidget) { T temp(w); temp.normalize(); temp.swap(w); } } For w in the template doProcessing:\nimplicit interface: w must support all the operations performed on it, but there is no explicit function signatures to follow. Rather, there\u0026rsquo;s an implicit interface consists of valid expressions that set constraints on w. compile-time polymorphism: w is one of the parameters in operator\u0026gt; and operator!=, which may involve instantiating function templates with different template parameters, leading to different functions being called during compilation. This is similar to the process to determine which of a set of overloaded functions should be called during compilation. Specifically, let\u0026rsquo;s take a look those constrains on w\u0026rsquo;s type T in the implicit interface:\nwhatever w.size() \u0026gt; 10 \u0026amp;\u0026amp; w != someNasyWidget yields, the expression as a whole must be compatible with bool calls to the copy constructor, to normalize, and to swap must be valid for objects of type T However, inside the expression w.size() \u0026gt; 10 \u0026amp;\u0026amp; w != someNasyWidget, constraints on compatibal type regarding the functions size, operator\u0026gt;, operator\u0026amp;\u0026amp;, or operator!= are pretty flexible, thanks to the possibility of operator overloading and implicit conversion:\nthere\u0026rsquo;s no requirement that size returns an integral value - it may simply return an object of some type X such that there is an operator\u0026gt; that can be called with an object of type X and an int (10 is of type int) there\u0026rsquo;s no requirement that operator\u0026gt; take a parameter of type X - it may take a parameter of type Y, as long as there were an implicit conversion from objects of type X to objects of type Y there\u0026rsquo;s no requirement that T support operator!= - it would be just as acceptable for operator!= to take one object of type X and one object of type Y, as long as T can be converted to X and someNastyWidget\u0026rsquo;s type can be converted to Y potentially, even operator\u0026amp;\u0026amp; could be overloaded, changing the meaning of the above expression from a conjunction to something quite different Anyway, the implicit interfaces imposed on a template\u0026rsquo;s parameters are just as real as the explicit interfaces imposed on a class\u0026rsquo;s objects, and both are checked during compilation.\n",
  "summary": "Classes support explicit interfaces based on function signatures, as well as runtime polymorphism through virtual functions; templates support implicit interfaces based on valid expressions, as well as compile-time polymorphism through template instantiation and function overloading resolution.\n",
  "date": "2018-03-07T14:21:33-05:00",
  "lastmod": "2018-03-07T14:21:33-05:00",
  "permalink": "https://nianze.github.io/en/notes/2018/03/understand-inplicit-interfaces-and-compile-time-polymorphism/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
