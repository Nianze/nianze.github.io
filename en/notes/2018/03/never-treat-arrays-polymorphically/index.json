{
  "title": "[MECpp]Item-3 Never Treat Arrays Polymorphically",
  "content": "Array operations almost always involve pointer arithmetic, so arrays and polymorphism don\u0026rsquo;t mix.\nC++ allows us to manipulate arrays of derived class objects through base class pointers and references, but it almost nerver works athe way we want it to.\nFor example, suppose following base class BST (binary search tree objects) and its derived class BalancedBST:\n1 2 class BST {...}; class BalancedBST: public BST {...}; For a function working with an array of BSTs, it works fine when we pass it an array of BST objects:\n1 2 3 4 5 6 7 8 9 10 void printBSTArray(ostream\u0026amp; s, const BST array[], int numElements) { for (int i = 0; i \u0026lt; numElements; ++i) { s \u0026lt;\u0026lt; array[i]; // assumes operator\u0026lt;\u0026lt; is defined for BST objects } } BST BSTArray[10]; ... printBSTArray(cout, BSTArray, 10); // work fine However, when passing an array of BalancedBST objects:\n1 2 3 BalancedBST bBSTArray[10]; ... printBSTArray(cout, bBSTArray, 10); The compilers will accept this function call without complaint, but then for array[i]`, they will generate code involving pointer arithmetic:\narray[i] is just shorthand for expression *(array+i) the distance between the memory location pointed to by array and by array+i is calculated through i*sizeof(object in the array) the parameter array is declared to be of type array-of-BST, so each element of the array is regard as BST, and thus the distance is i*sizeof(BST) the size of an object of type BalancedBST usually is larger than their base class ones\u0026rsquo; size, because derived class usually has extra data members If it is, the ointer arithmetic generated for printBSTArray will be wrong for arrays of BalancedBST objects Another problem will pop up if we try to delete an array of derived class objects through a base class pointer:\n1 2 3 4 5 6 7 8 9 10 void deleteArray(ostream\u0026amp; logStream, BST array[]) { logStream \u0026lt;\u0026lt; \u0026#34;Deleting array at address \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;void*\u0026gt;(array) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; delete [] array; } BalancedBST *balTreeArray = new BalancedBST[50]; // create a BalancedBST array ... deleteArray(cout, balTreeArray); // log its deletion There\u0026rsquo;s pointer arithmetic going on here, too: when compilers see the statement delete [] array;, they will generate code that looks like this:\n1 2 3 4 for (int i = the number of elements in the array - 1; i \u0026gt;= 0; --i) { array[i].BST::~BST(); // call array[i]\u0026#39;s destructor } Now we understand why the language specification says that the result of deleting an array of derived class objects through a base class pointers is undefined: here, again, polymorphism meets pointer arithmetic.\nIn the point of software designing, as MECpp-item 33 suggests, we\u0026rsquo;re unlikely to make the mistake of treating an array polymorphically if we avoid having a concrete class (like BalancedBST) inherit from another concrete class (such as BST).\n",
  "summary": "Array operations almost always involve pointer arithmetic, so arrays and polymorphism don\u0026rsquo;t mix.\n",
  "date": "2018-03-23T18:59:16-04:00",
  "lastmod": "2018-03-23T18:59:16-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/03/never-treat-arrays-polymorphically/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
