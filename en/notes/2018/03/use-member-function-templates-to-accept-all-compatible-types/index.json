{
  "title": "Item-45 Use member function templates to accept all compatible types",
  "content": "In order to implicitly convert all compatible types for a template class, we neet not a constructor function but a constructor template - member functoin templates that generate member functions of a class.\nImplicit conversion is a big convenient advantage offered by pointers: derived class pointers convert into base class pointers implicitly, pointers to non-const objects convert into pointers to const implicitly, etc. For a three-level hierarchy, following code makes perfect sense:\n1 2 3 4 5 6 class Top {...}; class Middle: public Top {...}; class Bottom: public Middle {...}; Top *pt1 = new Middle; // convert Middle* -\u0026gt; Top* Top *pt2 = new Bottom; // convert Bottom* -\u0026gt; Top* const Top *pct = pt1; // convert Top* -\u0026gt; const Top* In the world of template, we\u0026rsquo;d really like to emulate such conversions for our user-defined smart pointer classes:\n1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename T\u0026gt; class SmartPtr { public: explicit SmartPtr(T *realPtr) // initialized by built-in pointers ... }; SmartPtr\u0026lt;Top\u0026gt; pt1 = SmartPtr\u0026lt;Middle\u0026gt;(new Middle); // convert SmartPtr\u0026lt;Middle\u0026gt; -\u0026gt; SmartPtr\u0026lt;Top\u0026gt; SmartPtr\u0026lt;Top\u0026gt; pt2 = SmartPtr\u0026lt;Bottom\u0026gt;(new Bottom); // convert SmartPtr\u0026lt;Bottom\u0026gt; -\u0026gt; SmartPtr\u0026lt;Top\u0026gt; SmartPtr\u0026lt;const Top\u0026gt; pct = pt1; // convert SmartPtr\u0026lt;Top\u0026gt; -\u0026gt; SmartPtr\u0026lt;const Top\u0026gt; However, there\u0026rsquo;s no inherent relationship among different instantiations of the same template, so compilers view SmartPtr\u0026lt;Middle\u0026gt; and SmartPtr\u0026lt;Top\u0026gt; as completely different classes. We need to write smart pointer constructors that is not only able to construct SmartPtr\u0026lt;Top\u0026gt; from SmartPtr\u0026lt;Middle\u0026gt;, but also capable to convert any compatible types in the hierarchy (we may extend the hierarchy in the future and add class BelowBottom: public Bottom). In principle, such constructors are countless.\nConsidering the fact that a template can be instantiated to generate an unlimited number of functions, what we need here is not a constructor function, but a constructor template, the member function templates (also known as member templates) that generate member functions of a class:\n1 2 3 4 5 6 7 template\u0026lt;typename T\u0026gt; class SmartPtr { public: template\u0026lt;typename U\u0026gt; // member template for a \u0026#34;generalized copy constructor\u0026#34; SmartPtr(const SmartPtr\u0026lt;U\u0026gt;\u0026amp; other); // not declared as \u0026#34;explicit\u0026#34; for implicit conversion ... }; Constructors like this - ones that create one object from anothe object whose type is a different instantiation of the same template (e.g., create a SmartPtr\u0026lt;T\u0026gt; from a SmartPtr\u0026lt;U\u0026gt;) - are known as generalized copy constructors.\nHowever, this member template will generate more member functions than we need: as declared, it is possible to create a SmartPtr\u0026lt;Bottom\u0026gt; from a SmartPtr\u0026lt;Top\u0026gt;, which is contrary to the meaning of public inheritance (item 32). We need to restrict the conversions to those we want:\n1 2 3 4 5 6 7 8 9 10 11 template\u0026lt;typename T\u0026gt; class SmartPtr { public: template\u0026lt;typename U\u0026gt; SmartPtr(const SmartPtr\u0026lt;U\u0026gt;\u0026amp; other) // initialize this held ptr with other\u0026#39;s held ptr : heldPtr(other.get()) {...} T* get() const { return heldPtr; } ... private: T *heldPtr; // built-in ptr held by the smartPtr }; Since we initialize SmartPtr\u0026lt;T\u0026gt;\u0026rsquo;s data member of type T* with the pointer of type U* held by SmartPtr\u0026lt;U\u0026gt;, the code above will compile only if there is an implicit conversion from a U* pointer to a T* pointer, and this is exactly what we want.\nApart from constructors, we can also apply member function tmeplates to assignment. A good example is from TR1\u0026rsquo;s shared_ptr (item 13):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 template\u0026lt;class T\u0026gt; class shared_ptr { public: shared_ptr(shared_ptr const\u0026amp; r); // \u0026#34;normal\u0026#34; copy constructor template\u0026lt;class Y\u0026gt; explicit shared_ptr(Y * p); // generalized copy constructor from any compatible built-in pointer template\u0026lt;class Y\u0026gt; shared_ptr(shared_ptr\u0026lt;Y\u0026gt; const\u0026amp; r); // from compatible shared_ptr template\u0026lt;class Y\u0026gt; explicit shared_ptr(weak_ptr\u0026lt;Y\u0026gt; const\u0026amp; r); // from compatible weak_ptr template\u0026lt;class Y\u0026gt; explicit shared_ptr(auto_ptr\u0026lt;Y\u0026gt;\u0026amp; r); // from compatible auto_ptr shared_ptr\u0026amp; operator=(shared_ptr const\u0026amp; r); // \u0026#34;normal\u0026#34; copy assignment template\u0026lt;class Y\u0026gt; shared_ptr\u0026amp; operator=(shared_ptr\u0026lt;Y\u0026gt; const\u0026amp; r); // generalized copy assign from any compatible shared_ptr template\u0026lt;class Y\u0026gt; shared_ptr\u0026amp; operator=(auto_ptr\u0026lt;Y\u0026gt;\u0026amp; r); // assign from any compatible auto_ptr ... }; Note that\nthe generalized copy constructor is not declared explicit in order to support implicit conversion from one type of shared_ptr to another. All other constructors are explicit, so implicit conversion from a built-in pointer or other smart pointer type is not permitted (explicit conversion via a cast is okey). auto_ptr passed to tr1::shared_ptr constructors and assignment operators are not declared const, because auto_ptr will be modifies when they\u0026rsquo;re copyed (item 13). both a generalized copy constructor (and assignment) as well as the \u0026ldquo;normal\u0026rdquo; copy constructor (and copy assignment) are declared, because declaring a generalized copy constructor (a member template) in a class doesn\u0026rsquo;t keep compilers from generating their own copy constructor (a non-template version), so if we want to control all aspect of copy construction, we declare both. ",
  "summary": "In order to implicitly convert all compatible types for a template class, we neet not a constructor function but a constructor template - member functoin templates that generate member functions of a class.\n",
  "date": "2018-03-12T20:14:47-04:00",
  "lastmod": "2018-03-12T20:14:47-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/03/use-member-function-templates-to-accept-all-compatible-types/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
