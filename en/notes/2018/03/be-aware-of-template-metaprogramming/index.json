{
  "title": "Item-48 Be aware of template metaprogramming",
  "content": "Template metaprogramming can shift work from runtime to compile-time (thus enabling earlier error dettection and higher runtime performance), can be used to generate custom code based on combinations of policy choices, and can also be used to avoid generating code inappropriate for particular types.\nTemplate metaprogramming (TMP) is the process of writing template-based C++ programs that execute inside the C++ compiler, ending up with pieces of C++ source code instantiated from templates, which are then compiled as usual. TMP was discovered, not designed, in the early 1990s, and has later been shown to be Turing-complete, which means that it is powerful enough to compute anything (declare variables, perform loops, write and call functions, etc).\nStrength of TMP TMP has two great strengths:\nit makes some things easy that would otherwise be hard or impossiblle it shifts work from runtime to compile-time1 By making use of TMP, we can expect following good consequences:\nSome kinds of errors originally detected at runtime could be found during compilation C++ progrmas become more efficient in about every way: smaller executables, shorter runtimes, lesser memory requirements To take a glimpse into how things work in TMP, let\u0026rsquo;s look at two examples.\nExamples Ex1: if...else conditionals in TMP\nAs item 47 shows, if...else conditionals in TMP are expressed via templates and template specializations2. Let\u0026rsquo;s take a comparason between the \u0026ldquo;normal\u0026rdquo; C++ (using typeid) and TMP (using traits) based on implementing the pseudo part of if (iter is a random access iterator) from STL\u0026rsquo;s advance\nBelow is the \u0026ldquo;normal\u0026rdquo; C++ approach, which evaluates at runtime:\n1 2 3 4 5 6 7 8 9 10 11 12 template\u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d) { if (typeid(typename std::iterator_traits\u0026lt;IterT\u0026gt;::iterator_categoray) == typeid(std::random_access_iterator_tag)) { iter += d; // use iterator arithmetic for random access iters } else { if (d \u0026gt;= 0) { while(d--) ++iter; } else { while(d++) --iter; } } } Compared to the one using traits, the typeid-based approach has following issues:\nless efficient: testing occurs at runtime; executable is larger (since the code to do the testing must be present in the executable) introduce compilation problems: if iter isn\u0026rsquo;t a random access iterator, iter will not support operator +=, so iter += d will not be valid, but compilers will still check this part of code and complain about its invalidation, because they are obliged to make sure that all source code is valid, even if it\u0026rsquo;s not executed. Ex2: loops in TMP\nTMP has no real looping construct, so the effect of loops is accomplished via recursion, or more specifically, recursive template instantiations. As an example, TMP factorial computation demonstates how it works:\n1 2 3 4 5 6 7 8 9 template\u0026lt;unsigned n\u0026gt; // general case: the value of Factorial\u0026lt;n\u0026gt; is n times the value of Factorial\u0026lt;n-1\u0026gt; struct Factorial { enum { value = n * Factorial\u0026lt;n-1\u0026gt;::value }; }; template\u0026lt;\u0026gt; struct Factorial\u0026lt;0\u0026gt; { enum { value = 1 }; }; The looping part of the code occurs where the template instantiation Factorial\u0026lt;n\u0026gt; references the tempalte instantiation Factorial\u0026lt;n-1\u0026gt;, until hitting the special case, Factorial\u0026lt;0\u0026gt;, that causes the recursion to terminate.\nEach instantiation of the Factorial template is a struct, and each struct uses the enum hack (item 2) to declare a TMP variable named value, which holds the current value of the factorial computation. After recursive template instantiation, each instantiation gets its own copy of value.\nTo use Factorial:\n1 2 3 4 5 int main() { std::cout \u0026lt;\u0026lt; Factorial\u0026lt;5\u0026gt;::value; // prints 120 std::cout \u0026lt;\u0026lt; Factorial\u0026lt;10\u0026gt;::value; // prints 3628800 } To sum up the technique keywords: templates and specializations and recursive instantiations and enum hacks.\nWhat can be accomplished in TMP 1. Ensuring dimensional unit correctness In scientific and engineering applications, it\u0026rsquo;s essential that dimensional units (e.g., mass, distance, time, etc.) be combined correctly. Using TMP, it\u0026rsquo;s possible to ensure (during compilation) that all dimensional unit combinations in a program are correct, no matter how complex the calculations - good example for early error detection.\n2. Optimizang matrix operations Consider the following code,\n1 2 3 4 typedef SqureMatrix\u0026lt;double, 10000\u0026gt; BigMatrix; BigMatrix m1, m2, m3, m4, m5; // create matrices ... // give them values BigMatrix result = m1 * m2 * m3 * m4 * m5; // compute the product Calculating result in the \u0026ldquo;normal\u0026rdquo; way calls for the creation of four temporary matrices, one for the reuslt of each call to operator*. Furthermore, the independent multiplications generate a sequence of four loops over the matrix elements.\nUsing an advanced template technology related to TMP called expression templates, it\u0026rsquo;s possible to eliminate the temporaries and merge the loops, without changing the syntax of the client code above while enabling the program consume less memory and run dramatically fast.\n3. Generating custom design pattern implementations Design patterns like Strategy (item 35), Observer, Visitor, etc. can be implemented in many ways. Using a TMP-based technology called policy-based design, it\u0026rsquo;s possible to create templates representing independent design choices (\u0026ldquo;policies\u0026rdquo;) that can be combined in arbitrary ways to yield pattern implementations with custom behavior.\nGeneralized beyond the domain of programming artifacts like design patterns, this technology is a basis for what\u0026rsquo;s known as generative programming.\nPrograms using TMP may take much longer to compile than their non-TMP counterparts.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBasic constructs, such as declaring variables, performing loops, and calling function, may look very different from their \u0026ldquo;normal\u0026rdquo; C++ counterparts, but that\u0026rsquo;s assembly-level TMP - it\u0026rsquo;s worth to know that libraries for TMP (e.g., Boost\u0026rsquo;s MPL, item 55) offer a higher-level syntax.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
  "summary": "Template metaprogramming can shift work from runtime to compile-time (thus enabling earlier error dettection and higher runtime performance), can be used to generate custom code based on combinations of policy choices, and can also be used to avoid generating code inappropriate for particular types.\n",
  "date": "2018-03-15T23:00:22-04:00",
  "lastmod": "2018-03-15T23:00:22-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/03/be-aware-of-template-metaprogramming/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
