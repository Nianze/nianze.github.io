{
  "title": "[MECpp]Item-8 Understand the Different Meanings of New and Delete",
  "content": "The behaviors of new operator and operator new is different.\nRelationship between \u0026lsquo;new operator\u0026rsquo; and \u0026lsquo;operator new\u0026rsquo; Consider the following code:\n1 string *ps = new string(\u0026#34;Memory Management\u0026#34;); The new operator here is built into the language and always does the same two things:\nfirst, it calls operator new to allocate enough memory to hold an object of the type requested. second, it calls a constructor to initialize an object in the memory that was allocated. Thus, when compiler sees the code above, they must generate code equivalent to this:\n1 2 3 4 void *memory = operator new(sizeof(string)); // get raw memory for a string object call string::string(\u0026#34;Memory Management\u0026#34;) on *memory // init. the object in the memory. // as programmer, directly calling the ctor is prohibited string *ps = static_cast\u0026lt;stirng*\u0026gt;(memory); // make ps point to the new object So if we want to create an object on the heap, use the new operator and it both allocates memory and calls a constructor for the object.\nHowever, if we want to do some customized behaviors, we may consider following options:\nif we only want to allocate memory, just call operator new directly:\n1 void *rawMemory = operator new(sizeof(string)); if we want to customize the memory allocation that takes place when heap objects are created, write our own version of operator new and use the new operator, which will automatically invoke the custom version of operator new\nif we want to construct an object in memory we\u0026rsquo;ve already got a pointer to, use placement new.\nA special version of oeprator new called placement new allows us to construct an object in the memory that\u0026rsquo;s already been allocated, which is helpful for applications using shared memory or memory-mapped I/O, where objects must be placed at specific addresses or in memory allocated by special routines:\n1 2 3 4 5 6 7 8 9 10 class Widget { public: Widget(int widgetSize); ... }; Widget * constructWidgetInBuffer(void *buffer, int widgetSize) { return new (buffer) Widget(widgetSize); } Here, an additional argument (buffer) is being specified for the implicit call that the new operator makes to a special version of operator new known as placement new in standard C++ library1:\n1 2 3 4 void * operator new(size_t, void *location) { return location; } All placement new has to do is return the pointer that\u0026rsquo;s passed into it, because the memory for the object is already known. The unused (but mandatory) size_t parameter has no name to keep compilers from complaining about its not being used (MECpp item 6).\nDeletion and memory deallocation The delete operator also includes two steps: destructing the object and deallocating the memory occupied by that object. The second part of memory deallocation is performed by the operator delete function:\n1 void operator delete(void *memoryToBeDeallocated); Hence, for a pointer to string ps, delete ps; causes compilers to generate code that approximately corresponds to this:\n1 2 ps-\u0026gt;~string(); // call the object\u0026#39;s dtor operator delete(ps); // deallocate the memory the object occupied Some implications:\nIf we want to deal with raw, uninitialized memory, we should call operator new to get memory and operator delete to return it to the system (the C++ equivalent of calling malloc and free): 1 2 3 void *buffer = operator new (50*sizeof(char)); // allocate enough memory to hold 50 chars, call no ctor ... operator delete(buffer); // deallocate the memory; call no dtor If we use placement new to create an object in some memory, we should avoid using the delete operator on that memory: 1 2 3 4 5 6 7 8 9 10 // function to allocating and deallocating memory in shared memory void * mallocShared(size_t size); void freeShared(void *memory); void *sharedMemory = mallocShared(sizeof(Widget)); Widget *pw = constructWidgetInBuffer(sharedMemory, 10); // as above ... delete pw; // undefined! sharedMemory came from mallocShared, not operator new pw-\u0026gt;~Widget(); // fine. destructs the Widget pointed to by pw, no memory deallocation performed freeShared(pw); // fine, deallocate the memory pointed to by pw, but calls no dtor Arrays For array allocation:\n1 string *ps = new string[10]; // allocate an array of objects The new being used is still the new operator, but the behavior here is slightly different from the case for single-object creation:\nin the first step, memory is allocated by operator new[] instead of operator new in the second step, the constructor is called for each object in the array, so here the default constructor for string is called 10 times. Similarly, when the delete operator is used on an array, it calls a destructor for each array element and then calls operator delete[] to deallocate the memory.\nJust as we can replace or overload operator new and operator delete, we can do the same trick to operator new [] and operator delete [] to seize the control of memrory allocation and deallocation for arrays.\nTo use placement new, all we have to do is is #include \u0026lt;new\u0026gt;.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
  "summary": "The behaviors of new operator and operator new is different.\n",
  "date": "2018-03-30T17:09:04-04:00",
  "lastmod": "2018-03-30T17:09:04-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/03/understand-the-different-meanings-of-new-and-delete/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
