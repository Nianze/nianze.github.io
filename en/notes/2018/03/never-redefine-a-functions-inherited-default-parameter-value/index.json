{
  "title": "Item-37 Never redefine a function's inherited default parameter value",
  "content": "Defaul parameter values are statically bound, while virtual function - the only functions we should be overriding - are dynamically bound.\nAs item 36 suggests, we should never redefine an inherited non-virtual function, so we only need to focus on the case where we inherit a virtual function with a default parameter value.\nTo make things clear, first we need to understand the difference between static and dynamic binding:\nan object\u0026rsquo;s static type is the type we declare it to have in the program text an object\u0026rsquo;s dynamic type is determined by the type of the object to which it currently refers. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // a class for geometric shapes class Shape { public: enum ShapeColor {Red, Green, Blue}; // all shapes must offer a function to draw themselves virtual void draw(ShapeColor color = Red) const = 0; ... }; class Rectangle: public Shape { public: // different default parameter value -\u0026gt; bad virtual void draw(ShapeColor color = Green) const; ... }; class Circle: public Shape { public: virtual void draw(ShapeColor color) const; ... }; 1 2 3 Shape *ps; // static type = Shape*, no dynamic type (no object referred to) Shape *pr = new Rectangle // static type = Shape*, dynamic type = Rectangle* Shape *pc = new Circle; // static type = Shape*, dynamic type = Circle* Notice that the static type of ps, pr, and pr are all \u0026ldquo;pointer-to-Shape\u0026rdquo;, and that it makes no difference what they\u0026rsquo;re really pointing to.\nDynamic types , as their name suggests, can change as a program runs, typically through assignments:\n1 2 ps = pr; // ps\u0026#39;s dynamic type is now Rectangle* ps = pc; // ps\u0026#39;s dynamic type is now Circle* Virtual functions are dynamically bound, meaning that the particular function called is determined by the dynamic type of the object through which it\u0026rsquo;s invoked:\n1 2 pc-\u0026gt;draw(Shape::Red); // calls Circle::draw(Shape::Red) pr-\u0026gt;draw(Shape::Red); // calls Rectangle::draw(Shape::Red) However, since default parameters are statically bound, when calling a virtual function defined in a derived class, it is possible that the default parameter value we are using is from a base class:\n1 pr-\u0026gt;draw(); // calls Rectangle::draw(Shape::Red) In this case, even though the virtual function is called according to dynamic type Rectangle*, the default parameter value is taken from the Shape class (Shape::Red) rather than the derived Rectangle class (Shape::Green is expected). This result is almost certainly unanticipated.\nThe problem here is that the default parameter value of virtual function draw is redefined in a derived class. This inconsistency between the function call\u0026rsquo;s dynamic binding and the default parameter value\u0026rsquo;s statical binding is mainly due to C++\u0026rsquo;s insistence on runtime efficiency.\nWhen we\u0026rsquo;re having trouble making a virtual function behave the way we\u0026rsquo;d like, it\u0026rsquo;s wise to consider alternative designs, which item 35 happens to offer. One of the alternatives is the non-virtual-interface idiom:\nin order to make clear that the default value for draw\u0026rsquo;s color parameter should always be Red, we could declare a public non-virtual function in the base class calling a private virtual function that derived classes may redefine. According to item 36, such an non-virtual function should never be overridden by derived classes. Thus, simply specify the default parameter in the non-virtual function, and we\u0026rsquo;re done:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Shape { public: enum ShapeColor {Red, Green, Blue}; void draw(ShapeColor color = Red) const // now non-virtual { doDraw(color); // calls the private virtual } ... private: virtual void doDraw(ShapeColor color) const = 0; // the actual work is done in this func }; class Rectangle: public Shape { public: ... private: virtual void doDraw(ShapeColor color) const; // note lack of a default param value }; ",
  "summary": "Defaul parameter values are statically bound, while virtual function - the only functions we should be overriding - are dynamically bound.\n",
  "date": "2018-03-02T21:15:36-05:00",
  "lastmod": "2018-03-02T21:15:36-05:00",
  "permalink": "https://nianze.github.io/en/notes/2018/03/never-redefine-a-functions-inherited-default-parameter-value/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
