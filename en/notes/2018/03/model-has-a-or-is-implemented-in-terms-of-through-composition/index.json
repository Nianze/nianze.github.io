{
  "title": "Item-38 Model 'has-a' or 'is-implemented-in-terms-of' through composition",
  "content": "In the application domain, composition means has-a. In the implementation domain, it means is-implemented-in-terms-of.\nComposition is the relationship where objects of one type contain objects of another type. It\u0026rsquo;s also known as layering, containment, aggregation, and embedding. As public inheritance means \u0026ldquo;is-a\u0026rdquo;, there\u0026rsquo;re are two meanings for composition:\n\u0026ldquo;has-a\u0026rdquo; in the application domain (where we model things in the world with objects, such as people, vehicles, video frames, etc.) \u0026ldquo;is-implemented-in-terms-of\u0026rdquo; in the implementation domain (where the objects are purely implementation artifacts, e.g., buffers, mutexes, search trees, etc) While the has-a relationship is easy enough to understand, the distinction between is-a and is-implemented-in-terms-of is sometimes troublesome. For example, suppose we\u0026rsquo;d like to (re)use the list template in the standard C++ library to represent fairly small sets of objeccts, i.e., collections without duplicates.\nIn the first glimpse, we may consider the following implementation:\n1 2 template\u0026lt;typename T\u0026gt; // the wrong way to use list for Set class Set: public std::list\u0026lt;T\u0026gt; {...}; As item 32 explains, if D is-a B, everything true of B is also true of D. However, a list object may contains duplicates, but a Set may not contain duplicates. It is thus untrue that a Set is-a list, and public inheritance is the wrong way to model this relationship.\nThe right relationship between the Set and the list should be is-implemented-in-terms-of:\n1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename T\u0026gt; class Set { public: bool member(const T\u0026amp; item) const; void insert(const T\u0026amp; item); void remove(const T\u0026amp; item); std::size_t size() const; private: std::list\u0026lt;T\u0026gt; rep; / representation for Set data }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 template\u0026lt;typename T\u0026gt; bool Set\u0026lt;T\u0026gt;::member(const T\u0026amp; item) const { return std:find(rep.begin(), rep.end(), item) != rep.end(); } template\u0026lt;typename T\u0026gt; void Set\u0026lt;T\u0026gt;::insert(const T\u0026amp; item) { if (!member(item)) rep.push_back(item); } template\u0026lt;typename T\u0026gt; void Set\u0026lt;T\u0026gt;::remove(const T\u0026amp; item) { typename std::list\u0026lt;T\u0026gt;::iterator it = // see item 42 for info on typename std::find(rep.begin(), rep.end(), item); if (it != rep.end()) rep.erase(it); } template\u0026lt;typename T\u0026gt; std::size_t Set\u0026lt;T\u0026gt;::size() const { return rep.size(); } As above shows, Set\u0026rsquo;s member functions can lean heavily on functionality already offered by list and other parts of the standard library. Since they are so simple, they make reasonable candidates for inlining (refer to item 30 before confirming doing so).\n",
  "summary": "In the application domain, composition means has-a. In the implementation domain, it means is-implemented-in-terms-of.\n",
  "date": "2018-03-04T15:49:31-05:00",
  "lastmod": "2018-03-04T15:49:31-05:00",
  "permalink": "https://nianze.github.io/en/notes/2018/03/model-has-a-or-is-implemented-in-terms-of-through-composition/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
