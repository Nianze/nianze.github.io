{
  "title": "[MECpp]Item-22 Consider Using op= Instead of Stand Alone op",
  "content": "Assignment versions of operators (such as operator+=) tend to be more efficient than stand-alone versions of those operators (e.g., operator+).\nEfficiency difference between op= and stand-alone op In general, assignment versions of operators are more effiecient than stand-alone versions, because stand-alone versions must typically return a new object, and that costs us the construction and destruction of a temporary (MECpp item 19 and 20) assignment versions of operators write to their left-hand argument, so there is no need to generate a temporary to hold the operator\u0026rsquo;s return value By offering assignment versions of operators as well as stand-alone versions, we allow clients of our classes to make the different trade-off between efficiency and convenience: 1 2 3 Rational a, b, c, d, result; ... result = a + b + c + d; // 3 potential temporary objects, one for each call to operator+ This version is easy to write, debug, and maintain, and it offers acceptable performance about 80% of the time (MECpp item 16).\n1 2 3 4 result = a; // no temporary result += b; // no temporary result += c; // no temporary result += d; // no temporary This version is more efficient.\nIn summary, as a library designer, we should offer both, and as an application developer, we should consider using assignment versions of operators instead of stand-alone versions when trying to deal with the critical 20% code.\nRelationship between op= and stand-alone op To ensure the natural relationship between the assignment version of an operator (e.g., operator+=) and the stand-alone version (e.g., operator+) exists, we can implement the latter in terms of the former (MECpp item 6):\n1 2 3 4 5 6 7 8 9 10 class Rational { public: ... Rational\u0026amp; operator+=(const Rational\u0026amp; rhs); }; const Rational operator+(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { return Rational(lhs) += rhs; } Further more, if we don\u0026rsquo;t mind putting all stand-alone operators at global scope, we can use templates to eliminate the need to write the stand-alone functions:\n1 2 3 4 5 template\u0026lt;class T\u0026gt; const T operator+(const T\u0026amp; lhs, const T\u0026amp; rhs) { return T(lhs) += rhs; } A few points worth noting in this implementation of operator+:\noperator+= is implemented (elsewhere) from scratch, and operator+ calls it to provide its functionality, so that only the assignment versions need to be maintained. Assuming the assignment version is in the class\u0026rsquo;s public interface, there is no need for the stand-alone operators to be friends of the class. Without any named object, this implementation may take use of the return value optimization (MECpp item 20) 1. Although it is possible that return T(lhs) += rhs; may be more complex than most compilers are willing to subject to the return value optimization.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
  "summary": "Assignment versions of operators (such as operator+=) tend to be more efficient than stand-alone versions of those operators (e.g., operator+).\n",
  "date": "2018-04-18T14:09:10-04:00",
  "lastmod": "2018-04-18T14:09:10-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/04/consider-using-op-instead-of-stand-alone-op/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
