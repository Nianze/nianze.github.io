{
  "title": "[MECpp]Item-23 Consider Alternative Libraries",
  "content": "Different libraries offering similar functionality often feature different performance trade-offs, so we might be able to remove bottlenecks by replacing one library with another.\nIdeally, a library is small, fast, powerful, flexible, extensible, intuitive, universally available, well supported, free of use restriction, and bug-free.\nIn reality, libraries optimized for size and speed are typically not portable; libraries with rich functionality are rarely intuitive; bug-free libraries are limited in scope. In a word, we can\u0026rsquo;t get everything.\nDifferent designers assign different priorities to these criteria, leading to the result that two libraries offering similar functionality have different performance profiles.\nTake iostream and stdio for example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #ifndef STDIO #include \u0026lt;stdio.h\u0026gt; #else #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; #endif const int VALUES = 30000; // # of values to read/write int main() { double d; for (int n = 1; n \u0026lt;= VALUES; ++n) { #ifdef STDIO scanf(\u0026#34;%lf\u0026#34;, \u0026amp;d); printf(\u0026#34;%10.5f\u0026#34;, d); #else cin \u0026gt;\u0026gt; d; cout \u0026lt;\u0026lt; setw(10) // set field width \u0026lt;\u0026lt; setprecision(5) // set decimal places \u0026lt;\u0026lt; setiosflags(ios::showpoint) // keep trailing \u0026lt;\u0026lt; setiosflags(ios::fixed) \u0026lt;\u0026lt; d; #endif if (n % 5 == 0) { #ifdef STDIO printf(\u0026#34;\\n\u0026#34;); #else cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } #endif } return 0; } Running this program on several combinations of machines, operating systems, and compilers, and we should get a brief insight into the comparative performance difference between these two libraries. It is probable that the stdio version is faster, and the size of the executable using stdio tends to be smaller. However, it is also possible that iostream implementation is faster than stdio, because iostreams determine the types of their iperands during compilation, while stdio functions typically parse a format string at runtime.\nAnyway, the main point is that, because different libraries embody different design decisions regarding efficiency, extensibility, portability, type safety, and other issues, different libraries offeringg similar functionality often feature different performance trade-offs. Thus, once we\u0026rsquo;ve identified the bottlenecks in our software (via profiling, MECpp item 16), we can sometimes significantly improve the efficiency of our software by switching to libraries whose designer gave more weight to performance consideration than to other factors.\n",
  "summary": "Different libraries offering similar functionality often feature different performance trade-offs, so we might be able to remove bottlenecks by replacing one library with another.\n",
  "date": "2018-04-19T13:32:15-04:00",
  "lastmod": "2018-04-19T13:32:15-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/04/consider-alternative-libraries/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
