{
  "title": "[MECpp]Item-19 Understand the Origin of Temporary Objects",
  "content": "Unnamed non-heap objects are invisible temporary objects in C++.\nTemporary objects arise in two situations:\nwhen implicit type conversions are applied to make function calls succeed when functions return objects It\u0026rsquo;s important to understand how and why these temporary objects are created and destroyed because their construction and destruction can have noticeable impact on the performance of the program.\nImplicit conversion When the type of object passed to a function is not the same as the type of the parameter to which it is being bound, temporary objects are created during the implicit conversion to make function calls succeed.\nFor example,\n1 2 3 4 5 6 7 8 9 10 11 size_t countChar(const string\u0026amp; str, char ch); char buffer[MAX_STRING_LEN]; char c; // read in a char and a string; use setw to avoid // overflowing buffer when reading the string cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; setw(MAX_STRING_LEN) \u0026gt;\u0026gt; buffer; cout \u0026lt;\u0026lt; \u0026#34;There are \u0026#34; \u0026lt;\u0026lt; countChar(buffer, c) \u0026lt;\u0026lt; \u0026#34; occurrences of the character \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34; in \u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; endl; Here is what will happen:\nBy passing a char array into function countChar which expects a const string\u0026amp;, compilers will create a temporary object of type string constructed by calling the string constructor with buffer as its argument. The str parameter of countChar is then bound to this temporary string object. When the statement containing the call to countChar finishes executing, the temporary object is automatically destroyed. Needless to say, such implicit conversion (with pointless construction and destruction of temporary objects) is not efficient and should be eliminated:\nby redesigning the code to forbid such implicit conversion, MECpp item 5 by modifying the code the same as described in MECpp item 21 Restrictions on implicit conversion These conversions occur only when passing objects by value or when passing to a reference-to-const parameter, so when passing an object to a reference-to-non-const parameter, there is no implicit conversion. For example,\n1 2 3 void uppercasify(string\u0026amp; str); char bookTitle[] = \u0026#34;Effective C++\u0026#34;; uppercasify(bootTitle); // error! Here, temporary would not be created for parameter str, which is declared to be of type \u0026ldquo;non-const reference\u0026rdquo;, because it is the bookTitle that is supposed to be updated, instead of a newly created temporary.\nFunction return value 1 const Number operator+(const Number\u0026amp; lhs, const Number\u0026amp; rhs); The return value of operator+ is a temporary, because it is just the function\u0026rsquo;s return value and has no name, and we must pay to construct and destruct this object each time we call the function. (const is added for the same reason in MECpp item 6);\nTo avoid such costs,\nswitch to a similar function operator+=, MECpp item 22 if, in most cases, conceptually the construction and destruction can not be avoided, we optimize the program using the technique return value optimization instroduced in MECpp item 20 ",
  "summary": "Unnamed non-heap objects are invisible temporary objects in C++.\n",
  "date": "2018-04-13T17:06:28-04:00",
  "lastmod": "2018-04-13T17:06:28-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/04/understand-the-origin-of-temporary-objects/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
