{
  "title": "[MECpp]Item-9 Use Destructors to Prevent Resource Leaks",
  "content": "To avoid resource leaks in the presence of exceptions, we can encapsulate resources inside objects.\nUsing objects to manage pointer-based resource Suppose we\u0026rsquo;re writing software for a shelter names Adorable Little Animals, an organization that finds homes for puppies and kittens. Each day the shelter creates a file containing information on the adoptions it arranged that day, so we need to read these files and do the approgriate procesing for each adoption.\nA reasonable design will use polymorphism: an abstract base class ALA (\u0026ldquo;adorable little animal\u0026rdquo;), with two concrete derived classes for puppies and kittens, and a virtual function processAdoption to handle the necessary species-specific processing:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class ALA { public: virtual void processAdoption() = 0; ... }; class Puppy: public ALA { public: virtual void processAdoption(); ... }; class Kitten: public ALA { public: virtual void processAdoption(); ... }; Another thing we need is a virtual constructor (MECpp item 25), which reads information from a file and produce either a Puppy object or a Kitten object, depending on the information in the file:\n1 ALA * readALA(istream\u0026amp; s); Finally, the key processing part of the program looks like this:\n1 2 3 4 5 6 7 8 void processAdoptions(istream\u0026amp; dataSource) { while (dataSource) { ALA *pa = readALA(dataSource); pa-\u0026gt;processAdoption(); delete pa; } } However, there\u0026rsquo;s a potential resource leak: if pa-\u0026gt;processAdoption threw an exception, all statements in processAdoptions after this statement would be skipped, ending up with pa never getting deleted. To solve it, an ungly design would be:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void processAdoptions(istream\u0026amp; dataSource) { while (dataSource) { ALA *pa = readALA(dataSource); try { pa-\u0026gt;processAdoption(); } catch (...) { delete pa; // avoid resource leak when encountering exception throw; // propagate exception to caller } delete pa; // delete pa in normal condition } } The duplication in cleanup code is annoying to write and difficult to maintain. Remember that\nLocal objects are always destroyed when leaving a function, regardless of how that function is exited 1.\nSo we can move the delete into a destructor for an object local to processAdoptions, which is exactly the functionaltity smart pointers in standard C++ library provide. For example, the essential of auto_ptr (item 13, MECpp item 28) boils down to following definition:\n1 2 3 4 5 6 7 8 template\u0026lt;class T\u0026gt; class auto_ptr { public: auto_ptr(T *p = 0): ptr(p) {} // save ptr to object ~auto_ptr() { delete ptr; } // delete ptr to object private: T *ptr; // raw ptr to object }; New processAdoptions using an auto_ptr object instead of a raw pointer:\n1 2 3 4 5 6 7 void processAdoptions(istream\u0026amp; dataSource) { while (dataSource) { auto_ptr\u0026lt;ALA\u0026gt; pa(readALA(dataSource)); pa-\u0026gt;processAdoption(); } } Using objects to manage other resources The idea behind auto_ptr is to use an object to store a resource that needs to be automatically released via the object\u0026rsquo;s destructor, which applis to broader ranges of resource types as well. For example, in a GUI application that needs to create a window to display some information:\n1 2 3 4 5 6 void displayInfo(const Information\u0026amp; info) { WINDOW_HANDLE w(createWindow()); display \u0026#34;info\u0026#34; in window corresponding to \u0026#34;w\u0026#34;; destroyWindw(w); } The functions createWindow and destroyWindow for acquiring and releasing window resources should be packaged in an object to avoid resource leak in the situations where an exception is thrown during process of displaying info in w:\n1 2 3 4 5 6 7 8 9 10 11 12 // class for acquiring and releasing a window handle class WindowHandle { public: WindowHandle(WINDOW_HANDLE handle): w(handle) {} ~WindowHandle() { destroyWindow(w); } operator WINDOW_HANDLE() { return w; } // implicit convertion operator to turn a WindowHandle into a WINDOW_HANDLE private: WINDOW_HANDLE w; WindowHandle(const WindowHandle\u0026amp;); // prevent multiple copies WindowHandle\u0026amp; operator=(const WindowHandle\u0026amp;); // prevent multiple copies }; Note that the implicit conversion operator is essential to the practical application of a WindowHandle object, becauce it means we can use a WindowHandle just about anywhere we would normally use a raw WINDOW_HANDLE (refer to MECpp item 5 for downsides of doing so).\nGiven this WindowHandle class, we can rewrite desplayInfo as follows:\n1 2 3 4 5 void displayInfo(const Information\u0026amp; info) { WindowHandle w(createWindow()); display \u0026#34;info\u0026#34; in window corresponding to \u0026#34;w\u0026#34;; } // the window handled by \u0026#34;w\u0026#34; will always be released even if an exception is thrown The only exception to this rule is when we call longjmp, and this shortcoming of longjmp is the primary reason why C++ has support for exceptions in the first place.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n",
  "summary": "To avoid resource leaks in the presence of exceptions, we can encapsulate resources inside objects.\n",
  "date": "2018-04-01T00:00:00Z",
  "lastmod": "2018-04-01T00:00:00Z",
  "permalink": "https://nianze.github.io/en/notes/2018/04/use-destructors-to-prevent-resource-leaks/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
