{
  "title": "Item-3 Use const whenever possible",
  "content": "Useful tips on using const in C++.\nThe const keyword allows you to specify a semantic constraint and compilers will enforce that constraint. It is remarkably versatile:\noutside of class, you may use it for constants at global or namespace scope, as well as for objects declared static at file, function or block scope inside classes, you may use it for both static and non-static data members, for pointers when declaring functions, you may also refer const to function\u0026rsquo;s return value, function parameters, and, for member functions, to the function as a whole 1. const pointer 1 2 3 4 5 6 char greeting[] = \u0026#34;Hello\u0026#34;; char *p = greeting; // non-const pointer, non-const data const char *p = greeting; // non-const pointer, const data char * const p = greeting; // const pointer, non-const data const char * const p = greeting; // const pointer, const data char const * const p = greeting; // const pointer, const data If the const appears to the left of the asterisk, what\u0026rsquo;s pointed to is constant; if the word const appears to the right of the asterisk, the pointer itself is constant. It\u0026rsquo;s helpful to read pointer declarations right to left: const char * const p reads as \u0026ldquo;p is a constant pointer to constant chars\u0026rdquo;.\n2. const iterator STL iterators are modeled on pointers. Treat it like this:\niterator -\u0026gt; T* pointer const iterator -\u0026gt; T* const pointer const_iterator -\u0026gt; const T* pointer 1 2 3 4 5 6 7 8 9 std::vector\u0026lt;int\u0026gt; vec; ... const std::vector\u0026lt;int\u0026gt;::iterator iter = vec.begin(); // acts like T* const *iter = 10; // OK. ++iter; // error. std::vector\u0026lt;int\u0026gt;::const_iterator cIter = vec.begin(); // acts like const T* *cIter = 10; // error. ++cIter; // OK. 3. const function return value Generally speaking, having a function return a constant value is inappropriate, but sometimes doing so may reduce implicit errors out of incidence without giving up safety or efficiency.\n1 2 3 4 5 class Rational { ... // contains no operator* }; const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs); Declaring the return value of operator* to be const prevent typos like this:\n1 if (a * b = c) // meant to do a comparison for some user-defined objects 4. const function parameters const parameters act just like local const objects. Unless there\u0026rsquo;s a need to modify aparameter or local object, be sure to declare it const, for it may save you from annoying errors like if (a = b) above.\n5. const member functions The purpose of const on member functions is to identify which member functions may be invoked on const objects, which benefits us for:\nmaking the interface of a class easier to understand (which functions may modify an object and which may not) making it possible to work with const-qualified objects (which makes up a very important C++ feature: overloading member functions differing only in their constness) 5.1 Bitwise constness vs. Logical constness 5.1.1 Bitwise constness Bitwise constness: a member function is const if and only if it doesn\u0026rsquo;t modify any of the object\u0026rsquo;s data members (excluding those that are static). This is also C++\u0026rsquo;s definition of constness\nHowever, member functions that don\u0026rsquo;t act very const pass the bitwise test, such as a function including a char* const pointer manipulating a char* type class member:\n1 2 3 4 5 6 7 8 9 class CTextBlock { public: ... //inappropriate but bitwise const declaration of operator[] char\u0026amp; operator[](std::size_t position) const {return pText[position];} private: char *pText; }; Since operator[]\u0026rsquo;s implementation doesn\u0026rsquo;t modify pText in any way, compilers will happily generate code after verifying that it is indeed bitwise const. However, when you create a constant object with a particular value and invoke only const member functions on it, you can still change its value:\n1 2 3 const CTextBlock cctb(\u0026#34;Hello\u0026#34;); // declare constant object char *pc = \u0026amp;cctb[0]; // call the const operator[] *pc = \u0026#39;J\u0026#39; // cctb has value \u0026#34;Jello\u0026#34; now To solve this problem, we may store data as a string instead of communicating through a C API char*:\n1 2 3 4 5 6 7 8 9 10 11 12 class TextBlock { public: ... // operator[] for const objects const char\u0026amp; operator[] (const std::size_t position) const {return text[position];} // operator[] for non-const objects char\u0026amp; operator[] (const std::size_t position) const {return text[posion];} private: std::string text; }; Remeber the C++ feature mentioned above? By overloading operator[] and giving the different versions different return types, we can handle const and non-const TextBlock objects differently:\n1 2 3 4 5 6 7 TextBlock tb(\u0026#34;Hello\u0026#34;); const TextBlock ctb(\u0026#34;World\u0026#34;); std::cout \u0026lt;\u0026lt; tb[0]; // fine, call and reading a non-const TextBlock object tb[0] = \u0026#39;x\u0026#39;; // fine, call and writing a non-const TextBlock object std::cout \u0026lt;\u0026lt; ctb[0]; // fine, call and reading a const TextBlock object ctb[0] = \u0026#39;x\u0026#39;; // error! call to a const TextBlock object is fine // but making an assignment to returned const char\u0026amp; type gives us an error 5.1.2 Logical constness Logical constness: a const member function might modify some of the bits in the object on which it\u0026rsquo;s invoked, but only in ways that clients cannot detect.\nA typical example of logical constness shows in such a scenario: say we want to cache the length for a CTextBlock object, and we define it like as\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class CTextBlock { public: ... std::size_t length() const; private: char *pText; std::size_t textLength; book lengthIsValid; }; std::size_t CTextBlock::length() const { if(!lengthIsValid) { textLength = std::strlen(pText); // error: can\u0026#39;t asssign to textLength lengthIsValid = true; // and lengthIsValid in a const member function } return textLength; } Bitwise constness test fails and compilers complains due to the assignment to textLength and lengthIsValid, but it is supposed to be valid for const CTextBlock objects. The solution is to take advantage of C++\u0026rsquo;s keyword mutable, which frees non-static data members from the constraints of bitwise constness:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class CTextBlock { public: ... std::size_t length() const; private: char *pText; mutable std::size_t textLength; mutable book lengthIsValid; }; std::size_t CTextBlock::length() const { if(!lengthIsValid) { textLength = std::strlen(pText); // error: can\u0026#39;t asssign to textLength lengthIsValid = true; // and lengthIsValid in a const member function } return textLength; } According to the mutable\u0026rsquo;s definition, you may notice that const member function will not check bitwise constness for static data members. This is because following facts:\nThe this pointer in a const qualified member function is a const type, and this is inherently related to an instance of a class static data members are not related to a class instance For non-static data member lengthIsValid = true;, think of it as this-\u0026gt;lengthIsValid = true;, which is not compilable when the type of this is const CTextBlock* without mutable added. Think of static data member staticMember as CTextBlock::staticMember, so there\u0026rsquo;s no constraints from const type this pointer. 5.2 Avoiding duplication in const and non-const member function There are two versions of operator[] in class TextBlock, which is duplication and tempts us to have one version of operator[] call the other one. Although generally speaking casting is a bad idea, here we may find enough reasons to justify its usage so long as we use it properly (note that we call const version in non-const version, not the other way around!):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class TextBlock { public: ... const char\u0026amp; operator[](const std::size_t position) const { ... // some extra tasks such as bounds checking, ... // log access data, verify data integrity ... // to make code duplication unbearablly tedious return text[position]; } char\u0026amp; operator[](const std::size_t position) const { return const_cast\u0026lt;char\u0026amp;\u0026gt; ( // cast away const on return type static_cast\u0026lt;const TextBlock\u0026amp;\u0026gt;(*this)[position]; // add const to *this\u0026#39;s type in order to call const version of operator[] ); } }; It\u0026rsquo;s definitely worth knowing this technique of implementing a non-const member function in terms of its const twin, although the syntax is somehow ungainly.\n",
  "summary": "Useful tips on using const in C++.\n",
  "date": "2018-01-19T14:31:40-05:00",
  "lastmod": "2018-01-19T14:31:40-05:00",
  "permalink": "https://nianze.github.io/en/notes/2018/01/use-const-whenever-possible/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
