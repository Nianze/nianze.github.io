{
  "title": "Item-5 What functions C++ silently generates",
  "content": "Compilers may implicitly generate their own versions of default constructor, copy constructor, copy assignment operator, and destructor.\nAll the compiler generated functions will be both public and inline (item 30). An empty class declared like this:\n1 class Empty{}; is essentially equivalent to:\n1 2 3 4 5 6 7 8 9 class Empty { public: Empty() { ... } // default constructor Empty(const Empty\u0026amp; rhs) { ... } // copy constructor ~Empty() { ... } // destructor // will be _virtual_ only if inheriting // from a base class with virtual destructor Empty\u0026amp; operator=(const Empty\u0026amp; rhs) { ... } // copy assignment operator }; These functions are generated only if they are needed:\n1 2 3 Empty e1; // default constructor and destructor generated Empty e2(e1); // copy constructor generated e2 = e1; // copy assignment operator generated Basically, the generated default constructor and the destructor will invocate constructors and destructors of base classes and non-static data members, while the copy constructor will simply copy each non-static data member of the source object to the target object.\nspecifically,\nfor data member of user-defined type, call the data member\u0026rsquo;s copy constructor with source object\u0026rsquo;s corresponding member\u0026rsquo;s value as argument for data member of built-in type, directly copy the corresponding source data member\u0026rsquo;s bits Copy assignment operator behaves generally the same as copy constructor, but the code is only generated when the resulting code is both legal and has a reasonable chance of making sense. For example:\n1 2 3 4 5 6 7 8 9 template\u0026lt;class T\u0026gt; class NamedObject { public: NamedObject(std::string\u0026amp; name, const T\u0026amp; value); ... private: std::string\u0026amp; nameValue; // a reference const T objectValue; // a const } In below situation, implicitly generated copy assignment operator will make no sense for nameValue and illegal for objectValue:\n1 2 3 4 5 6 7 8 std::string youngMan(\u0026#34;child\u0026#34;); std::string oldMan(\u0026#34;adult\u0026#34;); NamedObject\u0026lt;int\u0026gt; p(youngMan, 10); NamedObject\u0026lt;int\u0026gt; s(oldMan, 50); p = s; // nameValue assignment will make no sense! // objectValue assignment will be illegal due to its constness Since p.nameValue and s.nameValue refer to different string object, the assignment will be in a conundrum:\nshould compiler choose to let p.nameValue refer to new string object? (actually C++ does not allow reference referring to different one)? should compiler choose to change the string content \u0026ldquo;child\u0026rdquo; to \u0026ldquo;adult\u0026rdquo;? (this will affect other objects that hold pointers or references to original string \u0026ldquo;child\u0026rdquo;) Neither will be sensible, so C++ refuses to compile the code. In this situation, a copy assignment operator must be defined manually.\nFinally, derived classes will not be able to have generated implicit copy assignment operators if base classes declare the copy assignment operator private, for derived copy assignment operators are supposed to handle base class parts, but they don\u0026rsquo;t have the right to invoke the base member functions in this situation.\n",
  "summary": "Compilers may implicitly generate their own versions of default constructor, copy constructor, copy assignment operator, and destructor.\n",
  "date": "2018-01-23T18:42:07-05:00",
  "lastmod": "2018-01-23T18:42:07-05:00",
  "permalink": "https://nianze.github.io/en/notes/2018/01/functions-silently-created/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
