{
  "title": "Item-12 Copy all parts of an object",
  "content": "Be sure to copy all of an object\u0026rsquo;s data members and all of its base class parts.\nIn a well-designed object-oriented system that encapsulate the internal parts of objects, there should only be two copying function:\ncopy constructor copy assignment operator As item 5 introduced, we may create our own versions of copy function. The thing is, while the compiler-generated ones copy all the data of the object being copied as expected, the manually defined copy functions may be implemented in the wrong way, the partial-copied way:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Customer { public: ... Customer(const Customer\u0026amp; rhs); Customer\u0026amp; operator=(const Customer\u0026amp; rhs); private: std::string name; //int age; potential new data memberf }; Customer::Customer(const Customer\u0026amp; rhs) :name(rhs.name){} // copy rhs\u0026#39;s data Customer\u0026amp; Customer::operator=(const Customer\u0026amp; rhs) { name = rhs.name; // copy rhs\u0026#39;s data return *this; // item 10 } Everything is fine here, unless there\u0026rsquo;s more data members, such as the age, added into the Customer class. Interesting thing is that even if there\u0026rsquo;s new data member added, compiler will most likely not complain about potential partial-copy problem if we don\u0026rsquo;t add the data member to the copying functions and all the constructors. So we have to rely on ourselves.\nA more subtle way to get into the problem comes from inheritance:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class PriorityCustomer: public Customer { public: ... PriorityCustomer(const PriorityCustomer\u0026amp; rhs); PriorityCustomer\u0026amp; operator=(const PriorityCustomer\u0026amp; rhs); private: int priority; }; PriorityCustomer::PriorityCustomer(const PriorityCustomer\u0026amp; rhs) : priority(rhs.priority) {} PriorityCustomer\u0026amp; PriorityCustomer::operator=(const PriorityCustomer\u0026amp; rhs) { priority = rhs.priority; return *this; } The problem here is that derived class PriorityCustomer also contains inherited data members (Customer.name) but the copying functions only cover its newly added data member (PriorityCustomer.priority), ending up with a partial-copy problem. In order to take care of the base class parts, which are typically private (item 22), we need to invoke the corresponding base class functions and implement the derived class\u0026rsquo;s copying function in this way:\n1 2 3 4 5 6 7 8 9 10 11 PriorityCustomer::PriorityCustomer(const PriorityCustomer\u0026amp; rhs) : Cutomer(rhs), // invoke vase class copy ctor priority(rhs.priority) {} PriorityCustomer\u0026amp; PriorityCustomer::operator=(const PriorityCustomer\u0026amp; rhs) { Customer::operator=(rhs); // assign base class part priority = rhs.priority; return *this; } Sometimes you may find the copy constructor and copy assignment operator share a lot of code bodies, so a good way to eliminate the duplication is to create a third (private) member function that both copying functions call. Don\u0026rsquo;t let one copying function call the other, since it makes no sense:\nYou can\u0026rsquo;t do an assignment operation even before the object get constructed and initialized. It may corrupt object if calling copy construction function in copy assignment operator. In summary, copy all parts mean:\ncopy all local data members (especially those get added later) invoke the appropriate copying function in all base classes ",
  "summary": "Be sure to copy all of an object\u0026rsquo;s data members and all of its base class parts.\n",
  "date": "2018-01-31T18:16:11-05:00",
  "lastmod": "2018-01-31T18:16:11-05:00",
  "permalink": "https://nianze.github.io/en/notes/2018/01/copy-all-parts-of-an-object/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
