{
  "title": "[EMCpp]Item-40 Use std::atomic for Concurrency, volatile for Special Memory",
  "content": "std::atomic is for data accessed from multiple threads without using mutexes (concurrent usage); volatile is for memory where reads and writes should not be optimised away (special memory).\nstd::atomic template Instantiations of std::atomic template offer operations that are guaranteed to be seen as atomic by other threads, as if they were inside a mutex-protected critical section, generally with the support of special machine instructions that are more efficient than the case of mutex. For example:\n1 2 3 4 5 std::atomic\u0026lt;int\u0026gt; ai(0); // init. ai to 0 ai = 10; // atomically set ai to 10 std::cout \u0026lt;\u0026lt; ai; // atomically read ai\u0026#39;s value ++ai; // atomically increment ai to 11 --ai; // atomically decrement ai to 10 During execution of these statements, other threads reading ai may see only values of 0, 10, or 11 (assuming, of course, this is the only thread modifying ai). Two things worth noting here:\nFor std::cout \u0026lt;\u0026lt; ai;, only the read of ai is atomic, so it\u0026rsquo;s possible that between the time ai\u0026rsquo;s value is rad and operator\u0026lt;\u0026lt; is invoked to write it to standard output, another thread may modify ai\u0026rsquo;s value. The increment and decrement of ai are read-modify-write (RMW) operations, and they execute atomatically as well, which is one of the nicest characteristics of the std::atomic types that they guarantee all member functions on std::atomic types will be seen by other threads as atomic. The use of std::atomic imposes restrictions that no code precedes a write of a std::atomic variable may take place afterwards. No reorder tricks for compiler/hardwaes for speed-up optimization purpose. In contrast, volatile offers no guarantee of operation atomicity and suffer insufficient restrictions on code reordering - basically not useful in multithreaded context. Say if we have a counter defined as volatile int vc(0), and there are two threads increment the volatile counter simultaneously, then the ending value of vc need not be 2 - the RMW operation in each of two threads may take place in any order, involving in a data race, which leading to undefined behavior according to Standard\u0026rsquo;s decree.\nThe place in which volatile shines is in the context where redundant loads and dead stores should not be optimized away, that is, we need special memory to perform such kinds of redundent reads and superfluous writes:\n1 2 3 4 5 auto y = x; // read x y = x; // read x again x = 10; // write x x = 20; // write x again The most common kind of special memory is memory used for memory-mapped I/O, which is used for communication with peripherals, e.g., external sensors or displays, printers, network ports, etc. rather than reading or writing normal memory (i.e., RAM). volatile is the way to tell compilers that we\u0026rsquo;re dealing with special memory.\nBecause std::atomic and volatile serve different purposes, they can be used together:\n1 volatile std::atomic\u0026lt;int\u0026gt; vai; // operations on vai are atomic and can\u0026#39;t be optimized away This could be useful if vai corresponded to a memory-mapped I/O location that was concurrently accessed by multiple threads.\n",
  "summary": "std::atomic is for data accessed from multiple threads without using mutexes (concurrent usage); volatile is for memory where reads and writes should not be optimised away (special memory).\n",
  "date": "2018-10-30T19:05:01-04:00",
  "lastmod": "2018-10-30T19:05:01-04:00",
  "permalink": "https://nianze.github.io/en/notes/2018/10/use-stdatomic-for-concurrency-volatile-for-special-memory/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["technique","cpp"],
  "categories": ["coding"],
  "series": ["effective c++"]
}
