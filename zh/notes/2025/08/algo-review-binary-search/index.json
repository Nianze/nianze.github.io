{
  "title": "Algo Review: Binary Search",
  "content": "A review on binary search algorithm.\nMindset model In binary search, key points:\nif right is defined as len(nums) - 1, then search space is between [left, right] termination condition: while (left \u0026lt;= right) in each shrinking iteration: left = mid + 1 and right = mid - 1 final state: left == right + 1 if right is defined as len(nums), then search space is between [left, right) termination condition: while (left \u0026lt; right) in each shrinking iteration: left = mid + 1 but right = mid final state: left == right for left bound searching, right = mid (-1) if f(mid) == target, return left (this will be immediate ceiling item if target is not in f(x)) for right bound searching, left = mid + 1 if f(mid) == target, return left - 1 (this will be immediate floor item if target is not in f(x)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # monotone function def f(x: int) -\u0026gt; int: pass # binary search to get target def binary_search(nums: List[int], target: int) -\u0026gt; int: if len(nums) == 0: return -1 left = ... # min of x right = ... + 1 # max of x while left \u0026lt; right: mid = left + (right - left) // 2 if f(mid) == target: # left bound or right bound elif f(mid) \u0026lt; target: # how to make f(x) larger elif f(mid) \u0026gt; target: # how to make f(x) smaller return left # or left - 1 ",
  "summary": "A review on binary search algorithm.\n",
  "date": "2025-08-16T02:45:44-04:00",
  "lastmod": "2025-08-16T02:45:44-04:00",
  "permalink": "https://nianze.github.io/zh/notes/2025/08/algo-review-binary-search/",
  "type": "notes",
  "kind": "page",
  "section": "notes",
  "tags": ["algorithm","binary-search"],
  "categories": ["coding"],
  "series": ["algorithm"]
}
